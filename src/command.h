/*
 Copyright 2018 Google Inc.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

#ifndef GFR_COMMAND_H
#define GFR_COMMAND_H

#define NOMINMAX
#include <vulkan/vulkan.h>

#include <memory>
#include <mutex>
#include <vector>

#include "command_common.h"
#include "command_tracker.h"
#include "descriptor_set.h"
#include "marker.h"
#include "util.h"

namespace GFR {

class Device;

// Options when dumping a command buffer to a log file.
typedef uint32_t CommandBufferDumpOptions;

struct CommandBufferDumpOption {
  static constexpr int kDefault = 0;
  static constexpr int kDumpAllCommands = 1 << 0;
};

enum class CommandState {
  kCommandNotSubmitted,  // not submitted
  kCommandPending,       // submitted, no more information available
  kCommandNotStarted,    // submitted, not started
  kCommandIncomplete,    // submitted, started, not finished
  kCommandCompleted,     // submitted and executed
  kInvalidState,
};

enum class CommandBufferState {
  // Vulkan CommandBuffer states from the spec
  // 5.1, Figure 1. Lifecycle of a command buffer
  kInitial,     // created (we have a separate state for reset)
  kRecording,   // begin called
  kExecutable,  // end called
  kPending,     // submitted
  kInvalid,     // invalid
  // Additional state since we know if a command buffer is reset
  kInitialReset,  // reset
  // The following are extensions of kPending and only can be verified when
  // a hang or crash is detected and marker values are read.
  kSubmittedExecutionNotStarted,  // submitted but not started
  kSubmittedExecutionIncomplete,  // submitted and started, but not finished
  kSubmittedExecutionCompleted,   // submitted and finished
  // The following is used for secondary command buffers when the command
  // vkCmdExecuteCommands is not submitted.
  kNotSubmitted,
};

// =================================================================================================
// CommandBuffer
// =================================================================================================
class CommandBuffer {
 public:
  CommandBuffer(Device* p_device, VkCommandPool vk_command_pool,
                VkCommandBuffer vk_command_buffer,
                const VkCommandBufferAllocateInfo* allocate_info,
                bool has_buffer_marker);
  ~CommandBuffer();

  Device* GetDevice() const { return device_; }
  VkQueue GetSubmittedQueue() const { return submitted_queue_; }
  VkFence GetSubmittedFence() const { return submitted_fence_; }
  VkCommandPool GetVkCommandPool() { return vk_command_pool_; }
  VkCommandBuffer GetVkCommandBuffer() { return vk_command_buffer_; }

  bool IsPrimaryCommandBuffer() const {
    return cb_level_ == VK_COMMAND_BUFFER_LEVEL_PRIMARY;
  }
  bool HasBufferMarker() const { return has_buffer_marker_; }

  void SetSubmitInfoId(uint64_t submit_info_id);
  uint64_t GetSubmitInfoId() { return submit_info_id_; }
  void SetInstrumentAllCommands(bool all) { instrument_all_commands_ = all; }

  bool WasSubmittedToQueue() const;
  bool StartedExecution() const;
  bool CompletedExecution() const;

  void Reset();
  void QueueSubmit(VkQueue queue, VkFence fence);

  void DumpContents(std::ostream& os, CommandBufferDumpOptions options,
                    const std::string& indent = GFR::Indent(2),
                    uint64_t secondary_cb_submit_info_id = 0,
                    CommandState vkcmd_execute_commands_command_state =
                        CommandState::kInvalidState);

  // custom command buffer functions (not autogenerated)
  VkResult PreBeginCommandBuffer(VkCommandBuffer commandBuffer,
                                 VkCommandBufferBeginInfo const* pBeginInfo);

  VkResult PostBeginCommandBuffer(VkCommandBuffer commandBuffer,
                                  VkCommandBufferBeginInfo const* pBeginInfo,
                                  VkResult result);

  VkResult PreEndCommandBuffer(VkCommandBuffer commandBuffer);

  VkResult PostEndCommandBuffer(VkCommandBuffer commandBuffer, VkResult result);

  VkResult PreResetCommandBuffer(VkCommandBuffer commandBuffer,
                                 VkCommandBufferResetFlags flags);

  VkResult PostResetCommandBuffer(VkCommandBuffer commandBuffer,
                                  VkCommandBufferResetFlags flags,
                                  VkResult result);

  CommandBuffer& operator=(const CommandBuffer&) = delete;
  CommandBuffer(const CommandBuffer&) = delete;

// =============================================================================
// Include the generated command tracking code defines
// =============================================================================
#include "command.h.inc"

 private:
  const char* GetCommandName(const Command& command);

  CommandBufferState GetCommandBufferState() const;
  CommandBufferState GetSecondaryCommandBufferState(
      CommandState vkcmd_execute_commands_command_state) const;
  std::string PrintCommandBufferState(CommandBufferState cb_state) const;
  CommandState GetCommandState(CommandBufferState cb_state,
                               const Command& command) const;
  std::string PrintCommandState(CommandState cm_state) const;

  bool DumpCmdExecuteCommands(const Command& command,
                              CommandState command_state, std::ostream& os,
                              CommandBufferDumpOptions options,
                              const std::string& indent);

  uint32_t GetLastStartedCommand() const;
  uint32_t GetLastCompleteCommand() const;

  bool DumpCommand(const Command& command, std::ostream& os,
                   const std::string& indent);
  void HandleIncompleteCommand(
      const Command& command,
      const class CommandBufferInternalState& state) const;

 private:
  Device* device_ = nullptr;
  uintptr_t vk_submit_info_ = 0;
  uint64_t submit_info_id_ = 0;
  VkCommandPool vk_command_pool_ = VK_NULL_HANDLE;
  VkCommandBuffer vk_command_buffer_ = VK_NULL_HANDLE;

  VkCommandBufferLevel cb_level_ = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
  bool cb_simultaneous_use_ = false;

  // secondary command buffer inheritance info
  VkCommandBufferInheritanceInfo* scb_inheritance_info_ = nullptr;

  bool instrument_all_commands_ = false;
  bool has_buffer_marker_ = false;

  Marker top_marker_;
  Marker bottom_marker_;

  uint32_t begin_marker_value_;
  uint32_t end_marker_value_;

  CommandBufferState buffer_state_ = CommandBufferState::kInitial;
  VkQueue submitted_queue_ = VK_NULL_HANDLE;
  VkFence submitted_fence_ = VK_NULL_HANDLE;

  CommandTracker tracker_;

  enum MarkerPosition {
    kTop,
    kBottom,
  };

  void WriteMarker(MarkerPosition position, uint32_t marker_value);
  uint32_t ReadMarker(MarkerPosition position) const;

  void WriteBeginCommandBufferMarker();
  void WriteEndCommandBufferMarker();
  void WriteBeginCommandExecutionMarker(uint32_t command_id);
  void WriteEndCommandExecutionMarker(uint32_t command_id);
};

using CommandBufferPtr = std::unique_ptr<CommandBuffer>;

}  // namespace GFR

#endif  // GFR_COMMAND_H
