/*
 * Copyright (C) 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * THIS FILE WAS GENERATED BY apic. DO NOT EDIT.
 */

// clang-format off
#include <vulkan/vulkan.h>
#include <cassert>

#include "command_common.h"
#include "command_tracker.h"

void CommandTracker::Reset()
{
  commands_.clear();
  recorder_.Reset();
}

void CommandTracker::SetNameResolver(std::ostream &os, const ObjectInfoDB *name_resolver)
{
  recorder_.SetNameResolver(os, name_resolver);
}

void CommandTracker::PrintCommandParameters(std::ostream &os, const Command &cmd, const std::string& indent)
{
  switch (cmd.type)
  {
    case Command::Type::kUnknown:
    os << "";
    break;
    case Command::Type::kBeginCommandBuffer:
    PrintBeginCommandBuffer(os, cmd, indent);
    break;
    case Command::Type::kEndCommandBuffer:
    PrintEndCommandBuffer(os, cmd, indent);
    break;
    case Command::Type::kResetCommandBuffer:
    PrintResetCommandBuffer(os, cmd, indent);
    break;
    case Command::Type::kExecuteCommands:
    PrintCmdExecuteCommands(os, cmd, indent);
    break;
    case Command::Type::kCopyBuffer:
    PrintCmdCopyBuffer(os, cmd, indent);
    break;
    case Command::Type::kCopyImage:
    PrintCmdCopyImage(os, cmd, indent);
    break;
    case Command::Type::kBlitImage:
    PrintCmdBlitImage(os, cmd, indent);
    break;
    case Command::Type::kCopyBufferToImage:
    PrintCmdCopyBufferToImage(os, cmd, indent);
    break;
    case Command::Type::kCopyImageToBuffer:
    PrintCmdCopyImageToBuffer(os, cmd, indent);
    break;
    case Command::Type::kUpdateBuffer:
    PrintCmdUpdateBuffer(os, cmd, indent);
    break;
    case Command::Type::kFillBuffer:
    PrintCmdFillBuffer(os, cmd, indent);
    break;
    case Command::Type::kClearColorImage:
    PrintCmdClearColorImage(os, cmd, indent);
    break;
    case Command::Type::kClearDepthStencilImage:
    PrintCmdClearDepthStencilImage(os, cmd, indent);
    break;
    case Command::Type::kClearAttachments:
    PrintCmdClearAttachments(os, cmd, indent);
    break;
    case Command::Type::kResolveImage:
    PrintCmdResolveImage(os, cmd, indent);
    break;
    case Command::Type::kBindDescriptorSets:
    PrintCmdBindDescriptorSets(os, cmd, indent);
    break;
    case Command::Type::kPushConstants:
    PrintCmdPushConstants(os, cmd, indent);
    break;
    case Command::Type::kBindIndexBuffer:
    PrintCmdBindIndexBuffer(os, cmd, indent);
    break;
    case Command::Type::kBindVertexBuffers:
    PrintCmdBindVertexBuffers(os, cmd, indent);
    break;
    case Command::Type::kDraw:
    PrintCmdDraw(os, cmd, indent);
    break;
    case Command::Type::kDrawIndexed:
    PrintCmdDrawIndexed(os, cmd, indent);
    break;
    case Command::Type::kDrawIndirect:
    PrintCmdDrawIndirect(os, cmd, indent);
    break;
    case Command::Type::kDrawIndexedIndirect:
    PrintCmdDrawIndexedIndirect(os, cmd, indent);
    break;
    case Command::Type::kDispatch:
    PrintCmdDispatch(os, cmd, indent);
    break;
    case Command::Type::kDispatchIndirect:
    PrintCmdDispatchIndirect(os, cmd, indent);
    break;
    case Command::Type::kBindPipeline:
    PrintCmdBindPipeline(os, cmd, indent);
    break;
    case Command::Type::kSetViewport:
    PrintCmdSetViewport(os, cmd, indent);
    break;
    case Command::Type::kSetScissor:
    PrintCmdSetScissor(os, cmd, indent);
    break;
    case Command::Type::kSetLineWidth:
    PrintCmdSetLineWidth(os, cmd, indent);
    break;
    case Command::Type::kSetDepthBias:
    PrintCmdSetDepthBias(os, cmd, indent);
    break;
    case Command::Type::kSetBlendConstants:
    PrintCmdSetBlendConstants(os, cmd, indent);
    break;
    case Command::Type::kSetDepthBounds:
    PrintCmdSetDepthBounds(os, cmd, indent);
    break;
    case Command::Type::kSetStencilCompareMask:
    PrintCmdSetStencilCompareMask(os, cmd, indent);
    break;
    case Command::Type::kSetStencilWriteMask:
    PrintCmdSetStencilWriteMask(os, cmd, indent);
    break;
    case Command::Type::kSetStencilReference:
    PrintCmdSetStencilReference(os, cmd, indent);
    break;
    case Command::Type::kBeginQuery:
    PrintCmdBeginQuery(os, cmd, indent);
    break;
    case Command::Type::kEndQuery:
    PrintCmdEndQuery(os, cmd, indent);
    break;
    case Command::Type::kResetQueryPool:
    PrintCmdResetQueryPool(os, cmd, indent);
    break;
    case Command::Type::kWriteTimestamp:
    PrintCmdWriteTimestamp(os, cmd, indent);
    break;
    case Command::Type::kCopyQueryPoolResults:
    PrintCmdCopyQueryPoolResults(os, cmd, indent);
    break;
    case Command::Type::kBeginRenderPass:
    PrintCmdBeginRenderPass(os, cmd, indent);
    break;
    case Command::Type::kNextSubpass:
    PrintCmdNextSubpass(os, cmd, indent);
    break;
    case Command::Type::kEndRenderPass:
    PrintCmdEndRenderPass(os, cmd, indent);
    break;
    case Command::Type::kSetEvent:
    PrintCmdSetEvent(os, cmd, indent);
    break;
    case Command::Type::kResetEvent:
    PrintCmdResetEvent(os, cmd, indent);
    break;
    case Command::Type::kWaitEvents:
    PrintCmdWaitEvents(os, cmd, indent);
    break;
    case Command::Type::kPipelineBarrier:
    PrintCmdPipelineBarrier(os, cmd, indent);
    break;
    case Command::Type::kWriteBufferMarkerAMD:
    PrintCmdWriteBufferMarkerAMD(os, cmd, indent);
    break;
    case Command::Type::kDrawIndirectCountAMD:
    PrintCmdDrawIndirectCountAMD(os, cmd, indent);
    break;
    case Command::Type::kDrawIndexedIndirectCountAMD:
    PrintCmdDrawIndexedIndirectCountAMD(os, cmd, indent);
    break;
    case Command::Type::kBeginConditionalRenderingEXT:
    PrintCmdBeginConditionalRenderingEXT(os, cmd, indent);
    break;
    case Command::Type::kEndConditionalRenderingEXT:
    PrintCmdEndConditionalRenderingEXT(os, cmd, indent);
    break;
    case Command::Type::kDebugMarkerBeginEXT:
    PrintCmdDebugMarkerBeginEXT(os, cmd, indent);
    break;
    case Command::Type::kDebugMarkerEndEXT:
    PrintCmdDebugMarkerEndEXT(os, cmd, indent);
    break;
    case Command::Type::kDebugMarkerInsertEXT:
    PrintCmdDebugMarkerInsertEXT(os, cmd, indent);
    break;
    case Command::Type::kBeginDebugUtilsLabelEXT:
    PrintCmdBeginDebugUtilsLabelEXT(os, cmd, indent);
    break;
    case Command::Type::kEndDebugUtilsLabelEXT:
    PrintCmdEndDebugUtilsLabelEXT(os, cmd, indent);
    break;
    case Command::Type::kInsertDebugUtilsLabelEXT:
    PrintCmdInsertDebugUtilsLabelEXT(os, cmd, indent);
    break;
    case Command::Type::kSetDeviceMaskKHR:
    PrintCmdSetDeviceMaskKHR(os, cmd, indent);
    break;
    case Command::Type::kSetDeviceMask:
    PrintCmdSetDeviceMask(os, cmd, indent);
    break;
    case Command::Type::kDispatchBaseKHR:
    PrintCmdDispatchBaseKHR(os, cmd, indent);
    break;
    case Command::Type::kDispatchBase:
    PrintCmdDispatchBase(os, cmd, indent);
    break;
    case Command::Type::kDrawIndirectCountKHR:
    PrintCmdDrawIndirectCountKHR(os, cmd, indent);
    break;
    case Command::Type::kDrawIndexedIndirectCountKHR:
    PrintCmdDrawIndexedIndirectCountKHR(os, cmd, indent);
    break;
  };
}

void CommandTracker::TrackPreBeginCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferBeginInfo const* pBeginInfo)
{
  Command cmd;
  cmd.type = Command::Type::kBeginCommandBuffer;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordBeginCommandBuffer(commandBuffer, pBeginInfo);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostBeginCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferBeginInfo const* pBeginInfo)
{
  assert(commands_.back().type == Command::Type::kBeginCommandBuffer);
}

void CommandTracker::PrintBeginCommandBuffer(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<BeginCommandBufferArgs *>(cmd.parameters);
    recorder_.PrintBeginCommandBufferArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreEndCommandBuffer(VkCommandBuffer commandBuffer)
{
  Command cmd;
  cmd.type = Command::Type::kEndCommandBuffer;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordEndCommandBuffer(commandBuffer);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostEndCommandBuffer(VkCommandBuffer commandBuffer)
{
  assert(commands_.back().type == Command::Type::kEndCommandBuffer);
}

void CommandTracker::PrintEndCommandBuffer(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<EndCommandBufferArgs *>(cmd.parameters);
    recorder_.PrintEndCommandBufferArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags)
{
  Command cmd;
  cmd.type = Command::Type::kResetCommandBuffer;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordResetCommandBuffer(commandBuffer, flags);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags)
{
  assert(commands_.back().type == Command::Type::kResetCommandBuffer);
}

void CommandTracker::PrintResetCommandBuffer(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<ResetCommandBufferArgs *>(cmd.parameters);
    recorder_.PrintResetCommandBufferArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, VkCommandBuffer const* pCommandBuffers)
{
  Command cmd;
  cmd.type = Command::Type::kExecuteCommands;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, VkCommandBuffer const* pCommandBuffers)
{
  assert(commands_.back().type == Command::Type::kExecuteCommands);
}

void CommandTracker::PrintCmdExecuteCommands(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdExecuteCommandsArgs *>(cmd.parameters);
    recorder_.PrintCmdExecuteCommandsArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, VkBufferCopy const* pRegions)
{
  Command cmd;
  cmd.type = Command::Type::kCopyBuffer;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, VkBufferCopy const* pRegions)
{
  assert(commands_.back().type == Command::Type::kCopyBuffer);
}

void CommandTracker::PrintCmdCopyBuffer(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdCopyBufferArgs *>(cmd.parameters);
    recorder_.PrintCmdCopyBufferArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageCopy const* pRegions)
{
  Command cmd;
  cmd.type = Command::Type::kCopyImage;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageCopy const* pRegions)
{
  assert(commands_.back().type == Command::Type::kCopyImage);
}

void CommandTracker::PrintCmdCopyImage(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdCopyImageArgs *>(cmd.parameters);
    recorder_.PrintCmdCopyImageArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageBlit const* pRegions, VkFilter filter)
{
  Command cmd;
  cmd.type = Command::Type::kBlitImage;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageBlit const* pRegions, VkFilter filter)
{
  assert(commands_.back().type == Command::Type::kBlitImage);
}

void CommandTracker::PrintCmdBlitImage(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdBlitImageArgs *>(cmd.parameters);
    recorder_.PrintCmdBlitImageArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkBufferImageCopy const* pRegions)
{
  Command cmd;
  cmd.type = Command::Type::kCopyBufferToImage;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkBufferImageCopy const* pRegions)
{
  assert(commands_.back().type == Command::Type::kCopyBufferToImage);
}

void CommandTracker::PrintCmdCopyBufferToImage(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdCopyBufferToImageArgs *>(cmd.parameters);
    recorder_.PrintCmdCopyBufferToImageArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, VkBufferImageCopy const* pRegions)
{
  Command cmd;
  cmd.type = Command::Type::kCopyImageToBuffer;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, VkBufferImageCopy const* pRegions)
{
  assert(commands_.back().type == Command::Type::kCopyImageToBuffer);
}

void CommandTracker::PrintCmdCopyImageToBuffer(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdCopyImageToBufferArgs *>(cmd.parameters);
    recorder_.PrintCmdCopyImageToBufferArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, void const* pData)
{
  Command cmd;
  cmd.type = Command::Type::kUpdateBuffer;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, void const* pData)
{
  assert(commands_.back().type == Command::Type::kUpdateBuffer);
}

void CommandTracker::PrintCmdUpdateBuffer(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdUpdateBufferArgs *>(cmd.parameters);
    recorder_.PrintCmdUpdateBufferArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data)
{
  Command cmd;
  cmd.type = Command::Type::kFillBuffer;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data)
{
  assert(commands_.back().type == Command::Type::kFillBuffer);
}

void CommandTracker::PrintCmdFillBuffer(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdFillBufferArgs *>(cmd.parameters);
    recorder_.PrintCmdFillBufferArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearColorValue const* pColor, uint32_t rangeCount, VkImageSubresourceRange const* pRanges)
{
  Command cmd;
  cmd.type = Command::Type::kClearColorImage;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearColorValue const* pColor, uint32_t rangeCount, VkImageSubresourceRange const* pRanges)
{
  assert(commands_.back().type == Command::Type::kClearColorImage);
}

void CommandTracker::PrintCmdClearColorImage(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdClearColorImageArgs *>(cmd.parameters);
    recorder_.PrintCmdClearColorImageArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearDepthStencilValue const* pDepthStencil, uint32_t rangeCount, VkImageSubresourceRange const* pRanges)
{
  Command cmd;
  cmd.type = Command::Type::kClearDepthStencilImage;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, VkClearDepthStencilValue const* pDepthStencil, uint32_t rangeCount, VkImageSubresourceRange const* pRanges)
{
  assert(commands_.back().type == Command::Type::kClearDepthStencilImage);
}

void CommandTracker::PrintCmdClearDepthStencilImage(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdClearDepthStencilImageArgs *>(cmd.parameters);
    recorder_.PrintCmdClearDepthStencilImageArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, VkClearAttachment const* pAttachments, uint32_t rectCount, VkClearRect const* pRects)
{
  Command cmd;
  cmd.type = Command::Type::kClearAttachments;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, VkClearAttachment const* pAttachments, uint32_t rectCount, VkClearRect const* pRects)
{
  assert(commands_.back().type == Command::Type::kClearAttachments);
}

void CommandTracker::PrintCmdClearAttachments(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdClearAttachmentsArgs *>(cmd.parameters);
    recorder_.PrintCmdClearAttachmentsArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageResolve const* pRegions)
{
  Command cmd;
  cmd.type = Command::Type::kResolveImage;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, VkImageResolve const* pRegions)
{
  assert(commands_.back().type == Command::Type::kResolveImage);
}

void CommandTracker::PrintCmdResolveImage(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdResolveImageArgs *>(cmd.parameters);
    recorder_.PrintCmdResolveImageArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, VkDescriptorSet const* pDescriptorSets, uint32_t dynamicOffsetCount, uint32_t const* pDynamicOffsets)
{
  Command cmd;
  cmd.type = Command::Type::kBindDescriptorSets;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, VkDescriptorSet const* pDescriptorSets, uint32_t dynamicOffsetCount, uint32_t const* pDynamicOffsets)
{
  assert(commands_.back().type == Command::Type::kBindDescriptorSets);
}

void CommandTracker::PrintCmdBindDescriptorSets(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdBindDescriptorSetsArgs *>(cmd.parameters);
    recorder_.PrintCmdBindDescriptorSetsArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, void const* pValues)
{
  Command cmd;
  cmd.type = Command::Type::kPushConstants;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, void const* pValues)
{
  assert(commands_.back().type == Command::Type::kPushConstants);
}

void CommandTracker::PrintCmdPushConstants(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdPushConstantsArgs *>(cmd.parameters);
    recorder_.PrintCmdPushConstantsArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType)
{
  Command cmd;
  cmd.type = Command::Type::kBindIndexBuffer;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType)
{
  assert(commands_.back().type == Command::Type::kBindIndexBuffer);
}

void CommandTracker::PrintCmdBindIndexBuffer(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdBindIndexBufferArgs *>(cmd.parameters);
    recorder_.PrintCmdBindIndexBufferArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, VkBuffer const* pBuffers, VkDeviceSize const* pOffsets)
{
  Command cmd;
  cmd.type = Command::Type::kBindVertexBuffers;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, VkBuffer const* pBuffers, VkDeviceSize const* pOffsets)
{
  assert(commands_.back().type == Command::Type::kBindVertexBuffers);
}

void CommandTracker::PrintCmdBindVertexBuffers(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdBindVertexBuffersArgs *>(cmd.parameters);
    recorder_.PrintCmdBindVertexBuffersArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance)
{
  Command cmd;
  cmd.type = Command::Type::kDraw;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance)
{
  assert(commands_.back().type == Command::Type::kDraw);
}

void CommandTracker::PrintCmdDraw(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdDrawArgs *>(cmd.parameters);
    recorder_.PrintCmdDrawArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance)
{
  Command cmd;
  cmd.type = Command::Type::kDrawIndexed;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance)
{
  assert(commands_.back().type == Command::Type::kDrawIndexed);
}

void CommandTracker::PrintCmdDrawIndexed(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdDrawIndexedArgs *>(cmd.parameters);
    recorder_.PrintCmdDrawIndexedArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
{
  Command cmd;
  cmd.type = Command::Type::kDrawIndirect;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
{
  assert(commands_.back().type == Command::Type::kDrawIndirect);
}

void CommandTracker::PrintCmdDrawIndirect(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdDrawIndirectArgs *>(cmd.parameters);
    recorder_.PrintCmdDrawIndirectArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
{
  Command cmd;
  cmd.type = Command::Type::kDrawIndexedIndirect;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
{
  assert(commands_.back().type == Command::Type::kDrawIndexedIndirect);
}

void CommandTracker::PrintCmdDrawIndexedIndirect(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdDrawIndexedIndirectArgs *>(cmd.parameters);
    recorder_.PrintCmdDrawIndexedIndirectArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{
  Command cmd;
  cmd.type = Command::Type::kDispatch;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{
  assert(commands_.back().type == Command::Type::kDispatch);
}

void CommandTracker::PrintCmdDispatch(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdDispatchArgs *>(cmd.parameters);
    recorder_.PrintCmdDispatchArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset)
{
  Command cmd;
  cmd.type = Command::Type::kDispatchIndirect;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdDispatchIndirect(commandBuffer, buffer, offset);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset)
{
  assert(commands_.back().type == Command::Type::kDispatchIndirect);
}

void CommandTracker::PrintCmdDispatchIndirect(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdDispatchIndirectArgs *>(cmd.parameters);
    recorder_.PrintCmdDispatchIndirectArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline)
{
  Command cmd;
  cmd.type = Command::Type::kBindPipeline;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline)
{
  assert(commands_.back().type == Command::Type::kBindPipeline);
}

void CommandTracker::PrintCmdBindPipeline(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdBindPipelineArgs *>(cmd.parameters);
    recorder_.PrintCmdBindPipelineArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, VkViewport const* pViewports)
{
  Command cmd;
  cmd.type = Command::Type::kSetViewport;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, VkViewport const* pViewports)
{
  assert(commands_.back().type == Command::Type::kSetViewport);
}

void CommandTracker::PrintCmdSetViewport(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdSetViewportArgs *>(cmd.parameters);
    recorder_.PrintCmdSetViewportArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, VkRect2D const* pScissors)
{
  Command cmd;
  cmd.type = Command::Type::kSetScissor;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, VkRect2D const* pScissors)
{
  assert(commands_.back().type == Command::Type::kSetScissor);
}

void CommandTracker::PrintCmdSetScissor(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdSetScissorArgs *>(cmd.parameters);
    recorder_.PrintCmdSetScissorArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth)
{
  Command cmd;
  cmd.type = Command::Type::kSetLineWidth;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdSetLineWidth(commandBuffer, lineWidth);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth)
{
  assert(commands_.back().type == Command::Type::kSetLineWidth);
}

void CommandTracker::PrintCmdSetLineWidth(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdSetLineWidthArgs *>(cmd.parameters);
    recorder_.PrintCmdSetLineWidthArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor)
{
  Command cmd;
  cmd.type = Command::Type::kSetDepthBias;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor)
{
  assert(commands_.back().type == Command::Type::kSetDepthBias);
}

void CommandTracker::PrintCmdSetDepthBias(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdSetDepthBiasArgs *>(cmd.parameters);
    recorder_.PrintCmdSetDepthBiasArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdSetBlendConstants(VkCommandBuffer commandBuffer, float blendConstants[4])
{
  Command cmd;
  cmd.type = Command::Type::kSetBlendConstants;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdSetBlendConstants(commandBuffer, blendConstants);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdSetBlendConstants(VkCommandBuffer commandBuffer, float blendConstants[4])
{
  assert(commands_.back().type == Command::Type::kSetBlendConstants);
}

void CommandTracker::PrintCmdSetBlendConstants(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdSetBlendConstantsArgs *>(cmd.parameters);
    recorder_.PrintCmdSetBlendConstantsArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds)
{
  Command cmd;
  cmd.type = Command::Type::kSetDepthBounds;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds)
{
  assert(commands_.back().type == Command::Type::kSetDepthBounds);
}

void CommandTracker::PrintCmdSetDepthBounds(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdSetDepthBoundsArgs *>(cmd.parameters);
    recorder_.PrintCmdSetDepthBoundsArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask)
{
  Command cmd;
  cmd.type = Command::Type::kSetStencilCompareMask;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask)
{
  assert(commands_.back().type == Command::Type::kSetStencilCompareMask);
}

void CommandTracker::PrintCmdSetStencilCompareMask(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdSetStencilCompareMaskArgs *>(cmd.parameters);
    recorder_.PrintCmdSetStencilCompareMaskArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask)
{
  Command cmd;
  cmd.type = Command::Type::kSetStencilWriteMask;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask)
{
  assert(commands_.back().type == Command::Type::kSetStencilWriteMask);
}

void CommandTracker::PrintCmdSetStencilWriteMask(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdSetStencilWriteMaskArgs *>(cmd.parameters);
    recorder_.PrintCmdSetStencilWriteMaskArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference)
{
  Command cmd;
  cmd.type = Command::Type::kSetStencilReference;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdSetStencilReference(commandBuffer, faceMask, reference);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference)
{
  assert(commands_.back().type == Command::Type::kSetStencilReference);
}

void CommandTracker::PrintCmdSetStencilReference(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdSetStencilReferenceArgs *>(cmd.parameters);
    recorder_.PrintCmdSetStencilReferenceArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags)
{
  Command cmd;
  cmd.type = Command::Type::kBeginQuery;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdBeginQuery(commandBuffer, queryPool, query, flags);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags)
{
  assert(commands_.back().type == Command::Type::kBeginQuery);
}

void CommandTracker::PrintCmdBeginQuery(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdBeginQueryArgs *>(cmd.parameters);
    recorder_.PrintCmdBeginQueryArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query)
{
  Command cmd;
  cmd.type = Command::Type::kEndQuery;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdEndQuery(commandBuffer, queryPool, query);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query)
{
  assert(commands_.back().type == Command::Type::kEndQuery);
}

void CommandTracker::PrintCmdEndQuery(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdEndQueryArgs *>(cmd.parameters);
    recorder_.PrintCmdEndQueryArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
{
  Command cmd;
  cmd.type = Command::Type::kResetQueryPool;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
{
  assert(commands_.back().type == Command::Type::kResetQueryPool);
}

void CommandTracker::PrintCmdResetQueryPool(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdResetQueryPoolArgs *>(cmd.parameters);
    recorder_.PrintCmdResetQueryPoolArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query)
{
  Command cmd;
  cmd.type = Command::Type::kWriteTimestamp;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query)
{
  assert(commands_.back().type == Command::Type::kWriteTimestamp);
}

void CommandTracker::PrintCmdWriteTimestamp(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdWriteTimestampArgs *>(cmd.parameters);
    recorder_.PrintCmdWriteTimestampArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags)
{
  Command cmd;
  cmd.type = Command::Type::kCopyQueryPoolResults;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags)
{
  assert(commands_.back().type == Command::Type::kCopyQueryPoolResults);
}

void CommandTracker::PrintCmdCopyQueryPoolResults(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdCopyQueryPoolResultsArgs *>(cmd.parameters);
    recorder_.PrintCmdCopyQueryPoolResultsArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdBeginRenderPass(VkCommandBuffer commandBuffer, VkRenderPassBeginInfo const* pRenderPassBegin, VkSubpassContents contents)
{
  Command cmd;
  cmd.type = Command::Type::kBeginRenderPass;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdBeginRenderPass(VkCommandBuffer commandBuffer, VkRenderPassBeginInfo const* pRenderPassBegin, VkSubpassContents contents)
{
  assert(commands_.back().type == Command::Type::kBeginRenderPass);
}

void CommandTracker::PrintCmdBeginRenderPass(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdBeginRenderPassArgs *>(cmd.parameters);
    recorder_.PrintCmdBeginRenderPassArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents)
{
  Command cmd;
  cmd.type = Command::Type::kNextSubpass;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdNextSubpass(commandBuffer, contents);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents)
{
  assert(commands_.back().type == Command::Type::kNextSubpass);
}

void CommandTracker::PrintCmdNextSubpass(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdNextSubpassArgs *>(cmd.parameters);
    recorder_.PrintCmdNextSubpassArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdEndRenderPass(VkCommandBuffer commandBuffer)
{
  Command cmd;
  cmd.type = Command::Type::kEndRenderPass;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdEndRenderPass(commandBuffer);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdEndRenderPass(VkCommandBuffer commandBuffer)
{
  assert(commands_.back().type == Command::Type::kEndRenderPass);
}

void CommandTracker::PrintCmdEndRenderPass(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdEndRenderPassArgs *>(cmd.parameters);
    recorder_.PrintCmdEndRenderPassArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
{
  Command cmd;
  cmd.type = Command::Type::kSetEvent;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdSetEvent(commandBuffer, event, stageMask);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
{
  assert(commands_.back().type == Command::Type::kSetEvent);
}

void CommandTracker::PrintCmdSetEvent(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdSetEventArgs *>(cmd.parameters);
    recorder_.PrintCmdSetEventArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
{
  Command cmd;
  cmd.type = Command::Type::kResetEvent;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdResetEvent(commandBuffer, event, stageMask);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
{
  assert(commands_.back().type == Command::Type::kResetEvent);
}

void CommandTracker::PrintCmdResetEvent(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdResetEventArgs *>(cmd.parameters);
    recorder_.PrintCmdResetEventArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, VkEvent const* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, VkMemoryBarrier const* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, VkBufferMemoryBarrier const* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, VkImageMemoryBarrier const* pImageMemoryBarriers)
{
  Command cmd;
  cmd.type = Command::Type::kWaitEvents;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, VkEvent const* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, VkMemoryBarrier const* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, VkBufferMemoryBarrier const* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, VkImageMemoryBarrier const* pImageMemoryBarriers)
{
  assert(commands_.back().type == Command::Type::kWaitEvents);
}

void CommandTracker::PrintCmdWaitEvents(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdWaitEventsArgs *>(cmd.parameters);
    recorder_.PrintCmdWaitEventsArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, VkMemoryBarrier const* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, VkBufferMemoryBarrier const* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, VkImageMemoryBarrier const* pImageMemoryBarriers)
{
  Command cmd;
  cmd.type = Command::Type::kPipelineBarrier;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, VkMemoryBarrier const* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, VkBufferMemoryBarrier const* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, VkImageMemoryBarrier const* pImageMemoryBarriers)
{
  assert(commands_.back().type == Command::Type::kPipelineBarrier);
}

void CommandTracker::PrintCmdPipelineBarrier(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdPipelineBarrierArgs *>(cmd.parameters);
    recorder_.PrintCmdPipelineBarrierArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker)
{
  Command cmd;
  cmd.type = Command::Type::kWriteBufferMarkerAMD;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker)
{
  assert(commands_.back().type == Command::Type::kWriteBufferMarkerAMD);
}

void CommandTracker::PrintCmdWriteBufferMarkerAMD(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdWriteBufferMarkerAMDArgs *>(cmd.parameters);
    recorder_.PrintCmdWriteBufferMarkerAMDArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countOffset, uint32_t maxDrawCount, uint32_t stride)
{
  Command cmd;
  cmd.type = Command::Type::kDrawIndirectCountAMD;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countOffset, maxDrawCount, stride);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countOffset, uint32_t maxDrawCount, uint32_t stride)
{
  assert(commands_.back().type == Command::Type::kDrawIndirectCountAMD);
}

void CommandTracker::PrintCmdDrawIndirectCountAMD(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdDrawIndirectCountAMDArgs *>(cmd.parameters);
    recorder_.PrintCmdDrawIndirectCountAMDArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countOffset, uint32_t maxDrawCount, uint32_t stride)
{
  Command cmd;
  cmd.type = Command::Type::kDrawIndexedIndirectCountAMD;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countOffset, maxDrawCount, stride);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countOffset, uint32_t maxDrawCount, uint32_t stride)
{
  assert(commands_.back().type == Command::Type::kDrawIndexedIndirectCountAMD);
}

void CommandTracker::PrintCmdDrawIndexedIndirectCountAMD(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdDrawIndexedIndirectCountAMDArgs *>(cmd.parameters);
    recorder_.PrintCmdDrawIndexedIndirectCountAMDArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, VkConditionalRenderingBeginInfoEXT const* pConditinalRenderingBegin)
{
  Command cmd;
  cmd.type = Command::Type::kBeginConditionalRenderingEXT;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdBeginConditionalRenderingEXT(commandBuffer, pConditinalRenderingBegin);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, VkConditionalRenderingBeginInfoEXT const* pConditinalRenderingBegin)
{
  assert(commands_.back().type == Command::Type::kBeginConditionalRenderingEXT);
}

void CommandTracker::PrintCmdBeginConditionalRenderingEXT(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdBeginConditionalRenderingEXTArgs *>(cmd.parameters);
    recorder_.PrintCmdBeginConditionalRenderingEXTArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer)
{
  Command cmd;
  cmd.type = Command::Type::kEndConditionalRenderingEXT;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdEndConditionalRenderingEXT(commandBuffer);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer)
{
  assert(commands_.back().type == Command::Type::kEndConditionalRenderingEXT);
}

void CommandTracker::PrintCmdEndConditionalRenderingEXT(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdEndConditionalRenderingEXTArgs *>(cmd.parameters);
    recorder_.PrintCmdEndConditionalRenderingEXTArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT const* pMarkerInfo)
{
  Command cmd;
  cmd.type = Command::Type::kDebugMarkerBeginEXT;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT const* pMarkerInfo)
{
  assert(commands_.back().type == Command::Type::kDebugMarkerBeginEXT);
}

void CommandTracker::PrintCmdDebugMarkerBeginEXT(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdDebugMarkerBeginEXTArgs *>(cmd.parameters);
    recorder_.PrintCmdDebugMarkerBeginEXTArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer)
{
  Command cmd;
  cmd.type = Command::Type::kDebugMarkerEndEXT;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdDebugMarkerEndEXT(commandBuffer);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer)
{
  assert(commands_.back().type == Command::Type::kDebugMarkerEndEXT);
}

void CommandTracker::PrintCmdDebugMarkerEndEXT(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdDebugMarkerEndEXTArgs *>(cmd.parameters);
    recorder_.PrintCmdDebugMarkerEndEXTArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT const* pMarkerInfo)
{
  Command cmd;
  cmd.type = Command::Type::kDebugMarkerInsertEXT;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, VkDebugMarkerMarkerInfoEXT const* pMarkerInfo)
{
  assert(commands_.back().type == Command::Type::kDebugMarkerInsertEXT);
}

void CommandTracker::PrintCmdDebugMarkerInsertEXT(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdDebugMarkerInsertEXTArgs *>(cmd.parameters);
    recorder_.PrintCmdDebugMarkerInsertEXTArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, VkDebugUtilsLabelEXT const* pLabelInfo)
{
  Command cmd;
  cmd.type = Command::Type::kBeginDebugUtilsLabelEXT;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, VkDebugUtilsLabelEXT const* pLabelInfo)
{
  assert(commands_.back().type == Command::Type::kBeginDebugUtilsLabelEXT);
}

void CommandTracker::PrintCmdBeginDebugUtilsLabelEXT(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdBeginDebugUtilsLabelEXTArgs *>(cmd.parameters);
    recorder_.PrintCmdBeginDebugUtilsLabelEXTArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer)
{
  Command cmd;
  cmd.type = Command::Type::kEndDebugUtilsLabelEXT;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdEndDebugUtilsLabelEXT(commandBuffer);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer)
{
  assert(commands_.back().type == Command::Type::kEndDebugUtilsLabelEXT);
}

void CommandTracker::PrintCmdEndDebugUtilsLabelEXT(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdEndDebugUtilsLabelEXTArgs *>(cmd.parameters);
    recorder_.PrintCmdEndDebugUtilsLabelEXTArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, VkDebugUtilsLabelEXT const* pLabelInfo)
{
  Command cmd;
  cmd.type = Command::Type::kInsertDebugUtilsLabelEXT;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, VkDebugUtilsLabelEXT const* pLabelInfo)
{
  assert(commands_.back().type == Command::Type::kInsertDebugUtilsLabelEXT);
}

void CommandTracker::PrintCmdInsertDebugUtilsLabelEXT(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdInsertDebugUtilsLabelEXTArgs *>(cmd.parameters);
    recorder_.PrintCmdInsertDebugUtilsLabelEXTArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask)
{
  Command cmd;
  cmd.type = Command::Type::kSetDeviceMaskKHR;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdSetDeviceMaskKHR(commandBuffer, deviceMask);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask)
{
  assert(commands_.back().type == Command::Type::kSetDeviceMaskKHR);
}

void CommandTracker::PrintCmdSetDeviceMaskKHR(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdSetDeviceMaskKHRArgs *>(cmd.parameters);
    recorder_.PrintCmdSetDeviceMaskKHRArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask)
{
  Command cmd;
  cmd.type = Command::Type::kSetDeviceMask;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdSetDeviceMask(commandBuffer, deviceMask);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask)
{
  assert(commands_.back().type == Command::Type::kSetDeviceMask);
}

void CommandTracker::PrintCmdSetDeviceMask(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdSetDeviceMaskArgs *>(cmd.parameters);
    recorder_.PrintCmdSetDeviceMaskArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{
  Command cmd;
  cmd.type = Command::Type::kDispatchBaseKHR;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{
  assert(commands_.back().type == Command::Type::kDispatchBaseKHR);
}

void CommandTracker::PrintCmdDispatchBaseKHR(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdDispatchBaseKHRArgs *>(cmd.parameters);
    recorder_.PrintCmdDispatchBaseKHRArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{
  Command cmd;
  cmd.type = Command::Type::kDispatchBase;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{
  assert(commands_.back().type == Command::Type::kDispatchBase);
}

void CommandTracker::PrintCmdDispatchBase(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdDispatchBaseArgs *>(cmd.parameters);
    recorder_.PrintCmdDispatchBaseArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countOffset, uint32_t maxDrawCount, uint32_t stride)
{
  Command cmd;
  cmd.type = Command::Type::kDrawIndirectCountKHR;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countOffset, maxDrawCount, stride);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countOffset, uint32_t maxDrawCount, uint32_t stride)
{
  assert(commands_.back().type == Command::Type::kDrawIndirectCountKHR);
}

void CommandTracker::PrintCmdDrawIndirectCountKHR(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdDrawIndirectCountKHRArgs *>(cmd.parameters);
    recorder_.PrintCmdDrawIndirectCountKHRArgs(os, *args, indent);
  }
}

void CommandTracker::TrackPreCmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countOffset, uint32_t maxDrawCount, uint32_t stride)
{
  Command cmd;
  cmd.type = Command::Type::kDrawIndexedIndirectCountKHR;
  cmd.id = static_cast<uint32_t>(commands_.size()) + 1;
  cmd.parameters = recorder_.RecordCmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countOffset, maxDrawCount, stride);
  commands_.push_back(cmd);
}

void CommandTracker::TrackPostCmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countOffset, uint32_t maxDrawCount, uint32_t stride)
{
  assert(commands_.back().type == Command::Type::kDrawIndexedIndirectCountKHR);
}

void CommandTracker::PrintCmdDrawIndexedIndirectCountKHR(std::ostream &os, const Command &cmd, const std::string& indent)
{
  if (cmd.parameters) {
    auto args = reinterpret_cast<CmdDrawIndexedIndirectCountKHRArgs *>(cmd.parameters);
    recorder_.PrintCmdDrawIndexedIndirectCountKHRArgs(os, *args, indent);
  }
}
