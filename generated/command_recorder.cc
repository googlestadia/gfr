/*
 * Copyright (C) 2021 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * THIS FILE IS GENERATED BY VkSpecGen. DO NOT EDIT.
 */

// clang-format off
#include <iomanip>
#include <sstream>

#include "command_common.h"
#include "command_recorder.h"
#include "object_name_db.h"

// Declare CopyArray template functions. We need this declaration since the
// templates call each other and we don't have control over the order of the
// definitions.



template<>
VkMultiDrawInfoEXT *CommandRecorder::CopyArray<VkMultiDrawInfoEXT>(const VkMultiDrawInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkMultiDrawIndexedInfoEXT *CommandRecorder::CopyArray<VkMultiDrawIndexedInfoEXT>(const VkMultiDrawIndexedInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkDisplayPropertiesKHR *CommandRecorder::CopyArray<VkDisplayPropertiesKHR>(const VkDisplayPropertiesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkDisplayPlanePropertiesKHR *CommandRecorder::CopyArray<VkDisplayPlanePropertiesKHR>(const VkDisplayPlanePropertiesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkDisplayModeParametersKHR *CommandRecorder::CopyArray<VkDisplayModeParametersKHR>(const VkDisplayModeParametersKHR *src, uint64_t start_index, uint64_t count);

template<>
VkDisplayModePropertiesKHR *CommandRecorder::CopyArray<VkDisplayModePropertiesKHR>(const VkDisplayModePropertiesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkDisplayModeCreateInfoKHR *CommandRecorder::CopyArray<VkDisplayModeCreateInfoKHR>(const VkDisplayModeCreateInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkDisplayPlaneCapabilitiesKHR *CommandRecorder::CopyArray<VkDisplayPlaneCapabilitiesKHR>(const VkDisplayPlaneCapabilitiesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkDisplaySurfaceCreateInfoKHR *CommandRecorder::CopyArray<VkDisplaySurfaceCreateInfoKHR>(const VkDisplaySurfaceCreateInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkDisplayPresentInfoKHR *CommandRecorder::CopyArray<VkDisplayPresentInfoKHR>(const VkDisplayPresentInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkSurfaceCapabilitiesKHR *CommandRecorder::CopyArray<VkSurfaceCapabilitiesKHR>(const VkSurfaceCapabilitiesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkSurfaceFormatKHR *CommandRecorder::CopyArray<VkSurfaceFormatKHR>(const VkSurfaceFormatKHR *src, uint64_t start_index, uint64_t count);

template<>
VkSwapchainCreateInfoKHR *CommandRecorder::CopyArray<VkSwapchainCreateInfoKHR>(const VkSwapchainCreateInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPresentInfoKHR *CommandRecorder::CopyArray<VkPresentInfoKHR>(const VkPresentInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkDebugReportCallbackCreateInfoEXT *CommandRecorder::CopyArray<VkDebugReportCallbackCreateInfoEXT>(const VkDebugReportCallbackCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineRasterizationStateRasterizationOrderAMD *CommandRecorder::CopyArray<VkPipelineRasterizationStateRasterizationOrderAMD>(const VkPipelineRasterizationStateRasterizationOrderAMD *src, uint64_t start_index, uint64_t count);

template<>
VkDebugMarkerObjectNameInfoEXT *CommandRecorder::CopyArray<VkDebugMarkerObjectNameInfoEXT>(const VkDebugMarkerObjectNameInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkDebugMarkerObjectTagInfoEXT *CommandRecorder::CopyArray<VkDebugMarkerObjectTagInfoEXT>(const VkDebugMarkerObjectTagInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkDebugMarkerMarkerInfoEXT *CommandRecorder::CopyArray<VkDebugMarkerMarkerInfoEXT>(const VkDebugMarkerMarkerInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceMultiDrawPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceMultiDrawPropertiesEXT>(const VkPhysicalDeviceMultiDrawPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDevicePushDescriptorPropertiesKHR *CommandRecorder::CopyArray<VkPhysicalDevicePushDescriptorPropertiesKHR>(const VkPhysicalDevicePushDescriptorPropertiesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPresentRegionsKHR *CommandRecorder::CopyArray<VkPresentRegionsKHR>(const VkPresentRegionsKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPresentRegionKHR *CommandRecorder::CopyArray<VkPresentRegionKHR>(const VkPresentRegionKHR *src, uint64_t start_index, uint64_t count);

template<>
VkRectLayerKHR *CommandRecorder::CopyArray<VkRectLayerKHR>(const VkRectLayerKHR *src, uint64_t start_index, uint64_t count);

template<>
VkImportMemoryFdInfoKHR *CommandRecorder::CopyArray<VkImportMemoryFdInfoKHR>(const VkImportMemoryFdInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkMemoryFdPropertiesKHR *CommandRecorder::CopyArray<VkMemoryFdPropertiesKHR>(const VkMemoryFdPropertiesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkMemoryGetFdInfoKHR *CommandRecorder::CopyArray<VkMemoryGetFdInfoKHR>(const VkMemoryGetFdInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkImportSemaphoreFdInfoKHR *CommandRecorder::CopyArray<VkImportSemaphoreFdInfoKHR>(const VkImportSemaphoreFdInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkSemaphoreGetFdInfoKHR *CommandRecorder::CopyArray<VkSemaphoreGetFdInfoKHR>(const VkSemaphoreGetFdInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkImportFenceFdInfoKHR *CommandRecorder::CopyArray<VkImportFenceFdInfoKHR>(const VkImportFenceFdInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkFenceGetFdInfoKHR *CommandRecorder::CopyArray<VkFenceGetFdInfoKHR>(const VkFenceGetFdInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceGroupPresentCapabilitiesKHR *CommandRecorder::CopyArray<VkDeviceGroupPresentCapabilitiesKHR>(const VkDeviceGroupPresentCapabilitiesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkImageSwapchainCreateInfoKHR *CommandRecorder::CopyArray<VkImageSwapchainCreateInfoKHR>(const VkImageSwapchainCreateInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkBindImageMemorySwapchainInfoKHR *CommandRecorder::CopyArray<VkBindImageMemorySwapchainInfoKHR>(const VkBindImageMemorySwapchainInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkAcquireNextImageInfoKHR *CommandRecorder::CopyArray<VkAcquireNextImageInfoKHR>(const VkAcquireNextImageInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceGroupPresentInfoKHR *CommandRecorder::CopyArray<VkDeviceGroupPresentInfoKHR>(const VkDeviceGroupPresentInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceGroupSwapchainCreateInfoKHR *CommandRecorder::CopyArray<VkDeviceGroupSwapchainCreateInfoKHR>(const VkDeviceGroupSwapchainCreateInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkDisplayNativeHdrSurfaceCapabilitiesAMD *CommandRecorder::CopyArray<VkDisplayNativeHdrSurfaceCapabilitiesAMD>(const VkDisplayNativeHdrSurfaceCapabilitiesAMD *src, uint64_t start_index, uint64_t count);

template<>
VkSwapchainDisplayNativeHdrCreateInfoAMD *CommandRecorder::CopyArray<VkSwapchainDisplayNativeHdrCreateInfoAMD>(const VkSwapchainDisplayNativeHdrCreateInfoAMD *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceSurfaceInfo2KHR *CommandRecorder::CopyArray<VkPhysicalDeviceSurfaceInfo2KHR>(const VkPhysicalDeviceSurfaceInfo2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkSurfaceCapabilities2KHR *CommandRecorder::CopyArray<VkSurfaceCapabilities2KHR>(const VkSurfaceCapabilities2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkSurfaceFormat2KHR *CommandRecorder::CopyArray<VkSurfaceFormat2KHR>(const VkSurfaceFormat2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkDisplayProperties2KHR *CommandRecorder::CopyArray<VkDisplayProperties2KHR>(const VkDisplayProperties2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkDisplayPlaneProperties2KHR *CommandRecorder::CopyArray<VkDisplayPlaneProperties2KHR>(const VkDisplayPlaneProperties2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkDisplayModeProperties2KHR *CommandRecorder::CopyArray<VkDisplayModeProperties2KHR>(const VkDisplayModeProperties2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkDisplayPlaneInfo2KHR *CommandRecorder::CopyArray<VkDisplayPlaneInfo2KHR>(const VkDisplayPlaneInfo2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkDisplayPlaneCapabilities2KHR *CommandRecorder::CopyArray<VkDisplayPlaneCapabilities2KHR>(const VkDisplayPlaneCapabilities2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkSharedPresentSurfaceCapabilitiesKHR *CommandRecorder::CopyArray<VkSharedPresentSurfaceCapabilitiesKHR>(const VkSharedPresentSurfaceCapabilitiesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkTextureLODGatherFormatPropertiesAMD *CommandRecorder::CopyArray<VkTextureLODGatherFormatPropertiesAMD>(const VkTextureLODGatherFormatPropertiesAMD *src, uint64_t start_index, uint64_t count);

template<>
VkSampleLocationEXT *CommandRecorder::CopyArray<VkSampleLocationEXT>(const VkSampleLocationEXT *src, uint64_t start_index, uint64_t count);

template<>
VkSampleLocationsInfoEXT *CommandRecorder::CopyArray<VkSampleLocationsInfoEXT>(const VkSampleLocationsInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkAttachmentSampleLocationsEXT *CommandRecorder::CopyArray<VkAttachmentSampleLocationsEXT>(const VkAttachmentSampleLocationsEXT *src, uint64_t start_index, uint64_t count);

template<>
VkSubpassSampleLocationsEXT *CommandRecorder::CopyArray<VkSubpassSampleLocationsEXT>(const VkSubpassSampleLocationsEXT *src, uint64_t start_index, uint64_t count);

template<>
VkRenderPassSampleLocationsBeginInfoEXT *CommandRecorder::CopyArray<VkRenderPassSampleLocationsBeginInfoEXT>(const VkRenderPassSampleLocationsBeginInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineSampleLocationsStateCreateInfoEXT *CommandRecorder::CopyArray<VkPipelineSampleLocationsStateCreateInfoEXT>(const VkPipelineSampleLocationsStateCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceSampleLocationsPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceSampleLocationsPropertiesEXT>(const VkPhysicalDeviceSampleLocationsPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkMultisamplePropertiesEXT *CommandRecorder::CopyArray<VkMultisamplePropertiesEXT>(const VkMultisamplePropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceMultiDrawFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceMultiDrawFeaturesEXT>(const VkPhysicalDeviceMultiDrawFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceInlineUniformBlockFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceInlineUniformBlockFeaturesEXT>(const VkPhysicalDeviceInlineUniformBlockFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceInlineUniformBlockPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceInlineUniformBlockPropertiesEXT>(const VkPhysicalDeviceInlineUniformBlockPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkWriteDescriptorSetInlineUniformBlockEXT *CommandRecorder::CopyArray<VkWriteDescriptorSetInlineUniformBlockEXT>(const VkWriteDescriptorSetInlineUniformBlockEXT *src, uint64_t start_index, uint64_t count);

template<>
VkDescriptorPoolInlineUniformBlockCreateInfoEXT *CommandRecorder::CopyArray<VkDescriptorPoolInlineUniformBlockCreateInfoEXT>(const VkDescriptorPoolInlineUniformBlockCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkShaderResourceUsageAMD *CommandRecorder::CopyArray<VkShaderResourceUsageAMD>(const VkShaderResourceUsageAMD *src, uint64_t start_index, uint64_t count);

template<>
VkShaderStatisticsInfoAMD *CommandRecorder::CopyArray<VkShaderStatisticsInfoAMD>(const VkShaderStatisticsInfoAMD *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceQueueGlobalPriorityCreateInfoEXT *CommandRecorder::CopyArray<VkDeviceQueueGlobalPriorityCreateInfoEXT>(const VkDeviceQueueGlobalPriorityCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT>(const VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkQueueFamilyGlobalPriorityPropertiesEXT *CommandRecorder::CopyArray<VkQueueFamilyGlobalPriorityPropertiesEXT>(const VkQueueFamilyGlobalPriorityPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkDebugUtilsObjectNameInfoEXT *CommandRecorder::CopyArray<VkDebugUtilsObjectNameInfoEXT>(const VkDebugUtilsObjectNameInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkDebugUtilsObjectTagInfoEXT *CommandRecorder::CopyArray<VkDebugUtilsObjectTagInfoEXT>(const VkDebugUtilsObjectTagInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkDebugUtilsLabelEXT *CommandRecorder::CopyArray<VkDebugUtilsLabelEXT>(const VkDebugUtilsLabelEXT *src, uint64_t start_index, uint64_t count);

template<>
VkDebugUtilsMessengerCreateInfoEXT *CommandRecorder::CopyArray<VkDebugUtilsMessengerCreateInfoEXT>(const VkDebugUtilsMessengerCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkDebugUtilsMessengerCallbackDataEXT *CommandRecorder::CopyArray<VkDebugUtilsMessengerCallbackDataEXT>(const VkDebugUtilsMessengerCallbackDataEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceDeviceMemoryReportFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>(const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceDeviceMemoryReportCreateInfoEXT *CommandRecorder::CopyArray<VkDeviceDeviceMemoryReportCreateInfoEXT>(const VkDeviceDeviceMemoryReportCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceMemoryReportCallbackDataEXT *CommandRecorder::CopyArray<VkDeviceMemoryReportCallbackDataEXT>(const VkDeviceMemoryReportCallbackDataEXT *src, uint64_t start_index, uint64_t count);

template<>
VkImportMemoryHostPointerInfoEXT *CommandRecorder::CopyArray<VkImportMemoryHostPointerInfoEXT>(const VkImportMemoryHostPointerInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkMemoryHostPointerPropertiesEXT *CommandRecorder::CopyArray<VkMemoryHostPointerPropertiesEXT>(const VkMemoryHostPointerPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceExternalMemoryHostPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(const VkPhysicalDeviceExternalMemoryHostPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkCalibratedTimestampInfoEXT *CommandRecorder::CopyArray<VkCalibratedTimestampInfoEXT>(const VkCalibratedTimestampInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceShaderCorePropertiesAMD *CommandRecorder::CopyArray<VkPhysicalDeviceShaderCorePropertiesAMD>(const VkPhysicalDeviceShaderCorePropertiesAMD *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceShaderCoreProperties2AMD *CommandRecorder::CopyArray<VkPhysicalDeviceShaderCoreProperties2AMD>(const VkPhysicalDeviceShaderCoreProperties2AMD *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDevicePCIBusInfoPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDevicePCIBusInfoPropertiesEXT>(const VkPhysicalDevicePCIBusInfoPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkRayTracingShaderGroupCreateInfoKHR *CommandRecorder::CopyArray<VkRayTracingShaderGroupCreateInfoKHR>(const VkRayTracingShaderGroupCreateInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkRayTracingPipelineCreateInfoKHR *CommandRecorder::CopyArray<VkRayTracingPipelineCreateInfoKHR>(const VkRayTracingPipelineCreateInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkWriteDescriptorSetAccelerationStructureKHR *CommandRecorder::CopyArray<VkWriteDescriptorSetAccelerationStructureKHR>(const VkWriteDescriptorSetAccelerationStructureKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceAccelerationStructureFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceAccelerationStructureFeaturesKHR>(const VkPhysicalDeviceAccelerationStructureFeaturesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceRayTracingPipelineFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingPipelineFeaturesKHR>(const VkPhysicalDeviceRayTracingPipelineFeaturesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceRayQueryFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceRayQueryFeaturesKHR>(const VkPhysicalDeviceRayQueryFeaturesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceAccelerationStructurePropertiesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceAccelerationStructurePropertiesKHR>(const VkPhysicalDeviceAccelerationStructurePropertiesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceRayTracingPipelinePropertiesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingPipelinePropertiesKHR>(const VkPhysicalDeviceRayTracingPipelinePropertiesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkStridedDeviceAddressRegionKHR *CommandRecorder::CopyArray<VkStridedDeviceAddressRegionKHR>(const VkStridedDeviceAddressRegionKHR *src, uint64_t start_index, uint64_t count);

template<>
VkTraceRaysIndirectCommandKHR *CommandRecorder::CopyArray<VkTraceRaysIndirectCommandKHR>(const VkTraceRaysIndirectCommandKHR *src, uint64_t start_index, uint64_t count);

template<>
VkDrmFormatModifierPropertiesListEXT *CommandRecorder::CopyArray<VkDrmFormatModifierPropertiesListEXT>(const VkDrmFormatModifierPropertiesListEXT *src, uint64_t start_index, uint64_t count);

template<>
VkDrmFormatModifierPropertiesEXT *CommandRecorder::CopyArray<VkDrmFormatModifierPropertiesEXT>(const VkDrmFormatModifierPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceImageDrmFormatModifierInfoEXT *CommandRecorder::CopyArray<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(const VkPhysicalDeviceImageDrmFormatModifierInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkImageDrmFormatModifierListCreateInfoEXT *CommandRecorder::CopyArray<VkImageDrmFormatModifierListCreateInfoEXT>(const VkImageDrmFormatModifierListCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkImageDrmFormatModifierExplicitCreateInfoEXT *CommandRecorder::CopyArray<VkImageDrmFormatModifierExplicitCreateInfoEXT>(const VkImageDrmFormatModifierExplicitCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkImageDrmFormatModifierPropertiesEXT *CommandRecorder::CopyArray<VkImageDrmFormatModifierPropertiesEXT>(const VkImageDrmFormatModifierPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceMemoryOverallocationCreateInfoAMD *CommandRecorder::CopyArray<VkDeviceMemoryOverallocationCreateInfoAMD>(const VkDeviceMemoryOverallocationCreateInfoAMD *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceFragmentDensityMapFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>(const VkPhysicalDeviceFragmentDensityMapFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>(const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceFragmentDensityMapPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>(const VkPhysicalDeviceFragmentDensityMapPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceFragmentDensityMap2PropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>(const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkRenderPassFragmentDensityMapCreateInfoEXT *CommandRecorder::CopyArray<VkRenderPassFragmentDensityMapCreateInfoEXT>(const VkRenderPassFragmentDensityMapCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkSurfaceProtectedCapabilitiesKHR *CommandRecorder::CopyArray<VkSurfaceProtectedCapabilitiesKHR>(const VkSurfaceProtectedCapabilitiesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceDepthClipEnableFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceDepthClipEnableFeaturesEXT>(const VkPhysicalDeviceDepthClipEnableFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineRasterizationDepthClipStateCreateInfoEXT *CommandRecorder::CopyArray<VkPipelineRasterizationDepthClipStateCreateInfoEXT>(const VkPipelineRasterizationDepthClipStateCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceMemoryBudgetPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceMemoryBudgetPropertiesEXT>(const VkPhysicalDeviceMemoryBudgetPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceMemoryPriorityFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceMemoryPriorityFeaturesEXT>(const VkPhysicalDeviceMemoryPriorityFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkMemoryPriorityAllocateInfoEXT *CommandRecorder::CopyArray<VkMemoryPriorityAllocateInfoEXT>(const VkMemoryPriorityAllocateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>(const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDevicePerformanceQueryFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDevicePerformanceQueryFeaturesKHR>(const VkPhysicalDevicePerformanceQueryFeaturesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDevicePerformanceQueryPropertiesKHR *CommandRecorder::CopyArray<VkPhysicalDevicePerformanceQueryPropertiesKHR>(const VkPhysicalDevicePerformanceQueryPropertiesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPerformanceCounterKHR *CommandRecorder::CopyArray<VkPerformanceCounterKHR>(const VkPerformanceCounterKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPerformanceCounterDescriptionKHR *CommandRecorder::CopyArray<VkPerformanceCounterDescriptionKHR>(const VkPerformanceCounterDescriptionKHR *src, uint64_t start_index, uint64_t count);

template<>
VkQueryPoolPerformanceCreateInfoKHR *CommandRecorder::CopyArray<VkQueryPoolPerformanceCreateInfoKHR>(const VkQueryPoolPerformanceCreateInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPerformanceCounterResultKHR *CommandRecorder::CopyArray<VkPerformanceCounterResultKHR>(const VkPerformanceCounterResultKHR *src, uint64_t start_index, uint64_t count);

template<>
VkAcquireProfilingLockInfoKHR *CommandRecorder::CopyArray<VkAcquireProfilingLockInfoKHR>(const VkAcquireProfilingLockInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPerformanceQuerySubmitInfoKHR *CommandRecorder::CopyArray<VkPerformanceQuerySubmitInfoKHR>(const VkPerformanceQuerySubmitInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkHeadlessSurfaceCreateInfoEXT *CommandRecorder::CopyArray<VkHeadlessSurfaceCreateInfoEXT>(const VkHeadlessSurfaceCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceShaderClockFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceShaderClockFeaturesKHR>(const VkPhysicalDeviceShaderClockFeaturesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceIndexTypeUint8FeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceIndexTypeUint8FeaturesEXT>(const VkPhysicalDeviceIndexTypeUint8FeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>(const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineInfoKHR *CommandRecorder::CopyArray<VkPipelineInfoKHR>(const VkPipelineInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineExecutablePropertiesKHR *CommandRecorder::CopyArray<VkPipelineExecutablePropertiesKHR>(const VkPipelineExecutablePropertiesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineExecutableInfoKHR *CommandRecorder::CopyArray<VkPipelineExecutableInfoKHR>(const VkPipelineExecutableInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineExecutableStatisticValueKHR *CommandRecorder::CopyArray<VkPipelineExecutableStatisticValueKHR>(const VkPipelineExecutableStatisticValueKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineExecutableStatisticKHR *CommandRecorder::CopyArray<VkPipelineExecutableStatisticKHR>(const VkPipelineExecutableStatisticKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineExecutableInternalRepresentationKHR *CommandRecorder::CopyArray<VkPipelineExecutableInternalRepresentationKHR>(const VkPipelineExecutableInternalRepresentationKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT>(const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>(const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT>(const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceSubgroupSizeControlFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT>(const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceSubgroupSizeControlPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT>(const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT *CommandRecorder::CopyArray<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT>(const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceLineRasterizationFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceLineRasterizationFeaturesEXT>(const VkPhysicalDeviceLineRasterizationFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceLineRasterizationPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceLineRasterizationPropertiesEXT>(const VkPhysicalDeviceLineRasterizationPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineRasterizationLineStateCreateInfoEXT *CommandRecorder::CopyArray<VkPipelineRasterizationLineStateCreateInfoEXT>(const VkPipelineRasterizationLineStateCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT>(const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineCompilerControlCreateInfoAMD *CommandRecorder::CopyArray<VkPipelineCompilerControlCreateInfoAMD>(const VkPipelineCompilerControlCreateInfoAMD *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceCoherentMemoryFeaturesAMD *CommandRecorder::CopyArray<VkPhysicalDeviceCoherentMemoryFeaturesAMD>(const VkPhysicalDeviceCoherentMemoryFeaturesAMD *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceToolPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceToolPropertiesEXT>(const VkPhysicalDeviceToolPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkSamplerCustomBorderColorCreateInfoEXT *CommandRecorder::CopyArray<VkSamplerCustomBorderColorCreateInfoEXT>(const VkSamplerCustomBorderColorCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceCustomBorderColorPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceCustomBorderColorPropertiesEXT>(const VkPhysicalDeviceCustomBorderColorPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceCustomBorderColorFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceCustomBorderColorFeaturesEXT>(const VkPhysicalDeviceCustomBorderColorFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceOrHostAddressKHR *CommandRecorder::CopyArray<VkDeviceOrHostAddressKHR>(const VkDeviceOrHostAddressKHR *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceOrHostAddressConstKHR *CommandRecorder::CopyArray<VkDeviceOrHostAddressConstKHR>(const VkDeviceOrHostAddressConstKHR *src, uint64_t start_index, uint64_t count);

template<>
VkAccelerationStructureGeometryTrianglesDataKHR *CommandRecorder::CopyArray<VkAccelerationStructureGeometryTrianglesDataKHR>(const VkAccelerationStructureGeometryTrianglesDataKHR *src, uint64_t start_index, uint64_t count);

template<>
VkAccelerationStructureGeometryAabbsDataKHR *CommandRecorder::CopyArray<VkAccelerationStructureGeometryAabbsDataKHR>(const VkAccelerationStructureGeometryAabbsDataKHR *src, uint64_t start_index, uint64_t count);

template<>
VkAccelerationStructureGeometryInstancesDataKHR *CommandRecorder::CopyArray<VkAccelerationStructureGeometryInstancesDataKHR>(const VkAccelerationStructureGeometryInstancesDataKHR *src, uint64_t start_index, uint64_t count);

template<>
VkAccelerationStructureGeometryDataKHR *CommandRecorder::CopyArray<VkAccelerationStructureGeometryDataKHR>(const VkAccelerationStructureGeometryDataKHR *src, uint64_t start_index, uint64_t count);

template<>
VkAccelerationStructureGeometryKHR *CommandRecorder::CopyArray<VkAccelerationStructureGeometryKHR>(const VkAccelerationStructureGeometryKHR *src, uint64_t start_index, uint64_t count);

template<>
VkAccelerationStructureBuildGeometryInfoKHR *CommandRecorder::CopyArray<VkAccelerationStructureBuildGeometryInfoKHR>(const VkAccelerationStructureBuildGeometryInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkAccelerationStructureBuildRangeInfoKHR *CommandRecorder::CopyArray<VkAccelerationStructureBuildRangeInfoKHR>(const VkAccelerationStructureBuildRangeInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkAccelerationStructureCreateInfoKHR *CommandRecorder::CopyArray<VkAccelerationStructureCreateInfoKHR>(const VkAccelerationStructureCreateInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkAabbPositionsKHR *CommandRecorder::CopyArray<VkAabbPositionsKHR>(const VkAabbPositionsKHR *src, uint64_t start_index, uint64_t count);

template<>
VkTransformMatrixKHR *CommandRecorder::CopyArray<VkTransformMatrixKHR>(const VkTransformMatrixKHR *src, uint64_t start_index, uint64_t count);

template<>
VkAccelerationStructureInstanceKHR *CommandRecorder::CopyArray<VkAccelerationStructureInstanceKHR>(const VkAccelerationStructureInstanceKHR *src, uint64_t start_index, uint64_t count);

template<>
VkAccelerationStructureDeviceAddressInfoKHR *CommandRecorder::CopyArray<VkAccelerationStructureDeviceAddressInfoKHR>(const VkAccelerationStructureDeviceAddressInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkAccelerationStructureVersionInfoKHR *CommandRecorder::CopyArray<VkAccelerationStructureVersionInfoKHR>(const VkAccelerationStructureVersionInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkCopyAccelerationStructureInfoKHR *CommandRecorder::CopyArray<VkCopyAccelerationStructureInfoKHR>(const VkCopyAccelerationStructureInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkCopyAccelerationStructureToMemoryInfoKHR *CommandRecorder::CopyArray<VkCopyAccelerationStructureToMemoryInfoKHR>(const VkCopyAccelerationStructureToMemoryInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkCopyMemoryToAccelerationStructureInfoKHR *CommandRecorder::CopyArray<VkCopyMemoryToAccelerationStructureInfoKHR>(const VkCopyMemoryToAccelerationStructureInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkRayTracingPipelineInterfaceCreateInfoKHR *CommandRecorder::CopyArray<VkRayTracingPipelineInterfaceCreateInfoKHR>(const VkRayTracingPipelineInterfaceCreateInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineLibraryCreateInfoKHR *CommandRecorder::CopyArray<VkPipelineLibraryCreateInfoKHR>(const VkPipelineLibraryCreateInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>(const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>(const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR>(const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>(const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceRobustness2FeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceRobustness2FeaturesEXT>(const VkPhysicalDeviceRobustness2FeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceRobustness2PropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceRobustness2PropertiesEXT>(const VkPhysicalDeviceRobustness2PropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceImageRobustnessFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceImageRobustnessFeaturesEXT>(const VkPhysicalDeviceImageRobustnessFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>(const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDevice4444FormatsFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDevice4444FormatsFeaturesEXT>(const VkPhysicalDevice4444FormatsFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkBufferCopy2KHR *CommandRecorder::CopyArray<VkBufferCopy2KHR>(const VkBufferCopy2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkImageCopy2KHR *CommandRecorder::CopyArray<VkImageCopy2KHR>(const VkImageCopy2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkImageBlit2KHR *CommandRecorder::CopyArray<VkImageBlit2KHR>(const VkImageBlit2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkBufferImageCopy2KHR *CommandRecorder::CopyArray<VkBufferImageCopy2KHR>(const VkBufferImageCopy2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkImageResolve2KHR *CommandRecorder::CopyArray<VkImageResolve2KHR>(const VkImageResolve2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkCopyBufferInfo2KHR *CommandRecorder::CopyArray<VkCopyBufferInfo2KHR>(const VkCopyBufferInfo2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkCopyImageInfo2KHR *CommandRecorder::CopyArray<VkCopyImageInfo2KHR>(const VkCopyImageInfo2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkBlitImageInfo2KHR *CommandRecorder::CopyArray<VkBlitImageInfo2KHR>(const VkBlitImageInfo2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkCopyBufferToImageInfo2KHR *CommandRecorder::CopyArray<VkCopyBufferToImageInfo2KHR>(const VkCopyBufferToImageInfo2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkCopyImageToBufferInfo2KHR *CommandRecorder::CopyArray<VkCopyImageToBufferInfo2KHR>(const VkCopyImageToBufferInfo2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkResolveImageInfo2KHR *CommandRecorder::CopyArray<VkResolveImageInfo2KHR>(const VkResolveImageInfo2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>(const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkFragmentShadingRateAttachmentInfoKHR *CommandRecorder::CopyArray<VkFragmentShadingRateAttachmentInfoKHR>(const VkFragmentShadingRateAttachmentInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineFragmentShadingRateStateCreateInfoKHR *CommandRecorder::CopyArray<VkPipelineFragmentShadingRateStateCreateInfoKHR>(const VkPipelineFragmentShadingRateStateCreateInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceFragmentShadingRateFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>(const VkPhysicalDeviceFragmentShadingRateFeaturesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceFragmentShadingRatePropertiesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRatePropertiesKHR>(const VkPhysicalDeviceFragmentShadingRatePropertiesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceFragmentShadingRateKHR *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRateKHR>(const VkPhysicalDeviceFragmentShadingRateKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR>(const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkAccelerationStructureBuildSizesInfoKHR *CommandRecorder::CopyArray<VkAccelerationStructureBuildSizesInfoKHR>(const VkAccelerationStructureBuildSizesInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>(const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkVertexInputBindingDescription2EXT *CommandRecorder::CopyArray<VkVertexInputBindingDescription2EXT>(const VkVertexInputBindingDescription2EXT *src, uint64_t start_index, uint64_t count);

template<>
VkVertexInputAttributeDescription2EXT *CommandRecorder::CopyArray<VkVertexInputAttributeDescription2EXT>(const VkVertexInputAttributeDescription2EXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceColorWriteEnableFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceColorWriteEnableFeaturesEXT>(const VkPhysicalDeviceColorWriteEnableFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineColorWriteCreateInfoEXT *CommandRecorder::CopyArray<VkPipelineColorWriteCreateInfoEXT>(const VkPipelineColorWriteCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkMemoryBarrier2KHR *CommandRecorder::CopyArray<VkMemoryBarrier2KHR>(const VkMemoryBarrier2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkImageMemoryBarrier2KHR *CommandRecorder::CopyArray<VkImageMemoryBarrier2KHR>(const VkImageMemoryBarrier2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkBufferMemoryBarrier2KHR *CommandRecorder::CopyArray<VkBufferMemoryBarrier2KHR>(const VkBufferMemoryBarrier2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkDependencyInfoKHR *CommandRecorder::CopyArray<VkDependencyInfoKHR>(const VkDependencyInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkSemaphoreSubmitInfoKHR *CommandRecorder::CopyArray<VkSemaphoreSubmitInfoKHR>(const VkSemaphoreSubmitInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkCommandBufferSubmitInfoKHR *CommandRecorder::CopyArray<VkCommandBufferSubmitInfoKHR>(const VkCommandBufferSubmitInfoKHR *src, uint64_t start_index, uint64_t count);

template<>
VkSubmitInfo2KHR *CommandRecorder::CopyArray<VkSubmitInfo2KHR>(const VkSubmitInfo2KHR *src, uint64_t start_index, uint64_t count);

template<>
VkQueueFamilyCheckpointProperties2NV *CommandRecorder::CopyArray<VkQueueFamilyCheckpointProperties2NV>(const VkQueueFamilyCheckpointProperties2NV *src, uint64_t start_index, uint64_t count);

template<>
VkCheckpointData2NV *CommandRecorder::CopyArray<VkCheckpointData2NV>(const VkCheckpointData2NV *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceSynchronization2FeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceSynchronization2FeaturesKHR>(const VkPhysicalDeviceSynchronization2FeaturesKHR *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>(const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceProvokingVertexFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceProvokingVertexFeaturesEXT>(const VkPhysicalDeviceProvokingVertexFeaturesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceProvokingVertexPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceProvokingVertexPropertiesEXT>(const VkPhysicalDeviceProvokingVertexPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineRasterizationProvokingVertexStateCreateInfoEXT *CommandRecorder::CopyArray<VkPipelineRasterizationProvokingVertexStateCreateInfoEXT>(const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceDrmPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceDrmPropertiesEXT>(const VkPhysicalDeviceDrmPropertiesEXT *src, uint64_t start_index, uint64_t count);

template<>
VkBaseOutStructure *CommandRecorder::CopyArray<VkBaseOutStructure>(const VkBaseOutStructure *src, uint64_t start_index, uint64_t count);

template<>
VkBaseInStructure *CommandRecorder::CopyArray<VkBaseInStructure>(const VkBaseInStructure *src, uint64_t start_index, uint64_t count);

template<>
VkOffset2D *CommandRecorder::CopyArray<VkOffset2D>(const VkOffset2D *src, uint64_t start_index, uint64_t count);

template<>
VkOffset3D *CommandRecorder::CopyArray<VkOffset3D>(const VkOffset3D *src, uint64_t start_index, uint64_t count);

template<>
VkExtent2D *CommandRecorder::CopyArray<VkExtent2D>(const VkExtent2D *src, uint64_t start_index, uint64_t count);

template<>
VkExtent3D *CommandRecorder::CopyArray<VkExtent3D>(const VkExtent3D *src, uint64_t start_index, uint64_t count);

template<>
VkViewport *CommandRecorder::CopyArray<VkViewport>(const VkViewport *src, uint64_t start_index, uint64_t count);

template<>
VkRect2D *CommandRecorder::CopyArray<VkRect2D>(const VkRect2D *src, uint64_t start_index, uint64_t count);

template<>
VkClearRect *CommandRecorder::CopyArray<VkClearRect>(const VkClearRect *src, uint64_t start_index, uint64_t count);

template<>
VkComponentMapping *CommandRecorder::CopyArray<VkComponentMapping>(const VkComponentMapping *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceProperties *CommandRecorder::CopyArray<VkPhysicalDeviceProperties>(const VkPhysicalDeviceProperties *src, uint64_t start_index, uint64_t count);

template<>
VkExtensionProperties *CommandRecorder::CopyArray<VkExtensionProperties>(const VkExtensionProperties *src, uint64_t start_index, uint64_t count);

template<>
VkLayerProperties *CommandRecorder::CopyArray<VkLayerProperties>(const VkLayerProperties *src, uint64_t start_index, uint64_t count);

template<>
VkApplicationInfo *CommandRecorder::CopyArray<VkApplicationInfo>(const VkApplicationInfo *src, uint64_t start_index, uint64_t count);

template<>
VkAllocationCallbacks *CommandRecorder::CopyArray<VkAllocationCallbacks>(const VkAllocationCallbacks *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceQueueCreateInfo *CommandRecorder::CopyArray<VkDeviceQueueCreateInfo>(const VkDeviceQueueCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceCreateInfo *CommandRecorder::CopyArray<VkDeviceCreateInfo>(const VkDeviceCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkInstanceCreateInfo *CommandRecorder::CopyArray<VkInstanceCreateInfo>(const VkInstanceCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkQueueFamilyProperties *CommandRecorder::CopyArray<VkQueueFamilyProperties>(const VkQueueFamilyProperties *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceMemoryProperties *CommandRecorder::CopyArray<VkPhysicalDeviceMemoryProperties>(const VkPhysicalDeviceMemoryProperties *src, uint64_t start_index, uint64_t count);

template<>
VkMemoryAllocateInfo *CommandRecorder::CopyArray<VkMemoryAllocateInfo>(const VkMemoryAllocateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkMemoryRequirements *CommandRecorder::CopyArray<VkMemoryRequirements>(const VkMemoryRequirements *src, uint64_t start_index, uint64_t count);

template<>
VkSparseImageFormatProperties *CommandRecorder::CopyArray<VkSparseImageFormatProperties>(const VkSparseImageFormatProperties *src, uint64_t start_index, uint64_t count);

template<>
VkSparseImageMemoryRequirements *CommandRecorder::CopyArray<VkSparseImageMemoryRequirements>(const VkSparseImageMemoryRequirements *src, uint64_t start_index, uint64_t count);

template<>
VkMemoryType *CommandRecorder::CopyArray<VkMemoryType>(const VkMemoryType *src, uint64_t start_index, uint64_t count);

template<>
VkMemoryHeap *CommandRecorder::CopyArray<VkMemoryHeap>(const VkMemoryHeap *src, uint64_t start_index, uint64_t count);

template<>
VkMappedMemoryRange *CommandRecorder::CopyArray<VkMappedMemoryRange>(const VkMappedMemoryRange *src, uint64_t start_index, uint64_t count);

template<>
VkFormatProperties *CommandRecorder::CopyArray<VkFormatProperties>(const VkFormatProperties *src, uint64_t start_index, uint64_t count);

template<>
VkImageFormatProperties *CommandRecorder::CopyArray<VkImageFormatProperties>(const VkImageFormatProperties *src, uint64_t start_index, uint64_t count);

template<>
VkDescriptorBufferInfo *CommandRecorder::CopyArray<VkDescriptorBufferInfo>(const VkDescriptorBufferInfo *src, uint64_t start_index, uint64_t count);

template<>
VkDescriptorImageInfo *CommandRecorder::CopyArray<VkDescriptorImageInfo>(const VkDescriptorImageInfo *src, uint64_t start_index, uint64_t count);

template<>
VkWriteDescriptorSet *CommandRecorder::CopyArray<VkWriteDescriptorSet>(const VkWriteDescriptorSet *src, uint64_t start_index, uint64_t count);

template<>
VkCopyDescriptorSet *CommandRecorder::CopyArray<VkCopyDescriptorSet>(const VkCopyDescriptorSet *src, uint64_t start_index, uint64_t count);

template<>
VkBufferCreateInfo *CommandRecorder::CopyArray<VkBufferCreateInfo>(const VkBufferCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkBufferViewCreateInfo *CommandRecorder::CopyArray<VkBufferViewCreateInfo>(const VkBufferViewCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkImageSubresource *CommandRecorder::CopyArray<VkImageSubresource>(const VkImageSubresource *src, uint64_t start_index, uint64_t count);

template<>
VkImageSubresourceLayers *CommandRecorder::CopyArray<VkImageSubresourceLayers>(const VkImageSubresourceLayers *src, uint64_t start_index, uint64_t count);

template<>
VkImageSubresourceRange *CommandRecorder::CopyArray<VkImageSubresourceRange>(const VkImageSubresourceRange *src, uint64_t start_index, uint64_t count);

template<>
VkMemoryBarrier *CommandRecorder::CopyArray<VkMemoryBarrier>(const VkMemoryBarrier *src, uint64_t start_index, uint64_t count);

template<>
VkBufferMemoryBarrier *CommandRecorder::CopyArray<VkBufferMemoryBarrier>(const VkBufferMemoryBarrier *src, uint64_t start_index, uint64_t count);

template<>
VkImageMemoryBarrier *CommandRecorder::CopyArray<VkImageMemoryBarrier>(const VkImageMemoryBarrier *src, uint64_t start_index, uint64_t count);

template<>
VkImageCreateInfo *CommandRecorder::CopyArray<VkImageCreateInfo>(const VkImageCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkSubresourceLayout *CommandRecorder::CopyArray<VkSubresourceLayout>(const VkSubresourceLayout *src, uint64_t start_index, uint64_t count);

template<>
VkImageViewCreateInfo *CommandRecorder::CopyArray<VkImageViewCreateInfo>(const VkImageViewCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkBufferCopy *CommandRecorder::CopyArray<VkBufferCopy>(const VkBufferCopy *src, uint64_t start_index, uint64_t count);

template<>
VkSparseMemoryBind *CommandRecorder::CopyArray<VkSparseMemoryBind>(const VkSparseMemoryBind *src, uint64_t start_index, uint64_t count);

template<>
VkSparseImageMemoryBind *CommandRecorder::CopyArray<VkSparseImageMemoryBind>(const VkSparseImageMemoryBind *src, uint64_t start_index, uint64_t count);

template<>
VkSparseBufferMemoryBindInfo *CommandRecorder::CopyArray<VkSparseBufferMemoryBindInfo>(const VkSparseBufferMemoryBindInfo *src, uint64_t start_index, uint64_t count);

template<>
VkSparseImageOpaqueMemoryBindInfo *CommandRecorder::CopyArray<VkSparseImageOpaqueMemoryBindInfo>(const VkSparseImageOpaqueMemoryBindInfo *src, uint64_t start_index, uint64_t count);

template<>
VkSparseImageMemoryBindInfo *CommandRecorder::CopyArray<VkSparseImageMemoryBindInfo>(const VkSparseImageMemoryBindInfo *src, uint64_t start_index, uint64_t count);

template<>
VkBindSparseInfo *CommandRecorder::CopyArray<VkBindSparseInfo>(const VkBindSparseInfo *src, uint64_t start_index, uint64_t count);

template<>
VkImageCopy *CommandRecorder::CopyArray<VkImageCopy>(const VkImageCopy *src, uint64_t start_index, uint64_t count);

template<>
VkImageBlit *CommandRecorder::CopyArray<VkImageBlit>(const VkImageBlit *src, uint64_t start_index, uint64_t count);

template<>
VkBufferImageCopy *CommandRecorder::CopyArray<VkBufferImageCopy>(const VkBufferImageCopy *src, uint64_t start_index, uint64_t count);

template<>
VkImageResolve *CommandRecorder::CopyArray<VkImageResolve>(const VkImageResolve *src, uint64_t start_index, uint64_t count);

template<>
VkShaderModuleCreateInfo *CommandRecorder::CopyArray<VkShaderModuleCreateInfo>(const VkShaderModuleCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkDescriptorSetLayoutBinding *CommandRecorder::CopyArray<VkDescriptorSetLayoutBinding>(const VkDescriptorSetLayoutBinding *src, uint64_t start_index, uint64_t count);

template<>
VkDescriptorSetLayoutCreateInfo *CommandRecorder::CopyArray<VkDescriptorSetLayoutCreateInfo>(const VkDescriptorSetLayoutCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkDescriptorPoolSize *CommandRecorder::CopyArray<VkDescriptorPoolSize>(const VkDescriptorPoolSize *src, uint64_t start_index, uint64_t count);

template<>
VkDescriptorPoolCreateInfo *CommandRecorder::CopyArray<VkDescriptorPoolCreateInfo>(const VkDescriptorPoolCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkDescriptorSetAllocateInfo *CommandRecorder::CopyArray<VkDescriptorSetAllocateInfo>(const VkDescriptorSetAllocateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkSpecializationMapEntry *CommandRecorder::CopyArray<VkSpecializationMapEntry>(const VkSpecializationMapEntry *src, uint64_t start_index, uint64_t count);

template<>
VkSpecializationInfo *CommandRecorder::CopyArray<VkSpecializationInfo>(const VkSpecializationInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineShaderStageCreateInfo *CommandRecorder::CopyArray<VkPipelineShaderStageCreateInfo>(const VkPipelineShaderStageCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkComputePipelineCreateInfo *CommandRecorder::CopyArray<VkComputePipelineCreateInfo>(const VkComputePipelineCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkVertexInputBindingDescription *CommandRecorder::CopyArray<VkVertexInputBindingDescription>(const VkVertexInputBindingDescription *src, uint64_t start_index, uint64_t count);

template<>
VkVertexInputAttributeDescription *CommandRecorder::CopyArray<VkVertexInputAttributeDescription>(const VkVertexInputAttributeDescription *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineVertexInputStateCreateInfo *CommandRecorder::CopyArray<VkPipelineVertexInputStateCreateInfo>(const VkPipelineVertexInputStateCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineInputAssemblyStateCreateInfo *CommandRecorder::CopyArray<VkPipelineInputAssemblyStateCreateInfo>(const VkPipelineInputAssemblyStateCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineTessellationStateCreateInfo *CommandRecorder::CopyArray<VkPipelineTessellationStateCreateInfo>(const VkPipelineTessellationStateCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineViewportStateCreateInfo *CommandRecorder::CopyArray<VkPipelineViewportStateCreateInfo>(const VkPipelineViewportStateCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineRasterizationStateCreateInfo *CommandRecorder::CopyArray<VkPipelineRasterizationStateCreateInfo>(const VkPipelineRasterizationStateCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineMultisampleStateCreateInfo *CommandRecorder::CopyArray<VkPipelineMultisampleStateCreateInfo>(const VkPipelineMultisampleStateCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineColorBlendAttachmentState *CommandRecorder::CopyArray<VkPipelineColorBlendAttachmentState>(const VkPipelineColorBlendAttachmentState *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineColorBlendStateCreateInfo *CommandRecorder::CopyArray<VkPipelineColorBlendStateCreateInfo>(const VkPipelineColorBlendStateCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineDynamicStateCreateInfo *CommandRecorder::CopyArray<VkPipelineDynamicStateCreateInfo>(const VkPipelineDynamicStateCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkStencilOpState *CommandRecorder::CopyArray<VkStencilOpState>(const VkStencilOpState *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineDepthStencilStateCreateInfo *CommandRecorder::CopyArray<VkPipelineDepthStencilStateCreateInfo>(const VkPipelineDepthStencilStateCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkGraphicsPipelineCreateInfo *CommandRecorder::CopyArray<VkGraphicsPipelineCreateInfo>(const VkGraphicsPipelineCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineCacheCreateInfo *CommandRecorder::CopyArray<VkPipelineCacheCreateInfo>(const VkPipelineCacheCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPushConstantRange *CommandRecorder::CopyArray<VkPushConstantRange>(const VkPushConstantRange *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineLayoutCreateInfo *CommandRecorder::CopyArray<VkPipelineLayoutCreateInfo>(const VkPipelineLayoutCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkSamplerCreateInfo *CommandRecorder::CopyArray<VkSamplerCreateInfo>(const VkSamplerCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkCommandPoolCreateInfo *CommandRecorder::CopyArray<VkCommandPoolCreateInfo>(const VkCommandPoolCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkCommandBufferAllocateInfo *CommandRecorder::CopyArray<VkCommandBufferAllocateInfo>(const VkCommandBufferAllocateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkCommandBufferInheritanceInfo *CommandRecorder::CopyArray<VkCommandBufferInheritanceInfo>(const VkCommandBufferInheritanceInfo *src, uint64_t start_index, uint64_t count);

template<>
VkCommandBufferBeginInfo *CommandRecorder::CopyArray<VkCommandBufferBeginInfo>(const VkCommandBufferBeginInfo *src, uint64_t start_index, uint64_t count);

template<>
VkRenderPassBeginInfo *CommandRecorder::CopyArray<VkRenderPassBeginInfo>(const VkRenderPassBeginInfo *src, uint64_t start_index, uint64_t count);

template<>
VkClearColorValue *CommandRecorder::CopyArray<VkClearColorValue>(const VkClearColorValue *src, uint64_t start_index, uint64_t count);

template<>
VkClearDepthStencilValue *CommandRecorder::CopyArray<VkClearDepthStencilValue>(const VkClearDepthStencilValue *src, uint64_t start_index, uint64_t count);

template<>
VkClearValue *CommandRecorder::CopyArray<VkClearValue>(const VkClearValue *src, uint64_t start_index, uint64_t count);

template<>
VkClearAttachment *CommandRecorder::CopyArray<VkClearAttachment>(const VkClearAttachment *src, uint64_t start_index, uint64_t count);

template<>
VkAttachmentDescription *CommandRecorder::CopyArray<VkAttachmentDescription>(const VkAttachmentDescription *src, uint64_t start_index, uint64_t count);

template<>
VkAttachmentReference *CommandRecorder::CopyArray<VkAttachmentReference>(const VkAttachmentReference *src, uint64_t start_index, uint64_t count);

template<>
VkSubpassDescription *CommandRecorder::CopyArray<VkSubpassDescription>(const VkSubpassDescription *src, uint64_t start_index, uint64_t count);

template<>
VkSubpassDependency *CommandRecorder::CopyArray<VkSubpassDependency>(const VkSubpassDependency *src, uint64_t start_index, uint64_t count);

template<>
VkRenderPassCreateInfo *CommandRecorder::CopyArray<VkRenderPassCreateInfo>(const VkRenderPassCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkEventCreateInfo *CommandRecorder::CopyArray<VkEventCreateInfo>(const VkEventCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkFenceCreateInfo *CommandRecorder::CopyArray<VkFenceCreateInfo>(const VkFenceCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceFeatures>(const VkPhysicalDeviceFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceSparseProperties *CommandRecorder::CopyArray<VkPhysicalDeviceSparseProperties>(const VkPhysicalDeviceSparseProperties *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceLimits *CommandRecorder::CopyArray<VkPhysicalDeviceLimits>(const VkPhysicalDeviceLimits *src, uint64_t start_index, uint64_t count);

template<>
VkSemaphoreCreateInfo *CommandRecorder::CopyArray<VkSemaphoreCreateInfo>(const VkSemaphoreCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkQueryPoolCreateInfo *CommandRecorder::CopyArray<VkQueryPoolCreateInfo>(const VkQueryPoolCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkFramebufferCreateInfo *CommandRecorder::CopyArray<VkFramebufferCreateInfo>(const VkFramebufferCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkDrawIndirectCommand *CommandRecorder::CopyArray<VkDrawIndirectCommand>(const VkDrawIndirectCommand *src, uint64_t start_index, uint64_t count);

template<>
VkDrawIndexedIndirectCommand *CommandRecorder::CopyArray<VkDrawIndexedIndirectCommand>(const VkDrawIndexedIndirectCommand *src, uint64_t start_index, uint64_t count);

template<>
VkDispatchIndirectCommand *CommandRecorder::CopyArray<VkDispatchIndirectCommand>(const VkDispatchIndirectCommand *src, uint64_t start_index, uint64_t count);

template<>
VkSubmitInfo *CommandRecorder::CopyArray<VkSubmitInfo>(const VkSubmitInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceFeatures2 *CommandRecorder::CopyArray<VkPhysicalDeviceFeatures2>(const VkPhysicalDeviceFeatures2 *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceProperties2 *CommandRecorder::CopyArray<VkPhysicalDeviceProperties2>(const VkPhysicalDeviceProperties2 *src, uint64_t start_index, uint64_t count);

template<>
VkFormatProperties2 *CommandRecorder::CopyArray<VkFormatProperties2>(const VkFormatProperties2 *src, uint64_t start_index, uint64_t count);

template<>
VkImageFormatProperties2 *CommandRecorder::CopyArray<VkImageFormatProperties2>(const VkImageFormatProperties2 *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceImageFormatInfo2 *CommandRecorder::CopyArray<VkPhysicalDeviceImageFormatInfo2>(const VkPhysicalDeviceImageFormatInfo2 *src, uint64_t start_index, uint64_t count);

template<>
VkQueueFamilyProperties2 *CommandRecorder::CopyArray<VkQueueFamilyProperties2>(const VkQueueFamilyProperties2 *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceMemoryProperties2 *CommandRecorder::CopyArray<VkPhysicalDeviceMemoryProperties2>(const VkPhysicalDeviceMemoryProperties2 *src, uint64_t start_index, uint64_t count);

template<>
VkSparseImageFormatProperties2 *CommandRecorder::CopyArray<VkSparseImageFormatProperties2>(const VkSparseImageFormatProperties2 *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceSparseImageFormatInfo2 *CommandRecorder::CopyArray<VkPhysicalDeviceSparseImageFormatInfo2>(const VkPhysicalDeviceSparseImageFormatInfo2 *src, uint64_t start_index, uint64_t count);

template<>
VkConformanceVersion *CommandRecorder::CopyArray<VkConformanceVersion>(const VkConformanceVersion *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceDriverProperties *CommandRecorder::CopyArray<VkPhysicalDeviceDriverProperties>(const VkPhysicalDeviceDriverProperties *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceVariablePointersFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceVariablePointersFeatures>(const VkPhysicalDeviceVariablePointersFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkExternalMemoryProperties *CommandRecorder::CopyArray<VkExternalMemoryProperties>(const VkExternalMemoryProperties *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceExternalImageFormatInfo *CommandRecorder::CopyArray<VkPhysicalDeviceExternalImageFormatInfo>(const VkPhysicalDeviceExternalImageFormatInfo *src, uint64_t start_index, uint64_t count);

template<>
VkExternalImageFormatProperties *CommandRecorder::CopyArray<VkExternalImageFormatProperties>(const VkExternalImageFormatProperties *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceExternalBufferInfo *CommandRecorder::CopyArray<VkPhysicalDeviceExternalBufferInfo>(const VkPhysicalDeviceExternalBufferInfo *src, uint64_t start_index, uint64_t count);

template<>
VkExternalBufferProperties *CommandRecorder::CopyArray<VkExternalBufferProperties>(const VkExternalBufferProperties *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceIDProperties *CommandRecorder::CopyArray<VkPhysicalDeviceIDProperties>(const VkPhysicalDeviceIDProperties *src, uint64_t start_index, uint64_t count);

template<>
VkExternalMemoryImageCreateInfo *CommandRecorder::CopyArray<VkExternalMemoryImageCreateInfo>(const VkExternalMemoryImageCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkExternalMemoryBufferCreateInfo *CommandRecorder::CopyArray<VkExternalMemoryBufferCreateInfo>(const VkExternalMemoryBufferCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkExportMemoryAllocateInfo *CommandRecorder::CopyArray<VkExportMemoryAllocateInfo>(const VkExportMemoryAllocateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceExternalSemaphoreInfo *CommandRecorder::CopyArray<VkPhysicalDeviceExternalSemaphoreInfo>(const VkPhysicalDeviceExternalSemaphoreInfo *src, uint64_t start_index, uint64_t count);

template<>
VkExternalSemaphoreProperties *CommandRecorder::CopyArray<VkExternalSemaphoreProperties>(const VkExternalSemaphoreProperties *src, uint64_t start_index, uint64_t count);

template<>
VkExportSemaphoreCreateInfo *CommandRecorder::CopyArray<VkExportSemaphoreCreateInfo>(const VkExportSemaphoreCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceExternalFenceInfo *CommandRecorder::CopyArray<VkPhysicalDeviceExternalFenceInfo>(const VkPhysicalDeviceExternalFenceInfo *src, uint64_t start_index, uint64_t count);

template<>
VkExternalFenceProperties *CommandRecorder::CopyArray<VkExternalFenceProperties>(const VkExternalFenceProperties *src, uint64_t start_index, uint64_t count);

template<>
VkExportFenceCreateInfo *CommandRecorder::CopyArray<VkExportFenceCreateInfo>(const VkExportFenceCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceMultiviewFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceMultiviewFeatures>(const VkPhysicalDeviceMultiviewFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceMultiviewProperties *CommandRecorder::CopyArray<VkPhysicalDeviceMultiviewProperties>(const VkPhysicalDeviceMultiviewProperties *src, uint64_t start_index, uint64_t count);

template<>
VkRenderPassMultiviewCreateInfo *CommandRecorder::CopyArray<VkRenderPassMultiviewCreateInfo>(const VkRenderPassMultiviewCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceGroupProperties *CommandRecorder::CopyArray<VkPhysicalDeviceGroupProperties>(const VkPhysicalDeviceGroupProperties *src, uint64_t start_index, uint64_t count);

template<>
VkMemoryAllocateFlagsInfo *CommandRecorder::CopyArray<VkMemoryAllocateFlagsInfo>(const VkMemoryAllocateFlagsInfo *src, uint64_t start_index, uint64_t count);

template<>
VkBindBufferMemoryInfo *CommandRecorder::CopyArray<VkBindBufferMemoryInfo>(const VkBindBufferMemoryInfo *src, uint64_t start_index, uint64_t count);

template<>
VkBindBufferMemoryDeviceGroupInfo *CommandRecorder::CopyArray<VkBindBufferMemoryDeviceGroupInfo>(const VkBindBufferMemoryDeviceGroupInfo *src, uint64_t start_index, uint64_t count);

template<>
VkBindImageMemoryInfo *CommandRecorder::CopyArray<VkBindImageMemoryInfo>(const VkBindImageMemoryInfo *src, uint64_t start_index, uint64_t count);

template<>
VkBindImageMemoryDeviceGroupInfo *CommandRecorder::CopyArray<VkBindImageMemoryDeviceGroupInfo>(const VkBindImageMemoryDeviceGroupInfo *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceGroupRenderPassBeginInfo *CommandRecorder::CopyArray<VkDeviceGroupRenderPassBeginInfo>(const VkDeviceGroupRenderPassBeginInfo *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceGroupCommandBufferBeginInfo *CommandRecorder::CopyArray<VkDeviceGroupCommandBufferBeginInfo>(const VkDeviceGroupCommandBufferBeginInfo *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceGroupSubmitInfo *CommandRecorder::CopyArray<VkDeviceGroupSubmitInfo>(const VkDeviceGroupSubmitInfo *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceGroupBindSparseInfo *CommandRecorder::CopyArray<VkDeviceGroupBindSparseInfo>(const VkDeviceGroupBindSparseInfo *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceGroupDeviceCreateInfo *CommandRecorder::CopyArray<VkDeviceGroupDeviceCreateInfo>(const VkDeviceGroupDeviceCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkDescriptorUpdateTemplateEntry *CommandRecorder::CopyArray<VkDescriptorUpdateTemplateEntry>(const VkDescriptorUpdateTemplateEntry *src, uint64_t start_index, uint64_t count);

template<>
VkDescriptorUpdateTemplateCreateInfo *CommandRecorder::CopyArray<VkDescriptorUpdateTemplateCreateInfo>(const VkDescriptorUpdateTemplateCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkInputAttachmentAspectReference *CommandRecorder::CopyArray<VkInputAttachmentAspectReference>(const VkInputAttachmentAspectReference *src, uint64_t start_index, uint64_t count);

template<>
VkRenderPassInputAttachmentAspectCreateInfo *CommandRecorder::CopyArray<VkRenderPassInputAttachmentAspectCreateInfo>(const VkRenderPassInputAttachmentAspectCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDevice16BitStorageFeatures *CommandRecorder::CopyArray<VkPhysicalDevice16BitStorageFeatures>(const VkPhysicalDevice16BitStorageFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceSubgroupProperties *CommandRecorder::CopyArray<VkPhysicalDeviceSubgroupProperties>(const VkPhysicalDeviceSubgroupProperties *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>(const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkBufferMemoryRequirementsInfo2 *CommandRecorder::CopyArray<VkBufferMemoryRequirementsInfo2>(const VkBufferMemoryRequirementsInfo2 *src, uint64_t start_index, uint64_t count);

template<>
VkImageMemoryRequirementsInfo2 *CommandRecorder::CopyArray<VkImageMemoryRequirementsInfo2>(const VkImageMemoryRequirementsInfo2 *src, uint64_t start_index, uint64_t count);

template<>
VkImageSparseMemoryRequirementsInfo2 *CommandRecorder::CopyArray<VkImageSparseMemoryRequirementsInfo2>(const VkImageSparseMemoryRequirementsInfo2 *src, uint64_t start_index, uint64_t count);

template<>
VkMemoryRequirements2 *CommandRecorder::CopyArray<VkMemoryRequirements2>(const VkMemoryRequirements2 *src, uint64_t start_index, uint64_t count);

template<>
VkSparseImageMemoryRequirements2 *CommandRecorder::CopyArray<VkSparseImageMemoryRequirements2>(const VkSparseImageMemoryRequirements2 *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDevicePointClippingProperties *CommandRecorder::CopyArray<VkPhysicalDevicePointClippingProperties>(const VkPhysicalDevicePointClippingProperties *src, uint64_t start_index, uint64_t count);

template<>
VkMemoryDedicatedRequirements *CommandRecorder::CopyArray<VkMemoryDedicatedRequirements>(const VkMemoryDedicatedRequirements *src, uint64_t start_index, uint64_t count);

template<>
VkMemoryDedicatedAllocateInfo *CommandRecorder::CopyArray<VkMemoryDedicatedAllocateInfo>(const VkMemoryDedicatedAllocateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkImageViewUsageCreateInfo *CommandRecorder::CopyArray<VkImageViewUsageCreateInfo>(const VkImageViewUsageCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPipelineTessellationDomainOriginStateCreateInfo *CommandRecorder::CopyArray<VkPipelineTessellationDomainOriginStateCreateInfo>(const VkPipelineTessellationDomainOriginStateCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkSamplerYcbcrConversionInfo *CommandRecorder::CopyArray<VkSamplerYcbcrConversionInfo>(const VkSamplerYcbcrConversionInfo *src, uint64_t start_index, uint64_t count);

template<>
VkSamplerYcbcrConversionCreateInfo *CommandRecorder::CopyArray<VkSamplerYcbcrConversionCreateInfo>(const VkSamplerYcbcrConversionCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkBindImagePlaneMemoryInfo *CommandRecorder::CopyArray<VkBindImagePlaneMemoryInfo>(const VkBindImagePlaneMemoryInfo *src, uint64_t start_index, uint64_t count);

template<>
VkImagePlaneMemoryRequirementsInfo *CommandRecorder::CopyArray<VkImagePlaneMemoryRequirementsInfo>(const VkImagePlaneMemoryRequirementsInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceSamplerYcbcrConversionFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceSamplerYcbcrConversionFeatures>(const VkPhysicalDeviceSamplerYcbcrConversionFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkSamplerYcbcrConversionImageFormatProperties *CommandRecorder::CopyArray<VkSamplerYcbcrConversionImageFormatProperties>(const VkSamplerYcbcrConversionImageFormatProperties *src, uint64_t start_index, uint64_t count);

template<>
VkProtectedSubmitInfo *CommandRecorder::CopyArray<VkProtectedSubmitInfo>(const VkProtectedSubmitInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceProtectedMemoryFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceProtectedMemoryFeatures>(const VkPhysicalDeviceProtectedMemoryFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceProtectedMemoryProperties *CommandRecorder::CopyArray<VkPhysicalDeviceProtectedMemoryProperties>(const VkPhysicalDeviceProtectedMemoryProperties *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceQueueInfo2 *CommandRecorder::CopyArray<VkDeviceQueueInfo2>(const VkDeviceQueueInfo2 *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceSamplerFilterMinmaxProperties *CommandRecorder::CopyArray<VkPhysicalDeviceSamplerFilterMinmaxProperties>(const VkPhysicalDeviceSamplerFilterMinmaxProperties *src, uint64_t start_index, uint64_t count);

template<>
VkSamplerReductionModeCreateInfo *CommandRecorder::CopyArray<VkSamplerReductionModeCreateInfo>(const VkSamplerReductionModeCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkImageFormatListCreateInfo *CommandRecorder::CopyArray<VkImageFormatListCreateInfo>(const VkImageFormatListCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceMaintenance3Properties *CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance3Properties>(const VkPhysicalDeviceMaintenance3Properties *src, uint64_t start_index, uint64_t count);

template<>
VkDescriptorSetLayoutSupport *CommandRecorder::CopyArray<VkDescriptorSetLayoutSupport>(const VkDescriptorSetLayoutSupport *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceShaderDrawParametersFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceShaderDrawParametersFeatures>(const VkPhysicalDeviceShaderDrawParametersFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceShaderFloat16Int8Features *CommandRecorder::CopyArray<VkPhysicalDeviceShaderFloat16Int8Features>(const VkPhysicalDeviceShaderFloat16Int8Features *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceFloatControlsProperties *CommandRecorder::CopyArray<VkPhysicalDeviceFloatControlsProperties>(const VkPhysicalDeviceFloatControlsProperties *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceHostQueryResetFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceHostQueryResetFeatures>(const VkPhysicalDeviceHostQueryResetFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceDescriptorIndexingFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorIndexingFeatures>(const VkPhysicalDeviceDescriptorIndexingFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceDescriptorIndexingProperties *CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorIndexingProperties>(const VkPhysicalDeviceDescriptorIndexingProperties *src, uint64_t start_index, uint64_t count);

template<>
VkDescriptorSetLayoutBindingFlagsCreateInfo *CommandRecorder::CopyArray<VkDescriptorSetLayoutBindingFlagsCreateInfo>(const VkDescriptorSetLayoutBindingFlagsCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkDescriptorSetVariableDescriptorCountAllocateInfo *CommandRecorder::CopyArray<VkDescriptorSetVariableDescriptorCountAllocateInfo>(const VkDescriptorSetVariableDescriptorCountAllocateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkDescriptorSetVariableDescriptorCountLayoutSupport *CommandRecorder::CopyArray<VkDescriptorSetVariableDescriptorCountLayoutSupport>(const VkDescriptorSetVariableDescriptorCountLayoutSupport *src, uint64_t start_index, uint64_t count);

template<>
VkAttachmentDescription2 *CommandRecorder::CopyArray<VkAttachmentDescription2>(const VkAttachmentDescription2 *src, uint64_t start_index, uint64_t count);

template<>
VkAttachmentReference2 *CommandRecorder::CopyArray<VkAttachmentReference2>(const VkAttachmentReference2 *src, uint64_t start_index, uint64_t count);

template<>
VkSubpassDescription2 *CommandRecorder::CopyArray<VkSubpassDescription2>(const VkSubpassDescription2 *src, uint64_t start_index, uint64_t count);

template<>
VkSubpassDependency2 *CommandRecorder::CopyArray<VkSubpassDependency2>(const VkSubpassDependency2 *src, uint64_t start_index, uint64_t count);

template<>
VkRenderPassCreateInfo2 *CommandRecorder::CopyArray<VkRenderPassCreateInfo2>(const VkRenderPassCreateInfo2 *src, uint64_t start_index, uint64_t count);

template<>
VkSubpassBeginInfo *CommandRecorder::CopyArray<VkSubpassBeginInfo>(const VkSubpassBeginInfo *src, uint64_t start_index, uint64_t count);

template<>
VkSubpassEndInfo *CommandRecorder::CopyArray<VkSubpassEndInfo>(const VkSubpassEndInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceTimelineSemaphoreFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceTimelineSemaphoreFeatures>(const VkPhysicalDeviceTimelineSemaphoreFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceTimelineSemaphoreProperties *CommandRecorder::CopyArray<VkPhysicalDeviceTimelineSemaphoreProperties>(const VkPhysicalDeviceTimelineSemaphoreProperties *src, uint64_t start_index, uint64_t count);

template<>
VkSemaphoreTypeCreateInfo *CommandRecorder::CopyArray<VkSemaphoreTypeCreateInfo>(const VkSemaphoreTypeCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkTimelineSemaphoreSubmitInfo *CommandRecorder::CopyArray<VkTimelineSemaphoreSubmitInfo>(const VkTimelineSemaphoreSubmitInfo *src, uint64_t start_index, uint64_t count);

template<>
VkSemaphoreWaitInfo *CommandRecorder::CopyArray<VkSemaphoreWaitInfo>(const VkSemaphoreWaitInfo *src, uint64_t start_index, uint64_t count);

template<>
VkSemaphoreSignalInfo *CommandRecorder::CopyArray<VkSemaphoreSignalInfo>(const VkSemaphoreSignalInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDevice8BitStorageFeatures *CommandRecorder::CopyArray<VkPhysicalDevice8BitStorageFeatures>(const VkPhysicalDevice8BitStorageFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceVulkanMemoryModelFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceVulkanMemoryModelFeatures>(const VkPhysicalDeviceVulkanMemoryModelFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceShaderAtomicInt64Features *CommandRecorder::CopyArray<VkPhysicalDeviceShaderAtomicInt64Features>(const VkPhysicalDeviceShaderAtomicInt64Features *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceDepthStencilResolveProperties *CommandRecorder::CopyArray<VkPhysicalDeviceDepthStencilResolveProperties>(const VkPhysicalDeviceDepthStencilResolveProperties *src, uint64_t start_index, uint64_t count);

template<>
VkSubpassDescriptionDepthStencilResolve *CommandRecorder::CopyArray<VkSubpassDescriptionDepthStencilResolve>(const VkSubpassDescriptionDepthStencilResolve *src, uint64_t start_index, uint64_t count);

template<>
VkImageStencilUsageCreateInfo *CommandRecorder::CopyArray<VkImageStencilUsageCreateInfo>(const VkImageStencilUsageCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceScalarBlockLayoutFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceScalarBlockLayoutFeatures>(const VkPhysicalDeviceScalarBlockLayoutFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceUniformBufferStandardLayoutFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>(const VkPhysicalDeviceUniformBufferStandardLayoutFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceBufferDeviceAddressFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceBufferDeviceAddressFeatures>(const VkPhysicalDeviceBufferDeviceAddressFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkBufferDeviceAddressInfo *CommandRecorder::CopyArray<VkBufferDeviceAddressInfo>(const VkBufferDeviceAddressInfo *src, uint64_t start_index, uint64_t count);

template<>
VkBufferOpaqueCaptureAddressCreateInfo *CommandRecorder::CopyArray<VkBufferOpaqueCaptureAddressCreateInfo>(const VkBufferOpaqueCaptureAddressCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceImagelessFramebufferFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceImagelessFramebufferFeatures>(const VkPhysicalDeviceImagelessFramebufferFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkFramebufferAttachmentsCreateInfo *CommandRecorder::CopyArray<VkFramebufferAttachmentsCreateInfo>(const VkFramebufferAttachmentsCreateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkFramebufferAttachmentImageInfo *CommandRecorder::CopyArray<VkFramebufferAttachmentImageInfo>(const VkFramebufferAttachmentImageInfo *src, uint64_t start_index, uint64_t count);

template<>
VkRenderPassAttachmentBeginInfo *CommandRecorder::CopyArray<VkRenderPassAttachmentBeginInfo>(const VkRenderPassAttachmentBeginInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>(const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *src, uint64_t start_index, uint64_t count);

template<>
VkAttachmentReferenceStencilLayout *CommandRecorder::CopyArray<VkAttachmentReferenceStencilLayout>(const VkAttachmentReferenceStencilLayout *src, uint64_t start_index, uint64_t count);

template<>
VkAttachmentDescriptionStencilLayout *CommandRecorder::CopyArray<VkAttachmentDescriptionStencilLayout>(const VkAttachmentDescriptionStencilLayout *src, uint64_t start_index, uint64_t count);

template<>
VkMemoryOpaqueCaptureAddressAllocateInfo *CommandRecorder::CopyArray<VkMemoryOpaqueCaptureAddressAllocateInfo>(const VkMemoryOpaqueCaptureAddressAllocateInfo *src, uint64_t start_index, uint64_t count);

template<>
VkDeviceMemoryOpaqueCaptureAddressInfo *CommandRecorder::CopyArray<VkDeviceMemoryOpaqueCaptureAddressInfo>(const VkDeviceMemoryOpaqueCaptureAddressInfo *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceVulkan11Features *CommandRecorder::CopyArray<VkPhysicalDeviceVulkan11Features>(const VkPhysicalDeviceVulkan11Features *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceVulkan11Properties *CommandRecorder::CopyArray<VkPhysicalDeviceVulkan11Properties>(const VkPhysicalDeviceVulkan11Properties *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceVulkan12Features *CommandRecorder::CopyArray<VkPhysicalDeviceVulkan12Features>(const VkPhysicalDeviceVulkan12Features *src, uint64_t start_index, uint64_t count);

template<>
VkPhysicalDeviceVulkan12Properties *CommandRecorder::CopyArray<VkPhysicalDeviceVulkan12Properties>(const VkPhysicalDeviceVulkan12Properties *src, uint64_t start_index, uint64_t count);



#ifdef VK_USE_PLATFORM_GGP 

template<>
VkStreamDescriptorSurfaceCreateInfoGGP *CommandRecorder::CopyArray<VkStreamDescriptorSurfaceCreateInfoGGP>(const VkStreamDescriptorSurfaceCreateInfoGGP *src, uint64_t start_index, uint64_t count);

template<>
VkPresentFrameTokenGGP *CommandRecorder::CopyArray<VkPresentFrameTokenGGP>(const VkPresentFrameTokenGGP *src, uint64_t start_index, uint64_t count);

#endif // VK_USE_PLATFORM_GGP


// Define CopyArray template functions.



template<>
VkMultiDrawInfoEXT *CommandRecorder::CopyArray<VkMultiDrawInfoEXT>(const VkMultiDrawInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMultiDrawInfoEXT *>(m_allocator.Alloc(sizeof(VkMultiDrawInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].firstVertex = src[start_index + i].firstVertex;
      ptr[i].vertexCount = src[start_index + i].vertexCount;
  }
  return ptr;
}

template<>
VkMultiDrawIndexedInfoEXT *CommandRecorder::CopyArray<VkMultiDrawIndexedInfoEXT>(const VkMultiDrawIndexedInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMultiDrawIndexedInfoEXT *>(m_allocator.Alloc(sizeof(VkMultiDrawIndexedInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].firstIndex = src[start_index + i].firstIndex;
      ptr[i].indexCount = src[start_index + i].indexCount;
      ptr[i].vertexOffset = src[start_index + i].vertexOffset;
  }
  return ptr;
}

template<>
VkDisplayPropertiesKHR *CommandRecorder::CopyArray<VkDisplayPropertiesKHR>(const VkDisplayPropertiesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDisplayPropertiesKHR *>(m_allocator.Alloc(sizeof(VkDisplayPropertiesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].display = src[start_index + i].display;
      ptr[i].displayName = nullptr;
    if (src[start_index + i].displayName) {
      ptr[i].displayName = CopyArray<>(src[start_index + i].displayName, 0, strlen(src[start_index + i].displayName));
    }
      ptr[i].physicalDimensions = src[start_index + i].physicalDimensions;
      ptr[i].physicalResolution = src[start_index + i].physicalResolution;
      ptr[i].supportedTransforms = src[start_index + i].supportedTransforms;
      ptr[i].planeReorderPossible = src[start_index + i].planeReorderPossible;
      ptr[i].persistentContent = src[start_index + i].persistentContent;
  }
  return ptr;
}

template<>
VkDisplayPlanePropertiesKHR *CommandRecorder::CopyArray<VkDisplayPlanePropertiesKHR>(const VkDisplayPlanePropertiesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDisplayPlanePropertiesKHR *>(m_allocator.Alloc(sizeof(VkDisplayPlanePropertiesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].currentDisplay = src[start_index + i].currentDisplay;
      ptr[i].currentStackIndex = src[start_index + i].currentStackIndex;
  }
  return ptr;
}

template<>
VkDisplayModeParametersKHR *CommandRecorder::CopyArray<VkDisplayModeParametersKHR>(const VkDisplayModeParametersKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDisplayModeParametersKHR *>(m_allocator.Alloc(sizeof(VkDisplayModeParametersKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].visibleRegion = src[start_index + i].visibleRegion;
      ptr[i].refreshRate = src[start_index + i].refreshRate;
  }
  return ptr;
}

template<>
VkDisplayModePropertiesKHR *CommandRecorder::CopyArray<VkDisplayModePropertiesKHR>(const VkDisplayModePropertiesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDisplayModePropertiesKHR *>(m_allocator.Alloc(sizeof(VkDisplayModePropertiesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].displayMode = src[start_index + i].displayMode;
      ptr[i].parameters = src[start_index + i].parameters;
  }
  return ptr;
}

template<>
VkDisplayModeCreateInfoKHR *CommandRecorder::CopyArray<VkDisplayModeCreateInfoKHR>(const VkDisplayModeCreateInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDisplayModeCreateInfoKHR *>(m_allocator.Alloc(sizeof(VkDisplayModeCreateInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].parameters = src[start_index + i].parameters;
  }
  return ptr;
}

template<>
VkDisplayPlaneCapabilitiesKHR *CommandRecorder::CopyArray<VkDisplayPlaneCapabilitiesKHR>(const VkDisplayPlaneCapabilitiesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDisplayPlaneCapabilitiesKHR *>(m_allocator.Alloc(sizeof(VkDisplayPlaneCapabilitiesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].supportedAlpha = src[start_index + i].supportedAlpha;
      ptr[i].minSrcPosition = src[start_index + i].minSrcPosition;
      ptr[i].maxSrcPosition = src[start_index + i].maxSrcPosition;
      ptr[i].minSrcExtent = src[start_index + i].minSrcExtent;
      ptr[i].maxSrcExtent = src[start_index + i].maxSrcExtent;
      ptr[i].minDstPosition = src[start_index + i].minDstPosition;
      ptr[i].maxDstPosition = src[start_index + i].maxDstPosition;
      ptr[i].minDstExtent = src[start_index + i].minDstExtent;
      ptr[i].maxDstExtent = src[start_index + i].maxDstExtent;
  }
  return ptr;
}

template<>
VkDisplaySurfaceCreateInfoKHR *CommandRecorder::CopyArray<VkDisplaySurfaceCreateInfoKHR>(const VkDisplaySurfaceCreateInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDisplaySurfaceCreateInfoKHR *>(m_allocator.Alloc(sizeof(VkDisplaySurfaceCreateInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].displayMode = src[start_index + i].displayMode;
      ptr[i].planeIndex = src[start_index + i].planeIndex;
      ptr[i].planeStackIndex = src[start_index + i].planeStackIndex;
      ptr[i].transform = src[start_index + i].transform;
      ptr[i].globalAlpha = src[start_index + i].globalAlpha;
      ptr[i].alphaMode = src[start_index + i].alphaMode;
      ptr[i].imageExtent = src[start_index + i].imageExtent;
  }
  return ptr;
}

template<>
VkDisplayPresentInfoKHR *CommandRecorder::CopyArray<VkDisplayPresentInfoKHR>(const VkDisplayPresentInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDisplayPresentInfoKHR *>(m_allocator.Alloc(sizeof(VkDisplayPresentInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcRect = src[start_index + i].srcRect;
      ptr[i].dstRect = src[start_index + i].dstRect;
      ptr[i].persistent = src[start_index + i].persistent;
  }
  return ptr;
}

template<>
VkSurfaceCapabilitiesKHR *CommandRecorder::CopyArray<VkSurfaceCapabilitiesKHR>(const VkSurfaceCapabilitiesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSurfaceCapabilitiesKHR *>(m_allocator.Alloc(sizeof(VkSurfaceCapabilitiesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].minImageCount = src[start_index + i].minImageCount;
      ptr[i].maxImageCount = src[start_index + i].maxImageCount;
      ptr[i].currentExtent = src[start_index + i].currentExtent;
      ptr[i].minImageExtent = src[start_index + i].minImageExtent;
      ptr[i].maxImageExtent = src[start_index + i].maxImageExtent;
      ptr[i].maxImageArrayLayers = src[start_index + i].maxImageArrayLayers;
      ptr[i].supportedTransforms = src[start_index + i].supportedTransforms;
      ptr[i].currentTransform = src[start_index + i].currentTransform;
      ptr[i].supportedCompositeAlpha = src[start_index + i].supportedCompositeAlpha;
      ptr[i].supportedUsageFlags = src[start_index + i].supportedUsageFlags;
  }
  return ptr;
}

template<>
VkSurfaceFormatKHR *CommandRecorder::CopyArray<VkSurfaceFormatKHR>(const VkSurfaceFormatKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSurfaceFormatKHR *>(m_allocator.Alloc(sizeof(VkSurfaceFormatKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].format = src[start_index + i].format;
      ptr[i].colorSpace = src[start_index + i].colorSpace;
  }
  return ptr;
}

template<>
VkSwapchainCreateInfoKHR *CommandRecorder::CopyArray<VkSwapchainCreateInfoKHR>(const VkSwapchainCreateInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSwapchainCreateInfoKHR *>(m_allocator.Alloc(sizeof(VkSwapchainCreateInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].surface = src[start_index + i].surface;
      ptr[i].minImageCount = src[start_index + i].minImageCount;
      ptr[i].imageFormat = src[start_index + i].imageFormat;
      ptr[i].imageColorSpace = src[start_index + i].imageColorSpace;
      ptr[i].imageExtent = src[start_index + i].imageExtent;
      ptr[i].imageArrayLayers = src[start_index + i].imageArrayLayers;
      ptr[i].imageUsage = src[start_index + i].imageUsage;
      ptr[i].imageSharingMode = src[start_index + i].imageSharingMode;
      ptr[i].queueFamilyIndexCount = src[start_index + i].queueFamilyIndexCount;
      ptr[i].pQueueFamilyIndices = nullptr;
      if (src[start_index + i].pQueueFamilyIndices) {
        ptr[i].pQueueFamilyIndices = CopyArray<>(src[start_index + i].pQueueFamilyIndices, 0, 1);
      }
      ptr[i].preTransform = src[start_index + i].preTransform;
      ptr[i].compositeAlpha = src[start_index + i].compositeAlpha;
      ptr[i].presentMode = src[start_index + i].presentMode;
      ptr[i].clipped = src[start_index + i].clipped;
      ptr[i].oldSwapchain = src[start_index + i].oldSwapchain;
  }
  return ptr;
}

template<>
VkPresentInfoKHR *CommandRecorder::CopyArray<VkPresentInfoKHR>(const VkPresentInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPresentInfoKHR *>(m_allocator.Alloc(sizeof(VkPresentInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].waitSemaphoreCount = src[start_index + i].waitSemaphoreCount;
      ptr[i].pWaitSemaphores = nullptr;
      if (src[start_index + i].pWaitSemaphores) {
        ptr[i].pWaitSemaphores = CopyArray<>(src[start_index + i].pWaitSemaphores, 0, 1);
      }
      ptr[i].swapchainCount = src[start_index + i].swapchainCount;
      ptr[i].pSwapchains = nullptr;
      if (src[start_index + i].pSwapchains) {
        ptr[i].pSwapchains = CopyArray<>(src[start_index + i].pSwapchains, 0, 1);
      }
      ptr[i].pImageIndices = nullptr;
      if (src[start_index + i].pImageIndices) {
        ptr[i].pImageIndices = CopyArray<>(src[start_index + i].pImageIndices, 0, 1);
      }
      ptr[i].pResults = nullptr;
      if (src[start_index + i].pResults) {
        ptr[i].pResults = CopyArray<>(src[start_index + i].pResults, 0, 1);
      }
  }
  return ptr;
}

template<>
VkDebugReportCallbackCreateInfoEXT *CommandRecorder::CopyArray<VkDebugReportCallbackCreateInfoEXT>(const VkDebugReportCallbackCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDebugReportCallbackCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkDebugReportCallbackCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].pfnCallback = src[start_index + i].pfnCallback;
      ptr[i].pUserData = src[start_index + i].pUserData;
  }
  return ptr;
}

template<>
VkPipelineRasterizationStateRasterizationOrderAMD *CommandRecorder::CopyArray<VkPipelineRasterizationStateRasterizationOrderAMD>(const VkPipelineRasterizationStateRasterizationOrderAMD *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineRasterizationStateRasterizationOrderAMD *>(m_allocator.Alloc(sizeof(VkPipelineRasterizationStateRasterizationOrderAMD) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].rasterizationOrder = src[start_index + i].rasterizationOrder;
  }
  return ptr;
}

template<>
VkDebugMarkerObjectNameInfoEXT *CommandRecorder::CopyArray<VkDebugMarkerObjectNameInfoEXT>(const VkDebugMarkerObjectNameInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDebugMarkerObjectNameInfoEXT *>(m_allocator.Alloc(sizeof(VkDebugMarkerObjectNameInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].objectType = src[start_index + i].objectType;
      ptr[i].object = src[start_index + i].object;
      ptr[i].pObjectName = nullptr;
    if (src[start_index + i].pObjectName) {
      ptr[i].pObjectName = CopyArray<>(src[start_index + i].pObjectName, 0, strlen(src[start_index + i].pObjectName));
    }
  }
  return ptr;
}

template<>
VkDebugMarkerObjectTagInfoEXT *CommandRecorder::CopyArray<VkDebugMarkerObjectTagInfoEXT>(const VkDebugMarkerObjectTagInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDebugMarkerObjectTagInfoEXT *>(m_allocator.Alloc(sizeof(VkDebugMarkerObjectTagInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].objectType = src[start_index + i].objectType;
      ptr[i].object = src[start_index + i].object;
      ptr[i].tagName = src[start_index + i].tagName;
      ptr[i].tagSize = src[start_index + i].tagSize;
      ptr[i].pTag = src[start_index + i].pTag;
  }
  return ptr;
}

template<>
VkDebugMarkerMarkerInfoEXT *CommandRecorder::CopyArray<VkDebugMarkerMarkerInfoEXT>(const VkDebugMarkerMarkerInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDebugMarkerMarkerInfoEXT *>(m_allocator.Alloc(sizeof(VkDebugMarkerMarkerInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].pMarkerName = nullptr;
    if (src[start_index + i].pMarkerName) {
      ptr[i].pMarkerName = CopyArray<>(src[start_index + i].pMarkerName, 0, strlen(src[start_index + i].pMarkerName));
    }
      std::memcpy(ptr[i].color, src[start_index + i].color, sizeof(src[start_index + i].color));
  }
  return ptr;
}

template<>
VkPhysicalDeviceMultiDrawPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceMultiDrawPropertiesEXT>(const VkPhysicalDeviceMultiDrawPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceMultiDrawPropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceMultiDrawPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].maxMultiDrawCount = src[start_index + i].maxMultiDrawCount;
  }
  return ptr;
}

template<>
VkPhysicalDevicePushDescriptorPropertiesKHR *CommandRecorder::CopyArray<VkPhysicalDevicePushDescriptorPropertiesKHR>(const VkPhysicalDevicePushDescriptorPropertiesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDevicePushDescriptorPropertiesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDevicePushDescriptorPropertiesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].maxPushDescriptors = src[start_index + i].maxPushDescriptors;
  }
  return ptr;
}

template<>
VkPresentRegionsKHR *CommandRecorder::CopyArray<VkPresentRegionsKHR>(const VkPresentRegionsKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPresentRegionsKHR *>(m_allocator.Alloc(sizeof(VkPresentRegionsKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].swapchainCount = src[start_index + i].swapchainCount;
      ptr[i].pRegions = nullptr;
      if (src[start_index + i].pRegions) {
        ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
      }
  }
  return ptr;
}

template<>
VkPresentRegionKHR *CommandRecorder::CopyArray<VkPresentRegionKHR>(const VkPresentRegionKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPresentRegionKHR *>(m_allocator.Alloc(sizeof(VkPresentRegionKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].rectangleCount = src[start_index + i].rectangleCount;
      ptr[i].pRectangles = nullptr;
      if (src[start_index + i].pRectangles) {
        ptr[i].pRectangles = CopyArray<>(src[start_index + i].pRectangles, 0, 1);
      }
  }
  return ptr;
}

template<>
VkRectLayerKHR *CommandRecorder::CopyArray<VkRectLayerKHR>(const VkRectLayerKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkRectLayerKHR *>(m_allocator.Alloc(sizeof(VkRectLayerKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].offset = src[start_index + i].offset;
      ptr[i].extent = src[start_index + i].extent;
      ptr[i].layer = src[start_index + i].layer;
  }
  return ptr;
}

template<>
VkImportMemoryFdInfoKHR *CommandRecorder::CopyArray<VkImportMemoryFdInfoKHR>(const VkImportMemoryFdInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImportMemoryFdInfoKHR *>(m_allocator.Alloc(sizeof(VkImportMemoryFdInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].handleType = src[start_index + i].handleType;
      ptr[i].fd = src[start_index + i].fd;
  }
  return ptr;
}

template<>
VkMemoryFdPropertiesKHR *CommandRecorder::CopyArray<VkMemoryFdPropertiesKHR>(const VkMemoryFdPropertiesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMemoryFdPropertiesKHR *>(m_allocator.Alloc(sizeof(VkMemoryFdPropertiesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].memoryTypeBits = src[start_index + i].memoryTypeBits;
  }
  return ptr;
}

template<>
VkMemoryGetFdInfoKHR *CommandRecorder::CopyArray<VkMemoryGetFdInfoKHR>(const VkMemoryGetFdInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMemoryGetFdInfoKHR *>(m_allocator.Alloc(sizeof(VkMemoryGetFdInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].memory = src[start_index + i].memory;
      ptr[i].handleType = src[start_index + i].handleType;
  }
  return ptr;
}

template<>
VkImportSemaphoreFdInfoKHR *CommandRecorder::CopyArray<VkImportSemaphoreFdInfoKHR>(const VkImportSemaphoreFdInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImportSemaphoreFdInfoKHR *>(m_allocator.Alloc(sizeof(VkImportSemaphoreFdInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].semaphore = src[start_index + i].semaphore;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].handleType = src[start_index + i].handleType;
      ptr[i].fd = src[start_index + i].fd;
  }
  return ptr;
}

template<>
VkSemaphoreGetFdInfoKHR *CommandRecorder::CopyArray<VkSemaphoreGetFdInfoKHR>(const VkSemaphoreGetFdInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSemaphoreGetFdInfoKHR *>(m_allocator.Alloc(sizeof(VkSemaphoreGetFdInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].semaphore = src[start_index + i].semaphore;
      ptr[i].handleType = src[start_index + i].handleType;
  }
  return ptr;
}

template<>
VkImportFenceFdInfoKHR *CommandRecorder::CopyArray<VkImportFenceFdInfoKHR>(const VkImportFenceFdInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImportFenceFdInfoKHR *>(m_allocator.Alloc(sizeof(VkImportFenceFdInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].fence = src[start_index + i].fence;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].handleType = src[start_index + i].handleType;
      ptr[i].fd = src[start_index + i].fd;
  }
  return ptr;
}

template<>
VkFenceGetFdInfoKHR *CommandRecorder::CopyArray<VkFenceGetFdInfoKHR>(const VkFenceGetFdInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkFenceGetFdInfoKHR *>(m_allocator.Alloc(sizeof(VkFenceGetFdInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].fence = src[start_index + i].fence;
      ptr[i].handleType = src[start_index + i].handleType;
  }
  return ptr;
}

template<>
VkDeviceGroupPresentCapabilitiesKHR *CommandRecorder::CopyArray<VkDeviceGroupPresentCapabilitiesKHR>(const VkDeviceGroupPresentCapabilitiesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceGroupPresentCapabilitiesKHR *>(m_allocator.Alloc(sizeof(VkDeviceGroupPresentCapabilitiesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      std::memcpy(ptr[i].presentMask, src[start_index + i].presentMask, sizeof(src[start_index + i].presentMask));
      ptr[i].modes = src[start_index + i].modes;
  }
  return ptr;
}

template<>
VkImageSwapchainCreateInfoKHR *CommandRecorder::CopyArray<VkImageSwapchainCreateInfoKHR>(const VkImageSwapchainCreateInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageSwapchainCreateInfoKHR *>(m_allocator.Alloc(sizeof(VkImageSwapchainCreateInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].swapchain = src[start_index + i].swapchain;
  }
  return ptr;
}

template<>
VkBindImageMemorySwapchainInfoKHR *CommandRecorder::CopyArray<VkBindImageMemorySwapchainInfoKHR>(const VkBindImageMemorySwapchainInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBindImageMemorySwapchainInfoKHR *>(m_allocator.Alloc(sizeof(VkBindImageMemorySwapchainInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].swapchain = src[start_index + i].swapchain;
      ptr[i].imageIndex = src[start_index + i].imageIndex;
  }
  return ptr;
}

template<>
VkAcquireNextImageInfoKHR *CommandRecorder::CopyArray<VkAcquireNextImageInfoKHR>(const VkAcquireNextImageInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAcquireNextImageInfoKHR *>(m_allocator.Alloc(sizeof(VkAcquireNextImageInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].swapchain = src[start_index + i].swapchain;
      ptr[i].timeout = src[start_index + i].timeout;
      ptr[i].semaphore = src[start_index + i].semaphore;
      ptr[i].fence = src[start_index + i].fence;
      ptr[i].deviceMask = src[start_index + i].deviceMask;
  }
  return ptr;
}

template<>
VkDeviceGroupPresentInfoKHR *CommandRecorder::CopyArray<VkDeviceGroupPresentInfoKHR>(const VkDeviceGroupPresentInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceGroupPresentInfoKHR *>(m_allocator.Alloc(sizeof(VkDeviceGroupPresentInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].swapchainCount = src[start_index + i].swapchainCount;
      ptr[i].pDeviceMasks = nullptr;
      if (src[start_index + i].pDeviceMasks) {
        ptr[i].pDeviceMasks = CopyArray<>(src[start_index + i].pDeviceMasks, 0, 1);
      }
      ptr[i].mode = src[start_index + i].mode;
  }
  return ptr;
}

template<>
VkDeviceGroupSwapchainCreateInfoKHR *CommandRecorder::CopyArray<VkDeviceGroupSwapchainCreateInfoKHR>(const VkDeviceGroupSwapchainCreateInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceGroupSwapchainCreateInfoKHR *>(m_allocator.Alloc(sizeof(VkDeviceGroupSwapchainCreateInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].modes = src[start_index + i].modes;
  }
  return ptr;
}

template<>
VkDisplayNativeHdrSurfaceCapabilitiesAMD *CommandRecorder::CopyArray<VkDisplayNativeHdrSurfaceCapabilitiesAMD>(const VkDisplayNativeHdrSurfaceCapabilitiesAMD *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDisplayNativeHdrSurfaceCapabilitiesAMD *>(m_allocator.Alloc(sizeof(VkDisplayNativeHdrSurfaceCapabilitiesAMD) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].localDimmingSupport = src[start_index + i].localDimmingSupport;
  }
  return ptr;
}

template<>
VkSwapchainDisplayNativeHdrCreateInfoAMD *CommandRecorder::CopyArray<VkSwapchainDisplayNativeHdrCreateInfoAMD>(const VkSwapchainDisplayNativeHdrCreateInfoAMD *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSwapchainDisplayNativeHdrCreateInfoAMD *>(m_allocator.Alloc(sizeof(VkSwapchainDisplayNativeHdrCreateInfoAMD) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].localDimmingEnable = src[start_index + i].localDimmingEnable;
  }
  return ptr;
}

template<>
VkPhysicalDeviceSurfaceInfo2KHR *CommandRecorder::CopyArray<VkPhysicalDeviceSurfaceInfo2KHR>(const VkPhysicalDeviceSurfaceInfo2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceSurfaceInfo2KHR *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceSurfaceInfo2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].surface = src[start_index + i].surface;
  }
  return ptr;
}

template<>
VkSurfaceCapabilities2KHR *CommandRecorder::CopyArray<VkSurfaceCapabilities2KHR>(const VkSurfaceCapabilities2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSurfaceCapabilities2KHR *>(m_allocator.Alloc(sizeof(VkSurfaceCapabilities2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].surfaceCapabilities = src[start_index + i].surfaceCapabilities;
  }
  return ptr;
}

template<>
VkSurfaceFormat2KHR *CommandRecorder::CopyArray<VkSurfaceFormat2KHR>(const VkSurfaceFormat2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSurfaceFormat2KHR *>(m_allocator.Alloc(sizeof(VkSurfaceFormat2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].surfaceFormat = src[start_index + i].surfaceFormat;
  }
  return ptr;
}

template<>
VkDisplayProperties2KHR *CommandRecorder::CopyArray<VkDisplayProperties2KHR>(const VkDisplayProperties2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDisplayProperties2KHR *>(m_allocator.Alloc(sizeof(VkDisplayProperties2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].displayProperties = src[start_index + i].displayProperties;
  }
  return ptr;
}

template<>
VkDisplayPlaneProperties2KHR *CommandRecorder::CopyArray<VkDisplayPlaneProperties2KHR>(const VkDisplayPlaneProperties2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDisplayPlaneProperties2KHR *>(m_allocator.Alloc(sizeof(VkDisplayPlaneProperties2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].displayPlaneProperties = src[start_index + i].displayPlaneProperties;
  }
  return ptr;
}

template<>
VkDisplayModeProperties2KHR *CommandRecorder::CopyArray<VkDisplayModeProperties2KHR>(const VkDisplayModeProperties2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDisplayModeProperties2KHR *>(m_allocator.Alloc(sizeof(VkDisplayModeProperties2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].displayModeProperties = src[start_index + i].displayModeProperties;
  }
  return ptr;
}

template<>
VkDisplayPlaneInfo2KHR *CommandRecorder::CopyArray<VkDisplayPlaneInfo2KHR>(const VkDisplayPlaneInfo2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDisplayPlaneInfo2KHR *>(m_allocator.Alloc(sizeof(VkDisplayPlaneInfo2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].mode = src[start_index + i].mode;
      ptr[i].planeIndex = src[start_index + i].planeIndex;
  }
  return ptr;
}

template<>
VkDisplayPlaneCapabilities2KHR *CommandRecorder::CopyArray<VkDisplayPlaneCapabilities2KHR>(const VkDisplayPlaneCapabilities2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDisplayPlaneCapabilities2KHR *>(m_allocator.Alloc(sizeof(VkDisplayPlaneCapabilities2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].capabilities = src[start_index + i].capabilities;
  }
  return ptr;
}

template<>
VkSharedPresentSurfaceCapabilitiesKHR *CommandRecorder::CopyArray<VkSharedPresentSurfaceCapabilitiesKHR>(const VkSharedPresentSurfaceCapabilitiesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSharedPresentSurfaceCapabilitiesKHR *>(m_allocator.Alloc(sizeof(VkSharedPresentSurfaceCapabilitiesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].sharedPresentSupportedUsageFlags = src[start_index + i].sharedPresentSupportedUsageFlags;
  }
  return ptr;
}

template<>
VkTextureLODGatherFormatPropertiesAMD *CommandRecorder::CopyArray<VkTextureLODGatherFormatPropertiesAMD>(const VkTextureLODGatherFormatPropertiesAMD *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkTextureLODGatherFormatPropertiesAMD *>(m_allocator.Alloc(sizeof(VkTextureLODGatherFormatPropertiesAMD) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].supportsTextureGatherLODBiasAMD = src[start_index + i].supportsTextureGatherLODBiasAMD;
  }
  return ptr;
}

template<>
VkSampleLocationEXT *CommandRecorder::CopyArray<VkSampleLocationEXT>(const VkSampleLocationEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSampleLocationEXT *>(m_allocator.Alloc(sizeof(VkSampleLocationEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].x = src[start_index + i].x;
      ptr[i].y = src[start_index + i].y;
  }
  return ptr;
}

template<>
VkSampleLocationsInfoEXT *CommandRecorder::CopyArray<VkSampleLocationsInfoEXT>(const VkSampleLocationsInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSampleLocationsInfoEXT *>(m_allocator.Alloc(sizeof(VkSampleLocationsInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].sampleLocationsPerPixel = src[start_index + i].sampleLocationsPerPixel;
      ptr[i].sampleLocationGridSize = src[start_index + i].sampleLocationGridSize;
      ptr[i].sampleLocationsCount = src[start_index + i].sampleLocationsCount;
      ptr[i].pSampleLocations = nullptr;
      if (src[start_index + i].pSampleLocations) {
        ptr[i].pSampleLocations = CopyArray<>(src[start_index + i].pSampleLocations, 0, 1);
      }
  }
  return ptr;
}

template<>
VkAttachmentSampleLocationsEXT *CommandRecorder::CopyArray<VkAttachmentSampleLocationsEXT>(const VkAttachmentSampleLocationsEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAttachmentSampleLocationsEXT *>(m_allocator.Alloc(sizeof(VkAttachmentSampleLocationsEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].attachmentIndex = src[start_index + i].attachmentIndex;
      ptr[i].sampleLocationsInfo = src[start_index + i].sampleLocationsInfo;
  }
  return ptr;
}

template<>
VkSubpassSampleLocationsEXT *CommandRecorder::CopyArray<VkSubpassSampleLocationsEXT>(const VkSubpassSampleLocationsEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSubpassSampleLocationsEXT *>(m_allocator.Alloc(sizeof(VkSubpassSampleLocationsEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].subpassIndex = src[start_index + i].subpassIndex;
      ptr[i].sampleLocationsInfo = src[start_index + i].sampleLocationsInfo;
  }
  return ptr;
}

template<>
VkRenderPassSampleLocationsBeginInfoEXT *CommandRecorder::CopyArray<VkRenderPassSampleLocationsBeginInfoEXT>(const VkRenderPassSampleLocationsBeginInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkRenderPassSampleLocationsBeginInfoEXT *>(m_allocator.Alloc(sizeof(VkRenderPassSampleLocationsBeginInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].attachmentInitialSampleLocationsCount = src[start_index + i].attachmentInitialSampleLocationsCount;
      ptr[i].pAttachmentInitialSampleLocations = nullptr;
      if (src[start_index + i].pAttachmentInitialSampleLocations) {
        ptr[i].pAttachmentInitialSampleLocations = CopyArray<>(src[start_index + i].pAttachmentInitialSampleLocations, 0, 1);
      }
      ptr[i].postSubpassSampleLocationsCount = src[start_index + i].postSubpassSampleLocationsCount;
      ptr[i].pPostSubpassSampleLocations = nullptr;
      if (src[start_index + i].pPostSubpassSampleLocations) {
        ptr[i].pPostSubpassSampleLocations = CopyArray<>(src[start_index + i].pPostSubpassSampleLocations, 0, 1);
      }
  }
  return ptr;
}

template<>
VkPipelineSampleLocationsStateCreateInfoEXT *CommandRecorder::CopyArray<VkPipelineSampleLocationsStateCreateInfoEXT>(const VkPipelineSampleLocationsStateCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineSampleLocationsStateCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkPipelineSampleLocationsStateCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].sampleLocationsEnable = src[start_index + i].sampleLocationsEnable;
      ptr[i].sampleLocationsInfo = src[start_index + i].sampleLocationsInfo;
  }
  return ptr;
}

template<>
VkPhysicalDeviceSampleLocationsPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceSampleLocationsPropertiesEXT>(const VkPhysicalDeviceSampleLocationsPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceSampleLocationsPropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceSampleLocationsPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].sampleLocationSampleCounts = src[start_index + i].sampleLocationSampleCounts;
      ptr[i].maxSampleLocationGridSize = src[start_index + i].maxSampleLocationGridSize;
      std::memcpy(ptr[i].sampleLocationCoordinateRange, src[start_index + i].sampleLocationCoordinateRange, sizeof(src[start_index + i].sampleLocationCoordinateRange));
      ptr[i].sampleLocationSubPixelBits = src[start_index + i].sampleLocationSubPixelBits;
      ptr[i].variableSampleLocations = src[start_index + i].variableSampleLocations;
  }
  return ptr;
}

template<>
VkMultisamplePropertiesEXT *CommandRecorder::CopyArray<VkMultisamplePropertiesEXT>(const VkMultisamplePropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMultisamplePropertiesEXT *>(m_allocator.Alloc(sizeof(VkMultisamplePropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].maxSampleLocationGridSize = src[start_index + i].maxSampleLocationGridSize;
  }
  return ptr;
}

template<>
VkPhysicalDeviceMultiDrawFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceMultiDrawFeaturesEXT>(const VkPhysicalDeviceMultiDrawFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceMultiDrawFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceMultiDrawFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].multiDraw = src[start_index + i].multiDraw;
  }
  return ptr;
}

template<>
VkPhysicalDeviceInlineUniformBlockFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceInlineUniformBlockFeaturesEXT>(const VkPhysicalDeviceInlineUniformBlockFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceInlineUniformBlockFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceInlineUniformBlockFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].inlineUniformBlock = src[start_index + i].inlineUniformBlock;
      ptr[i].descriptorBindingInlineUniformBlockUpdateAfterBind = src[start_index + i].descriptorBindingInlineUniformBlockUpdateAfterBind;
  }
  return ptr;
}

template<>
VkPhysicalDeviceInlineUniformBlockPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceInlineUniformBlockPropertiesEXT>(const VkPhysicalDeviceInlineUniformBlockPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceInlineUniformBlockPropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceInlineUniformBlockPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].maxInlineUniformBlockSize = src[start_index + i].maxInlineUniformBlockSize;
      ptr[i].maxPerStageDescriptorInlineUniformBlocks = src[start_index + i].maxPerStageDescriptorInlineUniformBlocks;
      ptr[i].maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks = src[start_index + i].maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks;
      ptr[i].maxDescriptorSetInlineUniformBlocks = src[start_index + i].maxDescriptorSetInlineUniformBlocks;
      ptr[i].maxDescriptorSetUpdateAfterBindInlineUniformBlocks = src[start_index + i].maxDescriptorSetUpdateAfterBindInlineUniformBlocks;
  }
  return ptr;
}

template<>
VkWriteDescriptorSetInlineUniformBlockEXT *CommandRecorder::CopyArray<VkWriteDescriptorSetInlineUniformBlockEXT>(const VkWriteDescriptorSetInlineUniformBlockEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkWriteDescriptorSetInlineUniformBlockEXT *>(m_allocator.Alloc(sizeof(VkWriteDescriptorSetInlineUniformBlockEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].dataSize = src[start_index + i].dataSize;
      ptr[i].pData = src[start_index + i].pData;
  }
  return ptr;
}

template<>
VkDescriptorPoolInlineUniformBlockCreateInfoEXT *CommandRecorder::CopyArray<VkDescriptorPoolInlineUniformBlockCreateInfoEXT>(const VkDescriptorPoolInlineUniformBlockCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDescriptorPoolInlineUniformBlockCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkDescriptorPoolInlineUniformBlockCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].maxInlineUniformBlockBindings = src[start_index + i].maxInlineUniformBlockBindings;
  }
  return ptr;
}

template<>
VkShaderResourceUsageAMD *CommandRecorder::CopyArray<VkShaderResourceUsageAMD>(const VkShaderResourceUsageAMD *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkShaderResourceUsageAMD *>(m_allocator.Alloc(sizeof(VkShaderResourceUsageAMD) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].numUsedVgprs = src[start_index + i].numUsedVgprs;
      ptr[i].numUsedSgprs = src[start_index + i].numUsedSgprs;
      ptr[i].ldsSizePerLocalWorkGroup = src[start_index + i].ldsSizePerLocalWorkGroup;
      ptr[i].ldsUsageSizeInBytes = src[start_index + i].ldsUsageSizeInBytes;
      ptr[i].scratchMemUsageInBytes = src[start_index + i].scratchMemUsageInBytes;
  }
  return ptr;
}

template<>
VkShaderStatisticsInfoAMD *CommandRecorder::CopyArray<VkShaderStatisticsInfoAMD>(const VkShaderStatisticsInfoAMD *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkShaderStatisticsInfoAMD *>(m_allocator.Alloc(sizeof(VkShaderStatisticsInfoAMD) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].shaderStageMask = src[start_index + i].shaderStageMask;
      ptr[i].resourceUsage = src[start_index + i].resourceUsage;
      ptr[i].numPhysicalVgprs = src[start_index + i].numPhysicalVgprs;
      ptr[i].numPhysicalSgprs = src[start_index + i].numPhysicalSgprs;
      ptr[i].numAvailableVgprs = src[start_index + i].numAvailableVgprs;
      ptr[i].numAvailableSgprs = src[start_index + i].numAvailableSgprs;
      std::memcpy(ptr[i].computeWorkGroupSize, src[start_index + i].computeWorkGroupSize, sizeof(src[start_index + i].computeWorkGroupSize));
  }
  return ptr;
}

template<>
VkDeviceQueueGlobalPriorityCreateInfoEXT *CommandRecorder::CopyArray<VkDeviceQueueGlobalPriorityCreateInfoEXT>(const VkDeviceQueueGlobalPriorityCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceQueueGlobalPriorityCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkDeviceQueueGlobalPriorityCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].globalPriority = src[start_index + i].globalPriority;
  }
  return ptr;
}

template<>
VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT>(const VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceGlobalPriorityQueryFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].globalPriorityQuery = src[start_index + i].globalPriorityQuery;
  }
  return ptr;
}

template<>
VkQueueFamilyGlobalPriorityPropertiesEXT *CommandRecorder::CopyArray<VkQueueFamilyGlobalPriorityPropertiesEXT>(const VkQueueFamilyGlobalPriorityPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkQueueFamilyGlobalPriorityPropertiesEXT *>(m_allocator.Alloc(sizeof(VkQueueFamilyGlobalPriorityPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].priorityCount = src[start_index + i].priorityCount;
      std::memcpy(ptr[i].priorities, src[start_index + i].priorities, sizeof(src[start_index + i].priorities));
  }
  return ptr;
}

template<>
VkDebugUtilsObjectNameInfoEXT *CommandRecorder::CopyArray<VkDebugUtilsObjectNameInfoEXT>(const VkDebugUtilsObjectNameInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDebugUtilsObjectNameInfoEXT *>(m_allocator.Alloc(sizeof(VkDebugUtilsObjectNameInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].objectType = src[start_index + i].objectType;
      ptr[i].objectHandle = src[start_index + i].objectHandle;
      ptr[i].pObjectName = nullptr;
    if (src[start_index + i].pObjectName) {
      ptr[i].pObjectName = CopyArray<>(src[start_index + i].pObjectName, 0, strlen(src[start_index + i].pObjectName));
    }
  }
  return ptr;
}

template<>
VkDebugUtilsObjectTagInfoEXT *CommandRecorder::CopyArray<VkDebugUtilsObjectTagInfoEXT>(const VkDebugUtilsObjectTagInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDebugUtilsObjectTagInfoEXT *>(m_allocator.Alloc(sizeof(VkDebugUtilsObjectTagInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].objectType = src[start_index + i].objectType;
      ptr[i].objectHandle = src[start_index + i].objectHandle;
      ptr[i].tagName = src[start_index + i].tagName;
      ptr[i].tagSize = src[start_index + i].tagSize;
      ptr[i].pTag = src[start_index + i].pTag;
  }
  return ptr;
}

template<>
VkDebugUtilsLabelEXT *CommandRecorder::CopyArray<VkDebugUtilsLabelEXT>(const VkDebugUtilsLabelEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDebugUtilsLabelEXT *>(m_allocator.Alloc(sizeof(VkDebugUtilsLabelEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].pLabelName = nullptr;
    if (src[start_index + i].pLabelName) {
      ptr[i].pLabelName = CopyArray<>(src[start_index + i].pLabelName, 0, strlen(src[start_index + i].pLabelName));
    }
      std::memcpy(ptr[i].color, src[start_index + i].color, sizeof(src[start_index + i].color));
  }
  return ptr;
}

template<>
VkDebugUtilsMessengerCreateInfoEXT *CommandRecorder::CopyArray<VkDebugUtilsMessengerCreateInfoEXT>(const VkDebugUtilsMessengerCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDebugUtilsMessengerCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkDebugUtilsMessengerCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].messageSeverity = src[start_index + i].messageSeverity;
      ptr[i].messageType = src[start_index + i].messageType;
      ptr[i].pfnUserCallback = src[start_index + i].pfnUserCallback;
      ptr[i].pUserData = src[start_index + i].pUserData;
  }
  return ptr;
}

template<>
VkDebugUtilsMessengerCallbackDataEXT *CommandRecorder::CopyArray<VkDebugUtilsMessengerCallbackDataEXT>(const VkDebugUtilsMessengerCallbackDataEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDebugUtilsMessengerCallbackDataEXT *>(m_allocator.Alloc(sizeof(VkDebugUtilsMessengerCallbackDataEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].pMessageIdName = nullptr;
    if (src[start_index + i].pMessageIdName) {
      ptr[i].pMessageIdName = CopyArray<>(src[start_index + i].pMessageIdName, 0, strlen(src[start_index + i].pMessageIdName));
    }
      ptr[i].messageIdNumber = src[start_index + i].messageIdNumber;
      ptr[i].pMessage = nullptr;
    if (src[start_index + i].pMessage) {
      ptr[i].pMessage = CopyArray<>(src[start_index + i].pMessage, 0, strlen(src[start_index + i].pMessage));
    }
      ptr[i].queueLabelCount = src[start_index + i].queueLabelCount;
      ptr[i].pQueueLabels = nullptr;
      if (src[start_index + i].pQueueLabels) {
        ptr[i].pQueueLabels = CopyArray<>(src[start_index + i].pQueueLabels, 0, 1);
      }
      ptr[i].cmdBufLabelCount = src[start_index + i].cmdBufLabelCount;
      ptr[i].pCmdBufLabels = nullptr;
      if (src[start_index + i].pCmdBufLabels) {
        ptr[i].pCmdBufLabels = CopyArray<>(src[start_index + i].pCmdBufLabels, 0, 1);
      }
      ptr[i].objectCount = src[start_index + i].objectCount;
      ptr[i].pObjects = nullptr;
      if (src[start_index + i].pObjects) {
        ptr[i].pObjects = CopyArray<>(src[start_index + i].pObjects, 0, 1);
      }
  }
  return ptr;
}

template<>
VkPhysicalDeviceDeviceMemoryReportFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>(const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceDeviceMemoryReportFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].deviceMemoryReport = src[start_index + i].deviceMemoryReport;
  }
  return ptr;
}

template<>
VkDeviceDeviceMemoryReportCreateInfoEXT *CommandRecorder::CopyArray<VkDeviceDeviceMemoryReportCreateInfoEXT>(const VkDeviceDeviceMemoryReportCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceDeviceMemoryReportCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkDeviceDeviceMemoryReportCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].pfnUserCallback = src[start_index + i].pfnUserCallback;
      ptr[i].pUserData = src[start_index + i].pUserData;
  }
  return ptr;
}

template<>
VkDeviceMemoryReportCallbackDataEXT *CommandRecorder::CopyArray<VkDeviceMemoryReportCallbackDataEXT>(const VkDeviceMemoryReportCallbackDataEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceMemoryReportCallbackDataEXT *>(m_allocator.Alloc(sizeof(VkDeviceMemoryReportCallbackDataEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].type = src[start_index + i].type;
      ptr[i].memoryObjectId = src[start_index + i].memoryObjectId;
      ptr[i].size = src[start_index + i].size;
      ptr[i].objectType = src[start_index + i].objectType;
      ptr[i].objectHandle = src[start_index + i].objectHandle;
      ptr[i].heapIndex = src[start_index + i].heapIndex;
  }
  return ptr;
}

template<>
VkImportMemoryHostPointerInfoEXT *CommandRecorder::CopyArray<VkImportMemoryHostPointerInfoEXT>(const VkImportMemoryHostPointerInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImportMemoryHostPointerInfoEXT *>(m_allocator.Alloc(sizeof(VkImportMemoryHostPointerInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].handleType = src[start_index + i].handleType;
      ptr[i].pHostPointer = src[start_index + i].pHostPointer;
  }
  return ptr;
}

template<>
VkMemoryHostPointerPropertiesEXT *CommandRecorder::CopyArray<VkMemoryHostPointerPropertiesEXT>(const VkMemoryHostPointerPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMemoryHostPointerPropertiesEXT *>(m_allocator.Alloc(sizeof(VkMemoryHostPointerPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].memoryTypeBits = src[start_index + i].memoryTypeBits;
  }
  return ptr;
}

template<>
VkPhysicalDeviceExternalMemoryHostPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(const VkPhysicalDeviceExternalMemoryHostPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceExternalMemoryHostPropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceExternalMemoryHostPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].minImportedHostPointerAlignment = src[start_index + i].minImportedHostPointerAlignment;
  }
  return ptr;
}

template<>
VkCalibratedTimestampInfoEXT *CommandRecorder::CopyArray<VkCalibratedTimestampInfoEXT>(const VkCalibratedTimestampInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkCalibratedTimestampInfoEXT *>(m_allocator.Alloc(sizeof(VkCalibratedTimestampInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].timeDomain = src[start_index + i].timeDomain;
  }
  return ptr;
}

template<>
VkPhysicalDeviceShaderCorePropertiesAMD *CommandRecorder::CopyArray<VkPhysicalDeviceShaderCorePropertiesAMD>(const VkPhysicalDeviceShaderCorePropertiesAMD *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceShaderCorePropertiesAMD *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderCorePropertiesAMD) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].shaderEngineCount = src[start_index + i].shaderEngineCount;
      ptr[i].shaderArraysPerEngineCount = src[start_index + i].shaderArraysPerEngineCount;
      ptr[i].computeUnitsPerShaderArray = src[start_index + i].computeUnitsPerShaderArray;
      ptr[i].simdPerComputeUnit = src[start_index + i].simdPerComputeUnit;
      ptr[i].wavefrontsPerSimd = src[start_index + i].wavefrontsPerSimd;
      ptr[i].wavefrontSize = src[start_index + i].wavefrontSize;
      ptr[i].sgprsPerSimd = src[start_index + i].sgprsPerSimd;
      ptr[i].minSgprAllocation = src[start_index + i].minSgprAllocation;
      ptr[i].maxSgprAllocation = src[start_index + i].maxSgprAllocation;
      ptr[i].sgprAllocationGranularity = src[start_index + i].sgprAllocationGranularity;
      ptr[i].vgprsPerSimd = src[start_index + i].vgprsPerSimd;
      ptr[i].minVgprAllocation = src[start_index + i].minVgprAllocation;
      ptr[i].maxVgprAllocation = src[start_index + i].maxVgprAllocation;
      ptr[i].vgprAllocationGranularity = src[start_index + i].vgprAllocationGranularity;
  }
  return ptr;
}

template<>
VkPhysicalDeviceShaderCoreProperties2AMD *CommandRecorder::CopyArray<VkPhysicalDeviceShaderCoreProperties2AMD>(const VkPhysicalDeviceShaderCoreProperties2AMD *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceShaderCoreProperties2AMD *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderCoreProperties2AMD) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].shaderCoreFeatures = src[start_index + i].shaderCoreFeatures;
      ptr[i].activeComputeUnitCount = src[start_index + i].activeComputeUnitCount;
  }
  return ptr;
}

template<>
VkPhysicalDevicePCIBusInfoPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDevicePCIBusInfoPropertiesEXT>(const VkPhysicalDevicePCIBusInfoPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDevicePCIBusInfoPropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDevicePCIBusInfoPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].pciDomain = src[start_index + i].pciDomain;
      ptr[i].pciBus = src[start_index + i].pciBus;
      ptr[i].pciDevice = src[start_index + i].pciDevice;
      ptr[i].pciFunction = src[start_index + i].pciFunction;
  }
  return ptr;
}

template<>
VkRayTracingShaderGroupCreateInfoKHR *CommandRecorder::CopyArray<VkRayTracingShaderGroupCreateInfoKHR>(const VkRayTracingShaderGroupCreateInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkRayTracingShaderGroupCreateInfoKHR *>(m_allocator.Alloc(sizeof(VkRayTracingShaderGroupCreateInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].type = src[start_index + i].type;
      ptr[i].generalShader = src[start_index + i].generalShader;
      ptr[i].closestHitShader = src[start_index + i].closestHitShader;
      ptr[i].anyHitShader = src[start_index + i].anyHitShader;
      ptr[i].intersectionShader = src[start_index + i].intersectionShader;
      ptr[i].pShaderGroupCaptureReplayHandle = src[start_index + i].pShaderGroupCaptureReplayHandle;
  }
  return ptr;
}

template<>
VkRayTracingPipelineCreateInfoKHR *CommandRecorder::CopyArray<VkRayTracingPipelineCreateInfoKHR>(const VkRayTracingPipelineCreateInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkRayTracingPipelineCreateInfoKHR *>(m_allocator.Alloc(sizeof(VkRayTracingPipelineCreateInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].stageCount = src[start_index + i].stageCount;
      ptr[i].pStages = nullptr;
      if (src[start_index + i].pStages) {
        ptr[i].pStages = CopyArray<>(src[start_index + i].pStages, 0, 1);
      }
      ptr[i].groupCount = src[start_index + i].groupCount;
      ptr[i].pGroups = nullptr;
      if (src[start_index + i].pGroups) {
        ptr[i].pGroups = CopyArray<>(src[start_index + i].pGroups, 0, 1);
      }
      ptr[i].maxPipelineRayRecursionDepth = src[start_index + i].maxPipelineRayRecursionDepth;
      ptr[i].pLibraryInfo = nullptr;
      if (src[start_index + i].pLibraryInfo) {
        ptr[i].pLibraryInfo = CopyArray<>(src[start_index + i].pLibraryInfo, 0, 1);
      }
      ptr[i].pLibraryInterface = nullptr;
      if (src[start_index + i].pLibraryInterface) {
        ptr[i].pLibraryInterface = CopyArray<>(src[start_index + i].pLibraryInterface, 0, 1);
      }
      ptr[i].pDynamicState = nullptr;
      if (src[start_index + i].pDynamicState) {
        ptr[i].pDynamicState = CopyArray<>(src[start_index + i].pDynamicState, 0, 1);
      }
      ptr[i].layout = src[start_index + i].layout;
      ptr[i].basePipelineHandle = src[start_index + i].basePipelineHandle;
      ptr[i].basePipelineIndex = src[start_index + i].basePipelineIndex;
  }
  return ptr;
}

template<>
VkWriteDescriptorSetAccelerationStructureKHR *CommandRecorder::CopyArray<VkWriteDescriptorSetAccelerationStructureKHR>(const VkWriteDescriptorSetAccelerationStructureKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkWriteDescriptorSetAccelerationStructureKHR *>(m_allocator.Alloc(sizeof(VkWriteDescriptorSetAccelerationStructureKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].accelerationStructureCount = src[start_index + i].accelerationStructureCount;
      ptr[i].pAccelerationStructures = nullptr;
      if (src[start_index + i].pAccelerationStructures) {
        ptr[i].pAccelerationStructures = CopyArray<>(src[start_index + i].pAccelerationStructures, 0, 1);
      }
  }
  return ptr;
}

template<>
VkPhysicalDeviceAccelerationStructureFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceAccelerationStructureFeaturesKHR>(const VkPhysicalDeviceAccelerationStructureFeaturesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceAccelerationStructureFeaturesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceAccelerationStructureFeaturesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].accelerationStructure = src[start_index + i].accelerationStructure;
      ptr[i].accelerationStructureCaptureReplay = src[start_index + i].accelerationStructureCaptureReplay;
      ptr[i].accelerationStructureIndirectBuild = src[start_index + i].accelerationStructureIndirectBuild;
      ptr[i].accelerationStructureHostCommands = src[start_index + i].accelerationStructureHostCommands;
      ptr[i].descriptorBindingAccelerationStructureUpdateAfterBind = src[start_index + i].descriptorBindingAccelerationStructureUpdateAfterBind;
  }
  return ptr;
}

template<>
VkPhysicalDeviceRayTracingPipelineFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingPipelineFeaturesKHR>(const VkPhysicalDeviceRayTracingPipelineFeaturesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceRayTracingPipelineFeaturesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceRayTracingPipelineFeaturesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].rayTracingPipeline = src[start_index + i].rayTracingPipeline;
      ptr[i].rayTracingPipelineShaderGroupHandleCaptureReplay = src[start_index + i].rayTracingPipelineShaderGroupHandleCaptureReplay;
      ptr[i].rayTracingPipelineShaderGroupHandleCaptureReplayMixed = src[start_index + i].rayTracingPipelineShaderGroupHandleCaptureReplayMixed;
      ptr[i].rayTracingPipelineTraceRaysIndirect = src[start_index + i].rayTracingPipelineTraceRaysIndirect;
      ptr[i].rayTraversalPrimitiveCulling = src[start_index + i].rayTraversalPrimitiveCulling;
  }
  return ptr;
}

template<>
VkPhysicalDeviceRayQueryFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceRayQueryFeaturesKHR>(const VkPhysicalDeviceRayQueryFeaturesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceRayQueryFeaturesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceRayQueryFeaturesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].rayQuery = src[start_index + i].rayQuery;
  }
  return ptr;
}

template<>
VkPhysicalDeviceAccelerationStructurePropertiesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceAccelerationStructurePropertiesKHR>(const VkPhysicalDeviceAccelerationStructurePropertiesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceAccelerationStructurePropertiesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceAccelerationStructurePropertiesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].maxGeometryCount = src[start_index + i].maxGeometryCount;
      ptr[i].maxInstanceCount = src[start_index + i].maxInstanceCount;
      ptr[i].maxPrimitiveCount = src[start_index + i].maxPrimitiveCount;
      ptr[i].maxPerStageDescriptorAccelerationStructures = src[start_index + i].maxPerStageDescriptorAccelerationStructures;
      ptr[i].maxPerStageDescriptorUpdateAfterBindAccelerationStructures = src[start_index + i].maxPerStageDescriptorUpdateAfterBindAccelerationStructures;
      ptr[i].maxDescriptorSetAccelerationStructures = src[start_index + i].maxDescriptorSetAccelerationStructures;
      ptr[i].maxDescriptorSetUpdateAfterBindAccelerationStructures = src[start_index + i].maxDescriptorSetUpdateAfterBindAccelerationStructures;
      ptr[i].minAccelerationStructureScratchOffsetAlignment = src[start_index + i].minAccelerationStructureScratchOffsetAlignment;
  }
  return ptr;
}

template<>
VkPhysicalDeviceRayTracingPipelinePropertiesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceRayTracingPipelinePropertiesKHR>(const VkPhysicalDeviceRayTracingPipelinePropertiesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceRayTracingPipelinePropertiesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceRayTracingPipelinePropertiesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].shaderGroupHandleSize = src[start_index + i].shaderGroupHandleSize;
      ptr[i].maxRayRecursionDepth = src[start_index + i].maxRayRecursionDepth;
      ptr[i].maxShaderGroupStride = src[start_index + i].maxShaderGroupStride;
      ptr[i].shaderGroupBaseAlignment = src[start_index + i].shaderGroupBaseAlignment;
      ptr[i].shaderGroupHandleCaptureReplaySize = src[start_index + i].shaderGroupHandleCaptureReplaySize;
      ptr[i].maxRayDispatchInvocationCount = src[start_index + i].maxRayDispatchInvocationCount;
      ptr[i].shaderGroupHandleAlignment = src[start_index + i].shaderGroupHandleAlignment;
      ptr[i].maxRayHitAttributeSize = src[start_index + i].maxRayHitAttributeSize;
  }
  return ptr;
}

template<>
VkStridedDeviceAddressRegionKHR *CommandRecorder::CopyArray<VkStridedDeviceAddressRegionKHR>(const VkStridedDeviceAddressRegionKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkStridedDeviceAddressRegionKHR *>(m_allocator.Alloc(sizeof(VkStridedDeviceAddressRegionKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].deviceAddress = src[start_index + i].deviceAddress;
      ptr[i].stride = src[start_index + i].stride;
      ptr[i].size = src[start_index + i].size;
  }
  return ptr;
}

template<>
VkTraceRaysIndirectCommandKHR *CommandRecorder::CopyArray<VkTraceRaysIndirectCommandKHR>(const VkTraceRaysIndirectCommandKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkTraceRaysIndirectCommandKHR *>(m_allocator.Alloc(sizeof(VkTraceRaysIndirectCommandKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].width = src[start_index + i].width;
      ptr[i].height = src[start_index + i].height;
      ptr[i].depth = src[start_index + i].depth;
  }
  return ptr;
}

template<>
VkDrmFormatModifierPropertiesListEXT *CommandRecorder::CopyArray<VkDrmFormatModifierPropertiesListEXT>(const VkDrmFormatModifierPropertiesListEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDrmFormatModifierPropertiesListEXT *>(m_allocator.Alloc(sizeof(VkDrmFormatModifierPropertiesListEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].drmFormatModifierCount = src[start_index + i].drmFormatModifierCount;
      ptr[i].pDrmFormatModifierProperties = nullptr;
      if (src[start_index + i].pDrmFormatModifierProperties) {
        ptr[i].pDrmFormatModifierProperties = CopyArray<>(src[start_index + i].pDrmFormatModifierProperties, 0, 1);
      }
  }
  return ptr;
}

template<>
VkDrmFormatModifierPropertiesEXT *CommandRecorder::CopyArray<VkDrmFormatModifierPropertiesEXT>(const VkDrmFormatModifierPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDrmFormatModifierPropertiesEXT *>(m_allocator.Alloc(sizeof(VkDrmFormatModifierPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].drmFormatModifier = src[start_index + i].drmFormatModifier;
      ptr[i].drmFormatModifierPlaneCount = src[start_index + i].drmFormatModifierPlaneCount;
      ptr[i].drmFormatModifierTilingFeatures = src[start_index + i].drmFormatModifierTilingFeatures;
  }
  return ptr;
}

template<>
VkPhysicalDeviceImageDrmFormatModifierInfoEXT *CommandRecorder::CopyArray<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(const VkPhysicalDeviceImageDrmFormatModifierInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceImageDrmFormatModifierInfoEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceImageDrmFormatModifierInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].drmFormatModifier = src[start_index + i].drmFormatModifier;
      ptr[i].sharingMode = src[start_index + i].sharingMode;
      ptr[i].queueFamilyIndexCount = src[start_index + i].queueFamilyIndexCount;
      ptr[i].pQueueFamilyIndices = nullptr;
      if (src[start_index + i].pQueueFamilyIndices) {
        ptr[i].pQueueFamilyIndices = CopyArray<>(src[start_index + i].pQueueFamilyIndices, 0, 1);
      }
  }
  return ptr;
}

template<>
VkImageDrmFormatModifierListCreateInfoEXT *CommandRecorder::CopyArray<VkImageDrmFormatModifierListCreateInfoEXT>(const VkImageDrmFormatModifierListCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageDrmFormatModifierListCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkImageDrmFormatModifierListCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].drmFormatModifierCount = src[start_index + i].drmFormatModifierCount;
      ptr[i].pDrmFormatModifiers = nullptr;
      if (src[start_index + i].pDrmFormatModifiers) {
        ptr[i].pDrmFormatModifiers = CopyArray<>(src[start_index + i].pDrmFormatModifiers, 0, 1);
      }
  }
  return ptr;
}

template<>
VkImageDrmFormatModifierExplicitCreateInfoEXT *CommandRecorder::CopyArray<VkImageDrmFormatModifierExplicitCreateInfoEXT>(const VkImageDrmFormatModifierExplicitCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageDrmFormatModifierExplicitCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkImageDrmFormatModifierExplicitCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].drmFormatModifier = src[start_index + i].drmFormatModifier;
      ptr[i].drmFormatModifierPlaneCount = src[start_index + i].drmFormatModifierPlaneCount;
      ptr[i].pPlaneLayouts = nullptr;
      if (src[start_index + i].pPlaneLayouts) {
        ptr[i].pPlaneLayouts = CopyArray<>(src[start_index + i].pPlaneLayouts, 0, 1);
      }
  }
  return ptr;
}

template<>
VkImageDrmFormatModifierPropertiesEXT *CommandRecorder::CopyArray<VkImageDrmFormatModifierPropertiesEXT>(const VkImageDrmFormatModifierPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageDrmFormatModifierPropertiesEXT *>(m_allocator.Alloc(sizeof(VkImageDrmFormatModifierPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].drmFormatModifier = src[start_index + i].drmFormatModifier;
  }
  return ptr;
}

template<>
VkDeviceMemoryOverallocationCreateInfoAMD *CommandRecorder::CopyArray<VkDeviceMemoryOverallocationCreateInfoAMD>(const VkDeviceMemoryOverallocationCreateInfoAMD *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceMemoryOverallocationCreateInfoAMD *>(m_allocator.Alloc(sizeof(VkDeviceMemoryOverallocationCreateInfoAMD) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].overallocationBehavior = src[start_index + i].overallocationBehavior;
  }
  return ptr;
}

template<>
VkPhysicalDeviceFragmentDensityMapFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>(const VkPhysicalDeviceFragmentDensityMapFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentDensityMapFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentDensityMapFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].fragmentDensityMap = src[start_index + i].fragmentDensityMap;
      ptr[i].fragmentDensityMapDynamic = src[start_index + i].fragmentDensityMapDynamic;
      ptr[i].fragmentDensityMapNonSubsampledImages = src[start_index + i].fragmentDensityMapNonSubsampledImages;
  }
  return ptr;
}

template<>
VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>(const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentDensityMap2FeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].fragmentDensityMapDeferred = src[start_index + i].fragmentDensityMapDeferred;
  }
  return ptr;
}

template<>
VkPhysicalDeviceFragmentDensityMapPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>(const VkPhysicalDeviceFragmentDensityMapPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentDensityMapPropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentDensityMapPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].minFragmentDensityTexelSize = src[start_index + i].minFragmentDensityTexelSize;
      ptr[i].maxFragmentDensityTexelSize = src[start_index + i].maxFragmentDensityTexelSize;
      ptr[i].fragmentDensityInvocations = src[start_index + i].fragmentDensityInvocations;
  }
  return ptr;
}

template<>
VkPhysicalDeviceFragmentDensityMap2PropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>(const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentDensityMap2PropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].subsampledLoads = src[start_index + i].subsampledLoads;
      ptr[i].subsampledCoarseReconstructionEarlyAccess = src[start_index + i].subsampledCoarseReconstructionEarlyAccess;
      ptr[i].maxSubsampledArrayLayers = src[start_index + i].maxSubsampledArrayLayers;
      ptr[i].maxDescriptorSetSubsampledSamplers = src[start_index + i].maxDescriptorSetSubsampledSamplers;
  }
  return ptr;
}

template<>
VkRenderPassFragmentDensityMapCreateInfoEXT *CommandRecorder::CopyArray<VkRenderPassFragmentDensityMapCreateInfoEXT>(const VkRenderPassFragmentDensityMapCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkRenderPassFragmentDensityMapCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkRenderPassFragmentDensityMapCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].fragmentDensityMapAttachment = src[start_index + i].fragmentDensityMapAttachment;
  }
  return ptr;
}

template<>
VkSurfaceProtectedCapabilitiesKHR *CommandRecorder::CopyArray<VkSurfaceProtectedCapabilitiesKHR>(const VkSurfaceProtectedCapabilitiesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSurfaceProtectedCapabilitiesKHR *>(m_allocator.Alloc(sizeof(VkSurfaceProtectedCapabilitiesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].supportsProtected = src[start_index + i].supportsProtected;
  }
  return ptr;
}

template<>
VkPhysicalDeviceDepthClipEnableFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceDepthClipEnableFeaturesEXT>(const VkPhysicalDeviceDepthClipEnableFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceDepthClipEnableFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceDepthClipEnableFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].depthClipEnable = src[start_index + i].depthClipEnable;
  }
  return ptr;
}

template<>
VkPipelineRasterizationDepthClipStateCreateInfoEXT *CommandRecorder::CopyArray<VkPipelineRasterizationDepthClipStateCreateInfoEXT>(const VkPipelineRasterizationDepthClipStateCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineRasterizationDepthClipStateCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkPipelineRasterizationDepthClipStateCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].depthClipEnable = src[start_index + i].depthClipEnable;
  }
  return ptr;
}

template<>
VkPhysicalDeviceMemoryBudgetPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceMemoryBudgetPropertiesEXT>(const VkPhysicalDeviceMemoryBudgetPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceMemoryBudgetPropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceMemoryBudgetPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      std::memcpy(ptr[i].heapBudget, src[start_index + i].heapBudget, sizeof(src[start_index + i].heapBudget));
      std::memcpy(ptr[i].heapUsage, src[start_index + i].heapUsage, sizeof(src[start_index + i].heapUsage));
  }
  return ptr;
}

template<>
VkPhysicalDeviceMemoryPriorityFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceMemoryPriorityFeaturesEXT>(const VkPhysicalDeviceMemoryPriorityFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceMemoryPriorityFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceMemoryPriorityFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].memoryPriority = src[start_index + i].memoryPriority;
  }
  return ptr;
}

template<>
VkMemoryPriorityAllocateInfoEXT *CommandRecorder::CopyArray<VkMemoryPriorityAllocateInfoEXT>(const VkMemoryPriorityAllocateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMemoryPriorityAllocateInfoEXT *>(m_allocator.Alloc(sizeof(VkMemoryPriorityAllocateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].priority = src[start_index + i].priority;
  }
  return ptr;
}

template<>
VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>(const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].ycbcrImageArrays = src[start_index + i].ycbcrImageArrays;
  }
  return ptr;
}

template<>
VkPhysicalDevicePerformanceQueryFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDevicePerformanceQueryFeaturesKHR>(const VkPhysicalDevicePerformanceQueryFeaturesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDevicePerformanceQueryFeaturesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDevicePerformanceQueryFeaturesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].performanceCounterQueryPools = src[start_index + i].performanceCounterQueryPools;
      ptr[i].performanceCounterMultipleQueryPools = src[start_index + i].performanceCounterMultipleQueryPools;
  }
  return ptr;
}

template<>
VkPhysicalDevicePerformanceQueryPropertiesKHR *CommandRecorder::CopyArray<VkPhysicalDevicePerformanceQueryPropertiesKHR>(const VkPhysicalDevicePerformanceQueryPropertiesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDevicePerformanceQueryPropertiesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDevicePerformanceQueryPropertiesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].allowCommandBufferQueryCopies = src[start_index + i].allowCommandBufferQueryCopies;
  }
  return ptr;
}

template<>
VkPerformanceCounterKHR *CommandRecorder::CopyArray<VkPerformanceCounterKHR>(const VkPerformanceCounterKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPerformanceCounterKHR *>(m_allocator.Alloc(sizeof(VkPerformanceCounterKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].unit = src[start_index + i].unit;
      ptr[i].scope = src[start_index + i].scope;
      ptr[i].storage = src[start_index + i].storage;
      std::memcpy(ptr[i].uuid, src[start_index + i].uuid, sizeof(src[start_index + i].uuid));
  }
  return ptr;
}

template<>
VkPerformanceCounterDescriptionKHR *CommandRecorder::CopyArray<VkPerformanceCounterDescriptionKHR>(const VkPerformanceCounterDescriptionKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPerformanceCounterDescriptionKHR *>(m_allocator.Alloc(sizeof(VkPerformanceCounterDescriptionKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      std::memcpy(ptr[i].name, src[start_index + i].name, sizeof(src[start_index + i].name));
      std::memcpy(ptr[i].category, src[start_index + i].category, sizeof(src[start_index + i].category));
      std::memcpy(ptr[i].description, src[start_index + i].description, sizeof(src[start_index + i].description));
  }
  return ptr;
}

template<>
VkQueryPoolPerformanceCreateInfoKHR *CommandRecorder::CopyArray<VkQueryPoolPerformanceCreateInfoKHR>(const VkQueryPoolPerformanceCreateInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkQueryPoolPerformanceCreateInfoKHR *>(m_allocator.Alloc(sizeof(VkQueryPoolPerformanceCreateInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].queueFamilyIndex = src[start_index + i].queueFamilyIndex;
      ptr[i].counterIndexCount = src[start_index + i].counterIndexCount;
      ptr[i].pCounterIndices = nullptr;
      if (src[start_index + i].pCounterIndices) {
        ptr[i].pCounterIndices = CopyArray<>(src[start_index + i].pCounterIndices, 0, 1);
      }
  }
  return ptr;
}

template<>
VkPerformanceCounterResultKHR *CommandRecorder::CopyArray<VkPerformanceCounterResultKHR>(const VkPerformanceCounterResultKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPerformanceCounterResultKHR *>(m_allocator.Alloc(sizeof(VkPerformanceCounterResultKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {ptr[i].int32 = src[start_index + i].int32;
  }
  return ptr;
}

template<>
VkAcquireProfilingLockInfoKHR *CommandRecorder::CopyArray<VkAcquireProfilingLockInfoKHR>(const VkAcquireProfilingLockInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAcquireProfilingLockInfoKHR *>(m_allocator.Alloc(sizeof(VkAcquireProfilingLockInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].timeout = src[start_index + i].timeout;
  }
  return ptr;
}

template<>
VkPerformanceQuerySubmitInfoKHR *CommandRecorder::CopyArray<VkPerformanceQuerySubmitInfoKHR>(const VkPerformanceQuerySubmitInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPerformanceQuerySubmitInfoKHR *>(m_allocator.Alloc(sizeof(VkPerformanceQuerySubmitInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].counterPassIndex = src[start_index + i].counterPassIndex;
  }
  return ptr;
}

template<>
VkHeadlessSurfaceCreateInfoEXT *CommandRecorder::CopyArray<VkHeadlessSurfaceCreateInfoEXT>(const VkHeadlessSurfaceCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkHeadlessSurfaceCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkHeadlessSurfaceCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
  }
  return ptr;
}

template<>
VkPhysicalDeviceShaderClockFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceShaderClockFeaturesKHR>(const VkPhysicalDeviceShaderClockFeaturesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceShaderClockFeaturesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderClockFeaturesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].shaderSubgroupClock = src[start_index + i].shaderSubgroupClock;
      ptr[i].shaderDeviceClock = src[start_index + i].shaderDeviceClock;
  }
  return ptr;
}

template<>
VkPhysicalDeviceIndexTypeUint8FeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceIndexTypeUint8FeaturesEXT>(const VkPhysicalDeviceIndexTypeUint8FeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceIndexTypeUint8FeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceIndexTypeUint8FeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].indexTypeUint8 = src[start_index + i].indexTypeUint8;
  }
  return ptr;
}

template<>
VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>(const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].fragmentShaderSampleInterlock = src[start_index + i].fragmentShaderSampleInterlock;
      ptr[i].fragmentShaderPixelInterlock = src[start_index + i].fragmentShaderPixelInterlock;
      ptr[i].fragmentShaderShadingRateInterlock = src[start_index + i].fragmentShaderShadingRateInterlock;
  }
  return ptr;
}

template<>
VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].pipelineExecutableInfo = src[start_index + i].pipelineExecutableInfo;
  }
  return ptr;
}

template<>
VkPipelineInfoKHR *CommandRecorder::CopyArray<VkPipelineInfoKHR>(const VkPipelineInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineInfoKHR *>(m_allocator.Alloc(sizeof(VkPipelineInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].pipeline = src[start_index + i].pipeline;
  }
  return ptr;
}

template<>
VkPipelineExecutablePropertiesKHR *CommandRecorder::CopyArray<VkPipelineExecutablePropertiesKHR>(const VkPipelineExecutablePropertiesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineExecutablePropertiesKHR *>(m_allocator.Alloc(sizeof(VkPipelineExecutablePropertiesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].stages = src[start_index + i].stages;
      std::memcpy(ptr[i].name, src[start_index + i].name, sizeof(src[start_index + i].name));
      std::memcpy(ptr[i].description, src[start_index + i].description, sizeof(src[start_index + i].description));
      ptr[i].subgroupSize = src[start_index + i].subgroupSize;
  }
  return ptr;
}

template<>
VkPipelineExecutableInfoKHR *CommandRecorder::CopyArray<VkPipelineExecutableInfoKHR>(const VkPipelineExecutableInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineExecutableInfoKHR *>(m_allocator.Alloc(sizeof(VkPipelineExecutableInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].pipeline = src[start_index + i].pipeline;
      ptr[i].executableIndex = src[start_index + i].executableIndex;
  }
  return ptr;
}

template<>
VkPipelineExecutableStatisticValueKHR *CommandRecorder::CopyArray<VkPipelineExecutableStatisticValueKHR>(const VkPipelineExecutableStatisticValueKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineExecutableStatisticValueKHR *>(m_allocator.Alloc(sizeof(VkPipelineExecutableStatisticValueKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {ptr[i].b32 = src[start_index + i].b32;
  }
  return ptr;
}

template<>
VkPipelineExecutableStatisticKHR *CommandRecorder::CopyArray<VkPipelineExecutableStatisticKHR>(const VkPipelineExecutableStatisticKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineExecutableStatisticKHR *>(m_allocator.Alloc(sizeof(VkPipelineExecutableStatisticKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      std::memcpy(ptr[i].name, src[start_index + i].name, sizeof(src[start_index + i].name));
      std::memcpy(ptr[i].description, src[start_index + i].description, sizeof(src[start_index + i].description));
      ptr[i].format = src[start_index + i].format;
      ptr[i].value = src[start_index + i].value;
  }
  return ptr;
}

template<>
VkPipelineExecutableInternalRepresentationKHR *CommandRecorder::CopyArray<VkPipelineExecutableInternalRepresentationKHR>(const VkPipelineExecutableInternalRepresentationKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineExecutableInternalRepresentationKHR *>(m_allocator.Alloc(sizeof(VkPipelineExecutableInternalRepresentationKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      std::memcpy(ptr[i].name, src[start_index + i].name, sizeof(src[start_index + i].name));
      std::memcpy(ptr[i].description, src[start_index + i].description, sizeof(src[start_index + i].description));
      ptr[i].isText = src[start_index + i].isText;
      ptr[i].dataSize = src[start_index + i].dataSize;
      ptr[i].pData = src[start_index + i].pData;
  }
  return ptr;
}

template<>
VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT>(const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].shaderDemoteToHelperInvocation = src[start_index + i].shaderDemoteToHelperInvocation;
  }
  return ptr;
}

template<>
VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>(const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].texelBufferAlignment = src[start_index + i].texelBufferAlignment;
  }
  return ptr;
}

template<>
VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT>(const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].storageTexelBufferOffsetAlignmentBytes = src[start_index + i].storageTexelBufferOffsetAlignmentBytes;
      ptr[i].storageTexelBufferOffsetSingleTexelAlignment = src[start_index + i].storageTexelBufferOffsetSingleTexelAlignment;
      ptr[i].uniformTexelBufferOffsetAlignmentBytes = src[start_index + i].uniformTexelBufferOffsetAlignmentBytes;
      ptr[i].uniformTexelBufferOffsetSingleTexelAlignment = src[start_index + i].uniformTexelBufferOffsetSingleTexelAlignment;
  }
  return ptr;
}

template<>
VkPhysicalDeviceSubgroupSizeControlFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT>(const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceSubgroupSizeControlFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].subgroupSizeControl = src[start_index + i].subgroupSizeControl;
      ptr[i].computeFullSubgroups = src[start_index + i].computeFullSubgroups;
  }
  return ptr;
}

template<>
VkPhysicalDeviceSubgroupSizeControlPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT>(const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceSubgroupSizeControlPropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceSubgroupSizeControlPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].minSubgroupSize = src[start_index + i].minSubgroupSize;
      ptr[i].maxSubgroupSize = src[start_index + i].maxSubgroupSize;
      ptr[i].maxComputeWorkgroupSubgroups = src[start_index + i].maxComputeWorkgroupSubgroups;
      ptr[i].requiredSubgroupSizeStages = src[start_index + i].requiredSubgroupSizeStages;
  }
  return ptr;
}

template<>
VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT *CommandRecorder::CopyArray<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT>(const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].requiredSubgroupSize = src[start_index + i].requiredSubgroupSize;
  }
  return ptr;
}

template<>
VkPhysicalDeviceLineRasterizationFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceLineRasterizationFeaturesEXT>(const VkPhysicalDeviceLineRasterizationFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceLineRasterizationFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceLineRasterizationFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].rectangularLines = src[start_index + i].rectangularLines;
      ptr[i].bresenhamLines = src[start_index + i].bresenhamLines;
      ptr[i].smoothLines = src[start_index + i].smoothLines;
      ptr[i].stippledRectangularLines = src[start_index + i].stippledRectangularLines;
      ptr[i].stippledBresenhamLines = src[start_index + i].stippledBresenhamLines;
      ptr[i].stippledSmoothLines = src[start_index + i].stippledSmoothLines;
  }
  return ptr;
}

template<>
VkPhysicalDeviceLineRasterizationPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceLineRasterizationPropertiesEXT>(const VkPhysicalDeviceLineRasterizationPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceLineRasterizationPropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceLineRasterizationPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].lineSubPixelPrecisionBits = src[start_index + i].lineSubPixelPrecisionBits;
  }
  return ptr;
}

template<>
VkPipelineRasterizationLineStateCreateInfoEXT *CommandRecorder::CopyArray<VkPipelineRasterizationLineStateCreateInfoEXT>(const VkPipelineRasterizationLineStateCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineRasterizationLineStateCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkPipelineRasterizationLineStateCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].lineRasterizationMode = src[start_index + i].lineRasterizationMode;
      ptr[i].stippledLineEnable = src[start_index + i].stippledLineEnable;
      ptr[i].lineStippleFactor = src[start_index + i].lineStippleFactor;
      ptr[i].lineStipplePattern = src[start_index + i].lineStipplePattern;
  }
  return ptr;
}

template<>
VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT>(const VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDevicePipelineCreationCacheControlFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].pipelineCreationCacheControl = src[start_index + i].pipelineCreationCacheControl;
  }
  return ptr;
}

template<>
VkPipelineCompilerControlCreateInfoAMD *CommandRecorder::CopyArray<VkPipelineCompilerControlCreateInfoAMD>(const VkPipelineCompilerControlCreateInfoAMD *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineCompilerControlCreateInfoAMD *>(m_allocator.Alloc(sizeof(VkPipelineCompilerControlCreateInfoAMD) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].compilerControlFlags = src[start_index + i].compilerControlFlags;
  }
  return ptr;
}

template<>
VkPhysicalDeviceCoherentMemoryFeaturesAMD *CommandRecorder::CopyArray<VkPhysicalDeviceCoherentMemoryFeaturesAMD>(const VkPhysicalDeviceCoherentMemoryFeaturesAMD *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceCoherentMemoryFeaturesAMD *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceCoherentMemoryFeaturesAMD) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].deviceCoherentMemory = src[start_index + i].deviceCoherentMemory;
  }
  return ptr;
}

template<>
VkPhysicalDeviceToolPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceToolPropertiesEXT>(const VkPhysicalDeviceToolPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceToolPropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceToolPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      std::memcpy(ptr[i].name, src[start_index + i].name, sizeof(src[start_index + i].name));
      std::memcpy(ptr[i].version, src[start_index + i].version, sizeof(src[start_index + i].version));
      ptr[i].purposes = src[start_index + i].purposes;
      std::memcpy(ptr[i].description, src[start_index + i].description, sizeof(src[start_index + i].description));
      std::memcpy(ptr[i].layer, src[start_index + i].layer, sizeof(src[start_index + i].layer));
  }
  return ptr;
}

template<>
VkSamplerCustomBorderColorCreateInfoEXT *CommandRecorder::CopyArray<VkSamplerCustomBorderColorCreateInfoEXT>(const VkSamplerCustomBorderColorCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSamplerCustomBorderColorCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkSamplerCustomBorderColorCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].customBorderColor = src[start_index + i].customBorderColor;
      ptr[i].format = src[start_index + i].format;
  }
  return ptr;
}

template<>
VkPhysicalDeviceCustomBorderColorPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceCustomBorderColorPropertiesEXT>(const VkPhysicalDeviceCustomBorderColorPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceCustomBorderColorPropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceCustomBorderColorPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].maxCustomBorderColorSamplers = src[start_index + i].maxCustomBorderColorSamplers;
  }
  return ptr;
}

template<>
VkPhysicalDeviceCustomBorderColorFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceCustomBorderColorFeaturesEXT>(const VkPhysicalDeviceCustomBorderColorFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceCustomBorderColorFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceCustomBorderColorFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].customBorderColors = src[start_index + i].customBorderColors;
      ptr[i].customBorderColorWithoutFormat = src[start_index + i].customBorderColorWithoutFormat;
  }
  return ptr;
}

template<>
VkDeviceOrHostAddressKHR *CommandRecorder::CopyArray<VkDeviceOrHostAddressKHR>(const VkDeviceOrHostAddressKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceOrHostAddressKHR *>(m_allocator.Alloc(sizeof(VkDeviceOrHostAddressKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {ptr[i].deviceAddress = src[start_index + i].deviceAddress;
  }
  return ptr;
}

template<>
VkDeviceOrHostAddressConstKHR *CommandRecorder::CopyArray<VkDeviceOrHostAddressConstKHR>(const VkDeviceOrHostAddressConstKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceOrHostAddressConstKHR *>(m_allocator.Alloc(sizeof(VkDeviceOrHostAddressConstKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {ptr[i].deviceAddress = src[start_index + i].deviceAddress;
  }
  return ptr;
}

template<>
VkAccelerationStructureGeometryTrianglesDataKHR *CommandRecorder::CopyArray<VkAccelerationStructureGeometryTrianglesDataKHR>(const VkAccelerationStructureGeometryTrianglesDataKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAccelerationStructureGeometryTrianglesDataKHR *>(m_allocator.Alloc(sizeof(VkAccelerationStructureGeometryTrianglesDataKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].vertexFormat = src[start_index + i].vertexFormat;
      ptr[i].vertexData = src[start_index + i].vertexData;
      ptr[i].vertexStride = src[start_index + i].vertexStride;
      ptr[i].maxVertex = src[start_index + i].maxVertex;
      ptr[i].indexType = src[start_index + i].indexType;
      ptr[i].indexData = src[start_index + i].indexData;
      ptr[i].transformData = src[start_index + i].transformData;
  }
  return ptr;
}

template<>
VkAccelerationStructureGeometryAabbsDataKHR *CommandRecorder::CopyArray<VkAccelerationStructureGeometryAabbsDataKHR>(const VkAccelerationStructureGeometryAabbsDataKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAccelerationStructureGeometryAabbsDataKHR *>(m_allocator.Alloc(sizeof(VkAccelerationStructureGeometryAabbsDataKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].data = src[start_index + i].data;
      ptr[i].stride = src[start_index + i].stride;
  }
  return ptr;
}

template<>
VkAccelerationStructureGeometryInstancesDataKHR *CommandRecorder::CopyArray<VkAccelerationStructureGeometryInstancesDataKHR>(const VkAccelerationStructureGeometryInstancesDataKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAccelerationStructureGeometryInstancesDataKHR *>(m_allocator.Alloc(sizeof(VkAccelerationStructureGeometryInstancesDataKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].arrayOfPointers = src[start_index + i].arrayOfPointers;
      ptr[i].data = src[start_index + i].data;
  }
  return ptr;
}

template<>
VkAccelerationStructureGeometryDataKHR *CommandRecorder::CopyArray<VkAccelerationStructureGeometryDataKHR>(const VkAccelerationStructureGeometryDataKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAccelerationStructureGeometryDataKHR *>(m_allocator.Alloc(sizeof(VkAccelerationStructureGeometryDataKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {ptr[i].triangles = src[start_index + i].triangles;
  }
  return ptr;
}

template<>
VkAccelerationStructureGeometryKHR *CommandRecorder::CopyArray<VkAccelerationStructureGeometryKHR>(const VkAccelerationStructureGeometryKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAccelerationStructureGeometryKHR *>(m_allocator.Alloc(sizeof(VkAccelerationStructureGeometryKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].geometryType = src[start_index + i].geometryType;
      ptr[i].geometry = src[start_index + i].geometry;
      ptr[i].flags = src[start_index + i].flags;
  }
  return ptr;
}

template<>
VkAccelerationStructureBuildGeometryInfoKHR *CommandRecorder::CopyArray<VkAccelerationStructureBuildGeometryInfoKHR>(const VkAccelerationStructureBuildGeometryInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAccelerationStructureBuildGeometryInfoKHR *>(m_allocator.Alloc(sizeof(VkAccelerationStructureBuildGeometryInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].type = src[start_index + i].type;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].mode = src[start_index + i].mode;
      ptr[i].srcAccelerationStructure = src[start_index + i].srcAccelerationStructure;
      ptr[i].dstAccelerationStructure = src[start_index + i].dstAccelerationStructure;
      ptr[i].geometryCount = src[start_index + i].geometryCount;
      ptr[i].pGeometries = nullptr;
      if (src[start_index + i].pGeometries) {
        ptr[i].pGeometries = CopyArray<>(src[start_index + i].pGeometries, 0, 1);
      }
      ptr[i].ppGeometries = nullptr;
      if (src[start_index + i].ppGeometries) {
        ptr[i].ppGeometries = CopyArray<>(src[start_index + i].ppGeometries, 0, 1);
      }
      ptr[i].scratchData = src[start_index + i].scratchData;
  }
  return ptr;
}

template<>
VkAccelerationStructureBuildRangeInfoKHR *CommandRecorder::CopyArray<VkAccelerationStructureBuildRangeInfoKHR>(const VkAccelerationStructureBuildRangeInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAccelerationStructureBuildRangeInfoKHR *>(m_allocator.Alloc(sizeof(VkAccelerationStructureBuildRangeInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].primitiveCount = src[start_index + i].primitiveCount;
      ptr[i].primitiveOffset = src[start_index + i].primitiveOffset;
      ptr[i].firstVertex = src[start_index + i].firstVertex;
      ptr[i].transformOffset = src[start_index + i].transformOffset;
  }
  return ptr;
}

template<>
VkAccelerationStructureCreateInfoKHR *CommandRecorder::CopyArray<VkAccelerationStructureCreateInfoKHR>(const VkAccelerationStructureCreateInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAccelerationStructureCreateInfoKHR *>(m_allocator.Alloc(sizeof(VkAccelerationStructureCreateInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].createFlags = src[start_index + i].createFlags;
      ptr[i].buffer = src[start_index + i].buffer;
      ptr[i].offset = src[start_index + i].offset;
      ptr[i].size = src[start_index + i].size;
      ptr[i].type = src[start_index + i].type;
      ptr[i].deviceAddress = src[start_index + i].deviceAddress;
  }
  return ptr;
}

template<>
VkAabbPositionsKHR *CommandRecorder::CopyArray<VkAabbPositionsKHR>(const VkAabbPositionsKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAabbPositionsKHR *>(m_allocator.Alloc(sizeof(VkAabbPositionsKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].minX = src[start_index + i].minX;
      ptr[i].minY = src[start_index + i].minY;
      ptr[i].minZ = src[start_index + i].minZ;
      ptr[i].maxX = src[start_index + i].maxX;
      ptr[i].maxY = src[start_index + i].maxY;
      ptr[i].maxZ = src[start_index + i].maxZ;
  }
  return ptr;
}

template<>
VkTransformMatrixKHR *CommandRecorder::CopyArray<VkTransformMatrixKHR>(const VkTransformMatrixKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkTransformMatrixKHR *>(m_allocator.Alloc(sizeof(VkTransformMatrixKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      std::memcpy(ptr[i].matrix, src[start_index + i].matrix, sizeof(src[start_index + i].matrix));
  }
  return ptr;
}

template<>
VkAccelerationStructureInstanceKHR *CommandRecorder::CopyArray<VkAccelerationStructureInstanceKHR>(const VkAccelerationStructureInstanceKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAccelerationStructureInstanceKHR *>(m_allocator.Alloc(sizeof(VkAccelerationStructureInstanceKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].transform = src[start_index + i].transform;
      ptr[i].instanceCustomIndex = src[start_index + i].instanceCustomIndex;
      ptr[i].mask = src[start_index + i].mask;
      ptr[i].instanceShaderBindingTableRecordOffset = src[start_index + i].instanceShaderBindingTableRecordOffset;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].accelerationStructureReference = src[start_index + i].accelerationStructureReference;
  }
  return ptr;
}

template<>
VkAccelerationStructureDeviceAddressInfoKHR *CommandRecorder::CopyArray<VkAccelerationStructureDeviceAddressInfoKHR>(const VkAccelerationStructureDeviceAddressInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAccelerationStructureDeviceAddressInfoKHR *>(m_allocator.Alloc(sizeof(VkAccelerationStructureDeviceAddressInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].accelerationStructure = src[start_index + i].accelerationStructure;
  }
  return ptr;
}

template<>
VkAccelerationStructureVersionInfoKHR *CommandRecorder::CopyArray<VkAccelerationStructureVersionInfoKHR>(const VkAccelerationStructureVersionInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAccelerationStructureVersionInfoKHR *>(m_allocator.Alloc(sizeof(VkAccelerationStructureVersionInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].pVersionData = nullptr;
      if (src[start_index + i].pVersionData) {
        ptr[i].pVersionData = CopyArray<>(src[start_index + i].pVersionData, 0, 1);
      }
  }
  return ptr;
}

template<>
VkCopyAccelerationStructureInfoKHR *CommandRecorder::CopyArray<VkCopyAccelerationStructureInfoKHR>(const VkCopyAccelerationStructureInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkCopyAccelerationStructureInfoKHR *>(m_allocator.Alloc(sizeof(VkCopyAccelerationStructureInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].src = src[start_index + i].src;
      ptr[i].dst = src[start_index + i].dst;
      ptr[i].mode = src[start_index + i].mode;
  }
  return ptr;
}

template<>
VkCopyAccelerationStructureToMemoryInfoKHR *CommandRecorder::CopyArray<VkCopyAccelerationStructureToMemoryInfoKHR>(const VkCopyAccelerationStructureToMemoryInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkCopyAccelerationStructureToMemoryInfoKHR *>(m_allocator.Alloc(sizeof(VkCopyAccelerationStructureToMemoryInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].src = src[start_index + i].src;
      ptr[i].dst = src[start_index + i].dst;
      ptr[i].mode = src[start_index + i].mode;
  }
  return ptr;
}

template<>
VkCopyMemoryToAccelerationStructureInfoKHR *CommandRecorder::CopyArray<VkCopyMemoryToAccelerationStructureInfoKHR>(const VkCopyMemoryToAccelerationStructureInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkCopyMemoryToAccelerationStructureInfoKHR *>(m_allocator.Alloc(sizeof(VkCopyMemoryToAccelerationStructureInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].src = src[start_index + i].src;
      ptr[i].dst = src[start_index + i].dst;
      ptr[i].mode = src[start_index + i].mode;
  }
  return ptr;
}

template<>
VkRayTracingPipelineInterfaceCreateInfoKHR *CommandRecorder::CopyArray<VkRayTracingPipelineInterfaceCreateInfoKHR>(const VkRayTracingPipelineInterfaceCreateInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkRayTracingPipelineInterfaceCreateInfoKHR *>(m_allocator.Alloc(sizeof(VkRayTracingPipelineInterfaceCreateInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].maxPipelineRayPayloadSize = src[start_index + i].maxPipelineRayPayloadSize;
      ptr[i].maxPipelineRayHitAttributeSize = src[start_index + i].maxPipelineRayHitAttributeSize;
  }
  return ptr;
}

template<>
VkPipelineLibraryCreateInfoKHR *CommandRecorder::CopyArray<VkPipelineLibraryCreateInfoKHR>(const VkPipelineLibraryCreateInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineLibraryCreateInfoKHR *>(m_allocator.Alloc(sizeof(VkPipelineLibraryCreateInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].libraryCount = src[start_index + i].libraryCount;
      ptr[i].pLibraries = nullptr;
      if (src[start_index + i].pLibraries) {
        ptr[i].pLibraries = CopyArray<>(src[start_index + i].pLibraries, 0, 1);
      }
  }
  return ptr;
}

template<>
VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>(const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].extendedDynamicState = src[start_index + i].extendedDynamicState;
  }
  return ptr;
}

template<>
VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>(const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].extendedDynamicState2 = src[start_index + i].extendedDynamicState2;
      ptr[i].extendedDynamicState2LogicOp = src[start_index + i].extendedDynamicState2LogicOp;
      ptr[i].extendedDynamicState2PatchControlPoints = src[start_index + i].extendedDynamicState2PatchControlPoints;
  }
  return ptr;
}

template<>
VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR>(const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeaturesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].shaderZeroInitializeWorkgroupMemory = src[start_index + i].shaderZeroInitializeWorkgroupMemory;
  }
  return ptr;
}

template<>
VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>(const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].shaderSubgroupUniformControlFlow = src[start_index + i].shaderSubgroupUniformControlFlow;
  }
  return ptr;
}

template<>
VkPhysicalDeviceRobustness2FeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceRobustness2FeaturesEXT>(const VkPhysicalDeviceRobustness2FeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceRobustness2FeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceRobustness2FeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].robustBufferAccess2 = src[start_index + i].robustBufferAccess2;
      ptr[i].robustImageAccess2 = src[start_index + i].robustImageAccess2;
      ptr[i].nullDescriptor = src[start_index + i].nullDescriptor;
  }
  return ptr;
}

template<>
VkPhysicalDeviceRobustness2PropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceRobustness2PropertiesEXT>(const VkPhysicalDeviceRobustness2PropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceRobustness2PropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceRobustness2PropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].robustStorageBufferAccessSizeAlignment = src[start_index + i].robustStorageBufferAccessSizeAlignment;
      ptr[i].robustUniformBufferAccessSizeAlignment = src[start_index + i].robustUniformBufferAccessSizeAlignment;
  }
  return ptr;
}

template<>
VkPhysicalDeviceImageRobustnessFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceImageRobustnessFeaturesEXT>(const VkPhysicalDeviceImageRobustnessFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceImageRobustnessFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceImageRobustnessFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].robustImageAccess = src[start_index + i].robustImageAccess;
  }
  return ptr;
}

template<>
VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>(const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].workgroupMemoryExplicitLayout = src[start_index + i].workgroupMemoryExplicitLayout;
      ptr[i].workgroupMemoryExplicitLayoutScalarBlockLayout = src[start_index + i].workgroupMemoryExplicitLayoutScalarBlockLayout;
      ptr[i].workgroupMemoryExplicitLayout8BitAccess = src[start_index + i].workgroupMemoryExplicitLayout8BitAccess;
      ptr[i].workgroupMemoryExplicitLayout16BitAccess = src[start_index + i].workgroupMemoryExplicitLayout16BitAccess;
  }
  return ptr;
}

template<>
VkPhysicalDevice4444FormatsFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDevice4444FormatsFeaturesEXT>(const VkPhysicalDevice4444FormatsFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDevice4444FormatsFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDevice4444FormatsFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].formatA4R4G4B4 = src[start_index + i].formatA4R4G4B4;
      ptr[i].formatA4B4G4R4 = src[start_index + i].formatA4B4G4R4;
  }
  return ptr;
}

template<>
VkBufferCopy2KHR *CommandRecorder::CopyArray<VkBufferCopy2KHR>(const VkBufferCopy2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBufferCopy2KHR *>(m_allocator.Alloc(sizeof(VkBufferCopy2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcOffset = src[start_index + i].srcOffset;
      ptr[i].dstOffset = src[start_index + i].dstOffset;
      ptr[i].size = src[start_index + i].size;
  }
  return ptr;
}

template<>
VkImageCopy2KHR *CommandRecorder::CopyArray<VkImageCopy2KHR>(const VkImageCopy2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageCopy2KHR *>(m_allocator.Alloc(sizeof(VkImageCopy2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcSubresource = src[start_index + i].srcSubresource;
      ptr[i].srcOffset = src[start_index + i].srcOffset;
      ptr[i].dstSubresource = src[start_index + i].dstSubresource;
      ptr[i].dstOffset = src[start_index + i].dstOffset;
      ptr[i].extent = src[start_index + i].extent;
  }
  return ptr;
}

template<>
VkImageBlit2KHR *CommandRecorder::CopyArray<VkImageBlit2KHR>(const VkImageBlit2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageBlit2KHR *>(m_allocator.Alloc(sizeof(VkImageBlit2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcSubresource = src[start_index + i].srcSubresource;
      std::memcpy(ptr[i].srcOffsets, src[start_index + i].srcOffsets, sizeof(src[start_index + i].srcOffsets));
      ptr[i].dstSubresource = src[start_index + i].dstSubresource;
      std::memcpy(ptr[i].dstOffsets, src[start_index + i].dstOffsets, sizeof(src[start_index + i].dstOffsets));
  }
  return ptr;
}

template<>
VkBufferImageCopy2KHR *CommandRecorder::CopyArray<VkBufferImageCopy2KHR>(const VkBufferImageCopy2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBufferImageCopy2KHR *>(m_allocator.Alloc(sizeof(VkBufferImageCopy2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].bufferOffset = src[start_index + i].bufferOffset;
      ptr[i].bufferRowLength = src[start_index + i].bufferRowLength;
      ptr[i].bufferImageHeight = src[start_index + i].bufferImageHeight;
      ptr[i].imageSubresource = src[start_index + i].imageSubresource;
      ptr[i].imageOffset = src[start_index + i].imageOffset;
      ptr[i].imageExtent = src[start_index + i].imageExtent;
  }
  return ptr;
}

template<>
VkImageResolve2KHR *CommandRecorder::CopyArray<VkImageResolve2KHR>(const VkImageResolve2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageResolve2KHR *>(m_allocator.Alloc(sizeof(VkImageResolve2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcSubresource = src[start_index + i].srcSubresource;
      ptr[i].srcOffset = src[start_index + i].srcOffset;
      ptr[i].dstSubresource = src[start_index + i].dstSubresource;
      ptr[i].dstOffset = src[start_index + i].dstOffset;
      ptr[i].extent = src[start_index + i].extent;
  }
  return ptr;
}

template<>
VkCopyBufferInfo2KHR *CommandRecorder::CopyArray<VkCopyBufferInfo2KHR>(const VkCopyBufferInfo2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkCopyBufferInfo2KHR *>(m_allocator.Alloc(sizeof(VkCopyBufferInfo2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcBuffer = src[start_index + i].srcBuffer;
      ptr[i].dstBuffer = src[start_index + i].dstBuffer;
      ptr[i].regionCount = src[start_index + i].regionCount;
      ptr[i].pRegions = nullptr;
      if (src[start_index + i].pRegions) {
        ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
      }
  }
  return ptr;
}

template<>
VkCopyImageInfo2KHR *CommandRecorder::CopyArray<VkCopyImageInfo2KHR>(const VkCopyImageInfo2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkCopyImageInfo2KHR *>(m_allocator.Alloc(sizeof(VkCopyImageInfo2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcImage = src[start_index + i].srcImage;
      ptr[i].srcImageLayout = src[start_index + i].srcImageLayout;
      ptr[i].dstImage = src[start_index + i].dstImage;
      ptr[i].dstImageLayout = src[start_index + i].dstImageLayout;
      ptr[i].regionCount = src[start_index + i].regionCount;
      ptr[i].pRegions = nullptr;
      if (src[start_index + i].pRegions) {
        ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
      }
  }
  return ptr;
}

template<>
VkBlitImageInfo2KHR *CommandRecorder::CopyArray<VkBlitImageInfo2KHR>(const VkBlitImageInfo2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBlitImageInfo2KHR *>(m_allocator.Alloc(sizeof(VkBlitImageInfo2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcImage = src[start_index + i].srcImage;
      ptr[i].srcImageLayout = src[start_index + i].srcImageLayout;
      ptr[i].dstImage = src[start_index + i].dstImage;
      ptr[i].dstImageLayout = src[start_index + i].dstImageLayout;
      ptr[i].regionCount = src[start_index + i].regionCount;
      ptr[i].pRegions = nullptr;
      if (src[start_index + i].pRegions) {
        ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
      }
      ptr[i].filter = src[start_index + i].filter;
  }
  return ptr;
}

template<>
VkCopyBufferToImageInfo2KHR *CommandRecorder::CopyArray<VkCopyBufferToImageInfo2KHR>(const VkCopyBufferToImageInfo2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkCopyBufferToImageInfo2KHR *>(m_allocator.Alloc(sizeof(VkCopyBufferToImageInfo2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcBuffer = src[start_index + i].srcBuffer;
      ptr[i].dstImage = src[start_index + i].dstImage;
      ptr[i].dstImageLayout = src[start_index + i].dstImageLayout;
      ptr[i].regionCount = src[start_index + i].regionCount;
      ptr[i].pRegions = nullptr;
      if (src[start_index + i].pRegions) {
        ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
      }
  }
  return ptr;
}

template<>
VkCopyImageToBufferInfo2KHR *CommandRecorder::CopyArray<VkCopyImageToBufferInfo2KHR>(const VkCopyImageToBufferInfo2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkCopyImageToBufferInfo2KHR *>(m_allocator.Alloc(sizeof(VkCopyImageToBufferInfo2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcImage = src[start_index + i].srcImage;
      ptr[i].srcImageLayout = src[start_index + i].srcImageLayout;
      ptr[i].dstBuffer = src[start_index + i].dstBuffer;
      ptr[i].regionCount = src[start_index + i].regionCount;
      ptr[i].pRegions = nullptr;
      if (src[start_index + i].pRegions) {
        ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
      }
  }
  return ptr;
}

template<>
VkResolveImageInfo2KHR *CommandRecorder::CopyArray<VkResolveImageInfo2KHR>(const VkResolveImageInfo2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkResolveImageInfo2KHR *>(m_allocator.Alloc(sizeof(VkResolveImageInfo2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcImage = src[start_index + i].srcImage;
      ptr[i].srcImageLayout = src[start_index + i].srcImageLayout;
      ptr[i].dstImage = src[start_index + i].dstImage;
      ptr[i].dstImageLayout = src[start_index + i].dstImageLayout;
      ptr[i].regionCount = src[start_index + i].regionCount;
      ptr[i].pRegions = nullptr;
      if (src[start_index + i].pRegions) {
        ptr[i].pRegions = CopyArray<>(src[start_index + i].pRegions, 0, 1);
      }
  }
  return ptr;
}

template<>
VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>(const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].shaderImageInt64Atomics = src[start_index + i].shaderImageInt64Atomics;
      ptr[i].sparseImageInt64Atomics = src[start_index + i].sparseImageInt64Atomics;
  }
  return ptr;
}

template<>
VkFragmentShadingRateAttachmentInfoKHR *CommandRecorder::CopyArray<VkFragmentShadingRateAttachmentInfoKHR>(const VkFragmentShadingRateAttachmentInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkFragmentShadingRateAttachmentInfoKHR *>(m_allocator.Alloc(sizeof(VkFragmentShadingRateAttachmentInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].pFragmentShadingRateAttachment = nullptr;
      if (src[start_index + i].pFragmentShadingRateAttachment) {
        ptr[i].pFragmentShadingRateAttachment = CopyArray<>(src[start_index + i].pFragmentShadingRateAttachment, 0, 1);
      }
      ptr[i].shadingRateAttachmentTexelSize = src[start_index + i].shadingRateAttachmentTexelSize;
  }
  return ptr;
}

template<>
VkPipelineFragmentShadingRateStateCreateInfoKHR *CommandRecorder::CopyArray<VkPipelineFragmentShadingRateStateCreateInfoKHR>(const VkPipelineFragmentShadingRateStateCreateInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineFragmentShadingRateStateCreateInfoKHR *>(m_allocator.Alloc(sizeof(VkPipelineFragmentShadingRateStateCreateInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].fragmentSize = src[start_index + i].fragmentSize;
      std::memcpy(ptr[i].combinerOps, src[start_index + i].combinerOps, sizeof(src[start_index + i].combinerOps));
  }
  return ptr;
}

template<>
VkPhysicalDeviceFragmentShadingRateFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>(const VkPhysicalDeviceFragmentShadingRateFeaturesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentShadingRateFeaturesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].pipelineFragmentShadingRate = src[start_index + i].pipelineFragmentShadingRate;
      ptr[i].primitiveFragmentShadingRate = src[start_index + i].primitiveFragmentShadingRate;
      ptr[i].attachmentFragmentShadingRate = src[start_index + i].attachmentFragmentShadingRate;
  }
  return ptr;
}

template<>
VkPhysicalDeviceFragmentShadingRatePropertiesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRatePropertiesKHR>(const VkPhysicalDeviceFragmentShadingRatePropertiesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentShadingRatePropertiesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentShadingRatePropertiesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].minFragmentShadingRateAttachmentTexelSize = src[start_index + i].minFragmentShadingRateAttachmentTexelSize;
      ptr[i].maxFragmentShadingRateAttachmentTexelSize = src[start_index + i].maxFragmentShadingRateAttachmentTexelSize;
      ptr[i].maxFragmentShadingRateAttachmentTexelSizeAspectRatio = src[start_index + i].maxFragmentShadingRateAttachmentTexelSizeAspectRatio;
      ptr[i].primitiveFragmentShadingRateWithMultipleViewports = src[start_index + i].primitiveFragmentShadingRateWithMultipleViewports;
      ptr[i].layeredShadingRateAttachments = src[start_index + i].layeredShadingRateAttachments;
      ptr[i].fragmentShadingRateNonTrivialCombinerOps = src[start_index + i].fragmentShadingRateNonTrivialCombinerOps;
      ptr[i].maxFragmentSize = src[start_index + i].maxFragmentSize;
      ptr[i].maxFragmentSizeAspectRatio = src[start_index + i].maxFragmentSizeAspectRatio;
      ptr[i].maxFragmentShadingRateCoverageSamples = src[start_index + i].maxFragmentShadingRateCoverageSamples;
      ptr[i].maxFragmentShadingRateRasterizationSamples = src[start_index + i].maxFragmentShadingRateRasterizationSamples;
      ptr[i].fragmentShadingRateWithShaderDepthStencilWrites = src[start_index + i].fragmentShadingRateWithShaderDepthStencilWrites;
      ptr[i].fragmentShadingRateWithSampleMask = src[start_index + i].fragmentShadingRateWithSampleMask;
      ptr[i].fragmentShadingRateWithShaderSampleMask = src[start_index + i].fragmentShadingRateWithShaderSampleMask;
      ptr[i].fragmentShadingRateWithConservativeRasterization = src[start_index + i].fragmentShadingRateWithConservativeRasterization;
      ptr[i].fragmentShadingRateWithFragmentShaderInterlock = src[start_index + i].fragmentShadingRateWithFragmentShaderInterlock;
      ptr[i].fragmentShadingRateWithCustomSampleLocations = src[start_index + i].fragmentShadingRateWithCustomSampleLocations;
      ptr[i].fragmentShadingRateStrictMultiplyCombiner = src[start_index + i].fragmentShadingRateStrictMultiplyCombiner;
  }
  return ptr;
}

template<>
VkPhysicalDeviceFragmentShadingRateKHR *CommandRecorder::CopyArray<VkPhysicalDeviceFragmentShadingRateKHR>(const VkPhysicalDeviceFragmentShadingRateKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceFragmentShadingRateKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceFragmentShadingRateKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].sampleCounts = src[start_index + i].sampleCounts;
      ptr[i].fragmentSize = src[start_index + i].fragmentSize;
  }
  return ptr;
}

template<>
VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR>(const VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderTerminateInvocationFeaturesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].shaderTerminateInvocation = src[start_index + i].shaderTerminateInvocation;
  }
  return ptr;
}

template<>
VkAccelerationStructureBuildSizesInfoKHR *CommandRecorder::CopyArray<VkAccelerationStructureBuildSizesInfoKHR>(const VkAccelerationStructureBuildSizesInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAccelerationStructureBuildSizesInfoKHR *>(m_allocator.Alloc(sizeof(VkAccelerationStructureBuildSizesInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].accelerationStructureSize = src[start_index + i].accelerationStructureSize;
      ptr[i].updateScratchSize = src[start_index + i].updateScratchSize;
      ptr[i].buildScratchSize = src[start_index + i].buildScratchSize;
  }
  return ptr;
}

template<>
VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>(const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].vertexInputDynamicState = src[start_index + i].vertexInputDynamicState;
  }
  return ptr;
}

template<>
VkVertexInputBindingDescription2EXT *CommandRecorder::CopyArray<VkVertexInputBindingDescription2EXT>(const VkVertexInputBindingDescription2EXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkVertexInputBindingDescription2EXT *>(m_allocator.Alloc(sizeof(VkVertexInputBindingDescription2EXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].binding = src[start_index + i].binding;
      ptr[i].stride = src[start_index + i].stride;
      ptr[i].inputRate = src[start_index + i].inputRate;
      ptr[i].divisor = src[start_index + i].divisor;
  }
  return ptr;
}

template<>
VkVertexInputAttributeDescription2EXT *CommandRecorder::CopyArray<VkVertexInputAttributeDescription2EXT>(const VkVertexInputAttributeDescription2EXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkVertexInputAttributeDescription2EXT *>(m_allocator.Alloc(sizeof(VkVertexInputAttributeDescription2EXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].location = src[start_index + i].location;
      ptr[i].binding = src[start_index + i].binding;
      ptr[i].format = src[start_index + i].format;
      ptr[i].offset = src[start_index + i].offset;
  }
  return ptr;
}

template<>
VkPhysicalDeviceColorWriteEnableFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceColorWriteEnableFeaturesEXT>(const VkPhysicalDeviceColorWriteEnableFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceColorWriteEnableFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceColorWriteEnableFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].colorWriteEnable = src[start_index + i].colorWriteEnable;
  }
  return ptr;
}

template<>
VkPipelineColorWriteCreateInfoEXT *CommandRecorder::CopyArray<VkPipelineColorWriteCreateInfoEXT>(const VkPipelineColorWriteCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineColorWriteCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkPipelineColorWriteCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].attachmentCount = src[start_index + i].attachmentCount;
      ptr[i].pColorWriteEnables = nullptr;
      if (src[start_index + i].pColorWriteEnables) {
        ptr[i].pColorWriteEnables = CopyArray<>(src[start_index + i].pColorWriteEnables, 0, 1);
      }
  }
  return ptr;
}

template<>
VkMemoryBarrier2KHR *CommandRecorder::CopyArray<VkMemoryBarrier2KHR>(const VkMemoryBarrier2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMemoryBarrier2KHR *>(m_allocator.Alloc(sizeof(VkMemoryBarrier2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcStageMask = src[start_index + i].srcStageMask;
      ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
      ptr[i].dstStageMask = src[start_index + i].dstStageMask;
      ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
  }
  return ptr;
}

template<>
VkImageMemoryBarrier2KHR *CommandRecorder::CopyArray<VkImageMemoryBarrier2KHR>(const VkImageMemoryBarrier2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageMemoryBarrier2KHR *>(m_allocator.Alloc(sizeof(VkImageMemoryBarrier2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcStageMask = src[start_index + i].srcStageMask;
      ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
      ptr[i].dstStageMask = src[start_index + i].dstStageMask;
      ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
      ptr[i].oldLayout = src[start_index + i].oldLayout;
      ptr[i].newLayout = src[start_index + i].newLayout;
      ptr[i].srcQueueFamilyIndex = src[start_index + i].srcQueueFamilyIndex;
      ptr[i].dstQueueFamilyIndex = src[start_index + i].dstQueueFamilyIndex;
      ptr[i].image = src[start_index + i].image;
      ptr[i].subresourceRange = src[start_index + i].subresourceRange;
  }
  return ptr;
}

template<>
VkBufferMemoryBarrier2KHR *CommandRecorder::CopyArray<VkBufferMemoryBarrier2KHR>(const VkBufferMemoryBarrier2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBufferMemoryBarrier2KHR *>(m_allocator.Alloc(sizeof(VkBufferMemoryBarrier2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcStageMask = src[start_index + i].srcStageMask;
      ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
      ptr[i].dstStageMask = src[start_index + i].dstStageMask;
      ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
      ptr[i].srcQueueFamilyIndex = src[start_index + i].srcQueueFamilyIndex;
      ptr[i].dstQueueFamilyIndex = src[start_index + i].dstQueueFamilyIndex;
      ptr[i].buffer = src[start_index + i].buffer;
      ptr[i].offset = src[start_index + i].offset;
      ptr[i].size = src[start_index + i].size;
  }
  return ptr;
}

template<>
VkDependencyInfoKHR *CommandRecorder::CopyArray<VkDependencyInfoKHR>(const VkDependencyInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDependencyInfoKHR *>(m_allocator.Alloc(sizeof(VkDependencyInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].dependencyFlags = src[start_index + i].dependencyFlags;
      ptr[i].memoryBarrierCount = src[start_index + i].memoryBarrierCount;
      ptr[i].pMemoryBarriers = nullptr;
      if (src[start_index + i].pMemoryBarriers) {
        ptr[i].pMemoryBarriers = CopyArray<>(src[start_index + i].pMemoryBarriers, 0, 1);
      }
      ptr[i].bufferMemoryBarrierCount = src[start_index + i].bufferMemoryBarrierCount;
      ptr[i].pBufferMemoryBarriers = nullptr;
      if (src[start_index + i].pBufferMemoryBarriers) {
        ptr[i].pBufferMemoryBarriers = CopyArray<>(src[start_index + i].pBufferMemoryBarriers, 0, 1);
      }
      ptr[i].imageMemoryBarrierCount = src[start_index + i].imageMemoryBarrierCount;
      ptr[i].pImageMemoryBarriers = nullptr;
      if (src[start_index + i].pImageMemoryBarriers) {
        ptr[i].pImageMemoryBarriers = CopyArray<>(src[start_index + i].pImageMemoryBarriers, 0, 1);
      }
  }
  return ptr;
}

template<>
VkSemaphoreSubmitInfoKHR *CommandRecorder::CopyArray<VkSemaphoreSubmitInfoKHR>(const VkSemaphoreSubmitInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSemaphoreSubmitInfoKHR *>(m_allocator.Alloc(sizeof(VkSemaphoreSubmitInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].semaphore = src[start_index + i].semaphore;
      ptr[i].value = src[start_index + i].value;
      ptr[i].stageMask = src[start_index + i].stageMask;
      ptr[i].deviceIndex = src[start_index + i].deviceIndex;
  }
  return ptr;
}

template<>
VkCommandBufferSubmitInfoKHR *CommandRecorder::CopyArray<VkCommandBufferSubmitInfoKHR>(const VkCommandBufferSubmitInfoKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkCommandBufferSubmitInfoKHR *>(m_allocator.Alloc(sizeof(VkCommandBufferSubmitInfoKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].commandBuffer = src[start_index + i].commandBuffer;
      ptr[i].deviceMask = src[start_index + i].deviceMask;
  }
  return ptr;
}

template<>
VkSubmitInfo2KHR *CommandRecorder::CopyArray<VkSubmitInfo2KHR>(const VkSubmitInfo2KHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSubmitInfo2KHR *>(m_allocator.Alloc(sizeof(VkSubmitInfo2KHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].waitSemaphoreInfoCount = src[start_index + i].waitSemaphoreInfoCount;
      ptr[i].pWaitSemaphoreInfos = nullptr;
      if (src[start_index + i].pWaitSemaphoreInfos) {
        ptr[i].pWaitSemaphoreInfos = CopyArray<>(src[start_index + i].pWaitSemaphoreInfos, 0, 1);
      }
      ptr[i].commandBufferInfoCount = src[start_index + i].commandBufferInfoCount;
      ptr[i].pCommandBufferInfos = nullptr;
      if (src[start_index + i].pCommandBufferInfos) {
        ptr[i].pCommandBufferInfos = CopyArray<>(src[start_index + i].pCommandBufferInfos, 0, 1);
      }
      ptr[i].signalSemaphoreInfoCount = src[start_index + i].signalSemaphoreInfoCount;
      ptr[i].pSignalSemaphoreInfos = nullptr;
      if (src[start_index + i].pSignalSemaphoreInfos) {
        ptr[i].pSignalSemaphoreInfos = CopyArray<>(src[start_index + i].pSignalSemaphoreInfos, 0, 1);
      }
  }
  return ptr;
}

template<>
VkQueueFamilyCheckpointProperties2NV *CommandRecorder::CopyArray<VkQueueFamilyCheckpointProperties2NV>(const VkQueueFamilyCheckpointProperties2NV *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkQueueFamilyCheckpointProperties2NV *>(m_allocator.Alloc(sizeof(VkQueueFamilyCheckpointProperties2NV) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].checkpointExecutionStageMask = src[start_index + i].checkpointExecutionStageMask;
  }
  return ptr;
}

template<>
VkCheckpointData2NV *CommandRecorder::CopyArray<VkCheckpointData2NV>(const VkCheckpointData2NV *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkCheckpointData2NV *>(m_allocator.Alloc(sizeof(VkCheckpointData2NV) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].stage = src[start_index + i].stage;
      ptr[i].pCheckpointMarker = src[start_index + i].pCheckpointMarker;
  }
  return ptr;
}

template<>
VkPhysicalDeviceSynchronization2FeaturesKHR *CommandRecorder::CopyArray<VkPhysicalDeviceSynchronization2FeaturesKHR>(const VkPhysicalDeviceSynchronization2FeaturesKHR *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceSynchronization2FeaturesKHR *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceSynchronization2FeaturesKHR) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].synchronization2 = src[start_index + i].synchronization2;
  }
  return ptr;
}

template<>
VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>(const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].ycbcr2plane444Formats = src[start_index + i].ycbcr2plane444Formats;
  }
  return ptr;
}

template<>
VkPhysicalDeviceProvokingVertexFeaturesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceProvokingVertexFeaturesEXT>(const VkPhysicalDeviceProvokingVertexFeaturesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceProvokingVertexFeaturesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceProvokingVertexFeaturesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].provokingVertexLast = src[start_index + i].provokingVertexLast;
      ptr[i].transformFeedbackPreservesProvokingVertex = src[start_index + i].transformFeedbackPreservesProvokingVertex;
  }
  return ptr;
}

template<>
VkPhysicalDeviceProvokingVertexPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceProvokingVertexPropertiesEXT>(const VkPhysicalDeviceProvokingVertexPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceProvokingVertexPropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceProvokingVertexPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].provokingVertexModePerPipeline = src[start_index + i].provokingVertexModePerPipeline;
      ptr[i].transformFeedbackPreservesTriangleFanProvokingVertex = src[start_index + i].transformFeedbackPreservesTriangleFanProvokingVertex;
  }
  return ptr;
}

template<>
VkPipelineRasterizationProvokingVertexStateCreateInfoEXT *CommandRecorder::CopyArray<VkPipelineRasterizationProvokingVertexStateCreateInfoEXT>(const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineRasterizationProvokingVertexStateCreateInfoEXT *>(m_allocator.Alloc(sizeof(VkPipelineRasterizationProvokingVertexStateCreateInfoEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].provokingVertexMode = src[start_index + i].provokingVertexMode;
  }
  return ptr;
}

template<>
VkPhysicalDeviceDrmPropertiesEXT *CommandRecorder::CopyArray<VkPhysicalDeviceDrmPropertiesEXT>(const VkPhysicalDeviceDrmPropertiesEXT *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceDrmPropertiesEXT *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceDrmPropertiesEXT) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].hasPrimary = src[start_index + i].hasPrimary;
      ptr[i].hasRender = src[start_index + i].hasRender;
      ptr[i].primaryMajor = src[start_index + i].primaryMajor;
      ptr[i].primaryMinor = src[start_index + i].primaryMinor;
      ptr[i].renderMajor = src[start_index + i].renderMajor;
      ptr[i].renderMinor = src[start_index + i].renderMinor;
  }
  return ptr;
}

template<>
VkBaseOutStructure *CommandRecorder::CopyArray<VkBaseOutStructure>(const VkBaseOutStructure *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBaseOutStructure *>(m_allocator.Alloc(sizeof(VkBaseOutStructure) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = nullptr;
      if (src[start_index + i].pNext) {
        ptr[i].pNext = CopyArray<>(src[start_index + i].pNext, 0, 1);
      }
  }
  return ptr;
}

template<>
VkBaseInStructure *CommandRecorder::CopyArray<VkBaseInStructure>(const VkBaseInStructure *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBaseInStructure *>(m_allocator.Alloc(sizeof(VkBaseInStructure) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = nullptr;
      if (src[start_index + i].pNext) {
        ptr[i].pNext = CopyArray<>(src[start_index + i].pNext, 0, 1);
      }
  }
  return ptr;
}

template<>
VkOffset2D *CommandRecorder::CopyArray<VkOffset2D>(const VkOffset2D *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkOffset2D *>(m_allocator.Alloc(sizeof(VkOffset2D) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].x = src[start_index + i].x;
      ptr[i].y = src[start_index + i].y;
  }
  return ptr;
}

template<>
VkOffset3D *CommandRecorder::CopyArray<VkOffset3D>(const VkOffset3D *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkOffset3D *>(m_allocator.Alloc(sizeof(VkOffset3D) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].x = src[start_index + i].x;
      ptr[i].y = src[start_index + i].y;
      ptr[i].z = src[start_index + i].z;
  }
  return ptr;
}

template<>
VkExtent2D *CommandRecorder::CopyArray<VkExtent2D>(const VkExtent2D *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkExtent2D *>(m_allocator.Alloc(sizeof(VkExtent2D) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].width = src[start_index + i].width;
      ptr[i].height = src[start_index + i].height;
  }
  return ptr;
}

template<>
VkExtent3D *CommandRecorder::CopyArray<VkExtent3D>(const VkExtent3D *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkExtent3D *>(m_allocator.Alloc(sizeof(VkExtent3D) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].width = src[start_index + i].width;
      ptr[i].height = src[start_index + i].height;
      ptr[i].depth = src[start_index + i].depth;
  }
  return ptr;
}

template<>
VkViewport *CommandRecorder::CopyArray<VkViewport>(const VkViewport *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkViewport *>(m_allocator.Alloc(sizeof(VkViewport) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].x = src[start_index + i].x;
      ptr[i].y = src[start_index + i].y;
      ptr[i].width = src[start_index + i].width;
      ptr[i].height = src[start_index + i].height;
      ptr[i].minDepth = src[start_index + i].minDepth;
      ptr[i].maxDepth = src[start_index + i].maxDepth;
  }
  return ptr;
}

template<>
VkRect2D *CommandRecorder::CopyArray<VkRect2D>(const VkRect2D *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkRect2D *>(m_allocator.Alloc(sizeof(VkRect2D) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].offset = src[start_index + i].offset;
      ptr[i].extent = src[start_index + i].extent;
  }
  return ptr;
}

template<>
VkClearRect *CommandRecorder::CopyArray<VkClearRect>(const VkClearRect *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkClearRect *>(m_allocator.Alloc(sizeof(VkClearRect) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].rect = src[start_index + i].rect;
      ptr[i].baseArrayLayer = src[start_index + i].baseArrayLayer;
      ptr[i].layerCount = src[start_index + i].layerCount;
  }
  return ptr;
}

template<>
VkComponentMapping *CommandRecorder::CopyArray<VkComponentMapping>(const VkComponentMapping *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkComponentMapping *>(m_allocator.Alloc(sizeof(VkComponentMapping) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].r = src[start_index + i].r;
      ptr[i].g = src[start_index + i].g;
      ptr[i].b = src[start_index + i].b;
      ptr[i].a = src[start_index + i].a;
  }
  return ptr;
}

template<>
VkPhysicalDeviceProperties *CommandRecorder::CopyArray<VkPhysicalDeviceProperties>(const VkPhysicalDeviceProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceProperties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].apiVersion = src[start_index + i].apiVersion;
      ptr[i].driverVersion = src[start_index + i].driverVersion;
      ptr[i].vendorID = src[start_index + i].vendorID;
      ptr[i].deviceID = src[start_index + i].deviceID;
      ptr[i].deviceType = src[start_index + i].deviceType;
      std::memcpy(ptr[i].deviceName, src[start_index + i].deviceName, sizeof(src[start_index + i].deviceName));
      std::memcpy(ptr[i].pipelineCacheUUID, src[start_index + i].pipelineCacheUUID, sizeof(src[start_index + i].pipelineCacheUUID));
      ptr[i].limits = src[start_index + i].limits;
      ptr[i].sparseProperties = src[start_index + i].sparseProperties;
  }
  return ptr;
}

template<>
VkExtensionProperties *CommandRecorder::CopyArray<VkExtensionProperties>(const VkExtensionProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkExtensionProperties *>(m_allocator.Alloc(sizeof(VkExtensionProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      std::memcpy(ptr[i].extensionName, src[start_index + i].extensionName, sizeof(src[start_index + i].extensionName));
      ptr[i].specVersion = src[start_index + i].specVersion;
  }
  return ptr;
}

template<>
VkLayerProperties *CommandRecorder::CopyArray<VkLayerProperties>(const VkLayerProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkLayerProperties *>(m_allocator.Alloc(sizeof(VkLayerProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      std::memcpy(ptr[i].layerName, src[start_index + i].layerName, sizeof(src[start_index + i].layerName));
      ptr[i].specVersion = src[start_index + i].specVersion;
      ptr[i].implementationVersion = src[start_index + i].implementationVersion;
      std::memcpy(ptr[i].description, src[start_index + i].description, sizeof(src[start_index + i].description));
  }
  return ptr;
}

template<>
VkApplicationInfo *CommandRecorder::CopyArray<VkApplicationInfo>(const VkApplicationInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkApplicationInfo *>(m_allocator.Alloc(sizeof(VkApplicationInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].pApplicationName = nullptr;
    if (src[start_index + i].pApplicationName) {
      ptr[i].pApplicationName = CopyArray<>(src[start_index + i].pApplicationName, 0, strlen(src[start_index + i].pApplicationName));
    }
      ptr[i].applicationVersion = src[start_index + i].applicationVersion;
      ptr[i].pEngineName = nullptr;
    if (src[start_index + i].pEngineName) {
      ptr[i].pEngineName = CopyArray<>(src[start_index + i].pEngineName, 0, strlen(src[start_index + i].pEngineName));
    }
      ptr[i].engineVersion = src[start_index + i].engineVersion;
      ptr[i].apiVersion = src[start_index + i].apiVersion;
  }
  return ptr;
}

template<>
VkAllocationCallbacks *CommandRecorder::CopyArray<VkAllocationCallbacks>(const VkAllocationCallbacks *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAllocationCallbacks *>(m_allocator.Alloc(sizeof(VkAllocationCallbacks) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].pUserData = src[start_index + i].pUserData;
      ptr[i].pfnAllocation = src[start_index + i].pfnAllocation;
      ptr[i].pfnReallocation = src[start_index + i].pfnReallocation;
      ptr[i].pfnFree = src[start_index + i].pfnFree;
      ptr[i].pfnInternalAllocation = src[start_index + i].pfnInternalAllocation;
      ptr[i].pfnInternalFree = src[start_index + i].pfnInternalFree;
  }
  return ptr;
}

template<>
VkDeviceQueueCreateInfo *CommandRecorder::CopyArray<VkDeviceQueueCreateInfo>(const VkDeviceQueueCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceQueueCreateInfo *>(m_allocator.Alloc(sizeof(VkDeviceQueueCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].queueFamilyIndex = src[start_index + i].queueFamilyIndex;
      ptr[i].queueCount = src[start_index + i].queueCount;
      ptr[i].pQueuePriorities = nullptr;
      if (src[start_index + i].pQueuePriorities) {
        ptr[i].pQueuePriorities = CopyArray<>(src[start_index + i].pQueuePriorities, 0, 1);
      }
  }
  return ptr;
}

template<>
VkDeviceCreateInfo *CommandRecorder::CopyArray<VkDeviceCreateInfo>(const VkDeviceCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceCreateInfo *>(m_allocator.Alloc(sizeof(VkDeviceCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].queueCreateInfoCount = src[start_index + i].queueCreateInfoCount;
      ptr[i].pQueueCreateInfos = nullptr;
      if (src[start_index + i].pQueueCreateInfos) {
        ptr[i].pQueueCreateInfos = CopyArray<>(src[start_index + i].pQueueCreateInfos, 0, 1);
      }
      ptr[i].enabledLayerCount = src[start_index + i].enabledLayerCount;
      ptr[i].ppEnabledLayerNames = nullptr;
      if (src[start_index + i].ppEnabledLayerNames) {
        ptr[i].ppEnabledLayerNames = CopyArray<>(src[start_index + i].ppEnabledLayerNames, 0, 1);
      }
      ptr[i].enabledExtensionCount = src[start_index + i].enabledExtensionCount;
      ptr[i].ppEnabledExtensionNames = nullptr;
      if (src[start_index + i].ppEnabledExtensionNames) {
        ptr[i].ppEnabledExtensionNames = CopyArray<>(src[start_index + i].ppEnabledExtensionNames, 0, 1);
      }
      ptr[i].pEnabledFeatures = nullptr;
      if (src[start_index + i].pEnabledFeatures) {
        ptr[i].pEnabledFeatures = CopyArray<>(src[start_index + i].pEnabledFeatures, 0, 1);
      }
  }
  return ptr;
}

template<>
VkInstanceCreateInfo *CommandRecorder::CopyArray<VkInstanceCreateInfo>(const VkInstanceCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkInstanceCreateInfo *>(m_allocator.Alloc(sizeof(VkInstanceCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].pApplicationInfo = nullptr;
      if (src[start_index + i].pApplicationInfo) {
        ptr[i].pApplicationInfo = CopyArray<>(src[start_index + i].pApplicationInfo, 0, 1);
      }
      ptr[i].enabledLayerCount = src[start_index + i].enabledLayerCount;
      ptr[i].ppEnabledLayerNames = nullptr;
      if (src[start_index + i].ppEnabledLayerNames) {
        ptr[i].ppEnabledLayerNames = CopyArray<>(src[start_index + i].ppEnabledLayerNames, 0, 1);
      }
      ptr[i].enabledExtensionCount = src[start_index + i].enabledExtensionCount;
      ptr[i].ppEnabledExtensionNames = nullptr;
      if (src[start_index + i].ppEnabledExtensionNames) {
        ptr[i].ppEnabledExtensionNames = CopyArray<>(src[start_index + i].ppEnabledExtensionNames, 0, 1);
      }
  }
  return ptr;
}

template<>
VkQueueFamilyProperties *CommandRecorder::CopyArray<VkQueueFamilyProperties>(const VkQueueFamilyProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkQueueFamilyProperties *>(m_allocator.Alloc(sizeof(VkQueueFamilyProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].queueFlags = src[start_index + i].queueFlags;
      ptr[i].queueCount = src[start_index + i].queueCount;
      ptr[i].timestampValidBits = src[start_index + i].timestampValidBits;
      ptr[i].minImageTransferGranularity = src[start_index + i].minImageTransferGranularity;
  }
  return ptr;
}

template<>
VkPhysicalDeviceMemoryProperties *CommandRecorder::CopyArray<VkPhysicalDeviceMemoryProperties>(const VkPhysicalDeviceMemoryProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceMemoryProperties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceMemoryProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].memoryTypeCount = src[start_index + i].memoryTypeCount;
      std::memcpy(ptr[i].memoryTypes, src[start_index + i].memoryTypes, sizeof(src[start_index + i].memoryTypes));
      ptr[i].memoryHeapCount = src[start_index + i].memoryHeapCount;
      std::memcpy(ptr[i].memoryHeaps, src[start_index + i].memoryHeaps, sizeof(src[start_index + i].memoryHeaps));
  }
  return ptr;
}

template<>
VkMemoryAllocateInfo *CommandRecorder::CopyArray<VkMemoryAllocateInfo>(const VkMemoryAllocateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMemoryAllocateInfo *>(m_allocator.Alloc(sizeof(VkMemoryAllocateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].allocationSize = src[start_index + i].allocationSize;
      ptr[i].memoryTypeIndex = src[start_index + i].memoryTypeIndex;
  }
  return ptr;
}

template<>
VkMemoryRequirements *CommandRecorder::CopyArray<VkMemoryRequirements>(const VkMemoryRequirements *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMemoryRequirements *>(m_allocator.Alloc(sizeof(VkMemoryRequirements) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].size = src[start_index + i].size;
      ptr[i].alignment = src[start_index + i].alignment;
      ptr[i].memoryTypeBits = src[start_index + i].memoryTypeBits;
  }
  return ptr;
}

template<>
VkSparseImageFormatProperties *CommandRecorder::CopyArray<VkSparseImageFormatProperties>(const VkSparseImageFormatProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSparseImageFormatProperties *>(m_allocator.Alloc(sizeof(VkSparseImageFormatProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].aspectMask = src[start_index + i].aspectMask;
      ptr[i].imageGranularity = src[start_index + i].imageGranularity;
      ptr[i].flags = src[start_index + i].flags;
  }
  return ptr;
}

template<>
VkSparseImageMemoryRequirements *CommandRecorder::CopyArray<VkSparseImageMemoryRequirements>(const VkSparseImageMemoryRequirements *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSparseImageMemoryRequirements *>(m_allocator.Alloc(sizeof(VkSparseImageMemoryRequirements) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].formatProperties = src[start_index + i].formatProperties;
      ptr[i].imageMipTailFirstLod = src[start_index + i].imageMipTailFirstLod;
      ptr[i].imageMipTailSize = src[start_index + i].imageMipTailSize;
      ptr[i].imageMipTailOffset = src[start_index + i].imageMipTailOffset;
      ptr[i].imageMipTailStride = src[start_index + i].imageMipTailStride;
  }
  return ptr;
}

template<>
VkMemoryType *CommandRecorder::CopyArray<VkMemoryType>(const VkMemoryType *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMemoryType *>(m_allocator.Alloc(sizeof(VkMemoryType) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].propertyFlags = src[start_index + i].propertyFlags;
      ptr[i].heapIndex = src[start_index + i].heapIndex;
  }
  return ptr;
}

template<>
VkMemoryHeap *CommandRecorder::CopyArray<VkMemoryHeap>(const VkMemoryHeap *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMemoryHeap *>(m_allocator.Alloc(sizeof(VkMemoryHeap) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].size = src[start_index + i].size;
      ptr[i].flags = src[start_index + i].flags;
  }
  return ptr;
}

template<>
VkMappedMemoryRange *CommandRecorder::CopyArray<VkMappedMemoryRange>(const VkMappedMemoryRange *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMappedMemoryRange *>(m_allocator.Alloc(sizeof(VkMappedMemoryRange) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].memory = src[start_index + i].memory;
      ptr[i].offset = src[start_index + i].offset;
      ptr[i].size = src[start_index + i].size;
  }
  return ptr;
}

template<>
VkFormatProperties *CommandRecorder::CopyArray<VkFormatProperties>(const VkFormatProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkFormatProperties *>(m_allocator.Alloc(sizeof(VkFormatProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].linearTilingFeatures = src[start_index + i].linearTilingFeatures;
      ptr[i].optimalTilingFeatures = src[start_index + i].optimalTilingFeatures;
      ptr[i].bufferFeatures = src[start_index + i].bufferFeatures;
  }
  return ptr;
}

template<>
VkImageFormatProperties *CommandRecorder::CopyArray<VkImageFormatProperties>(const VkImageFormatProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageFormatProperties *>(m_allocator.Alloc(sizeof(VkImageFormatProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].maxExtent = src[start_index + i].maxExtent;
      ptr[i].maxMipLevels = src[start_index + i].maxMipLevels;
      ptr[i].maxArrayLayers = src[start_index + i].maxArrayLayers;
      ptr[i].sampleCounts = src[start_index + i].sampleCounts;
      ptr[i].maxResourceSize = src[start_index + i].maxResourceSize;
  }
  return ptr;
}

template<>
VkDescriptorBufferInfo *CommandRecorder::CopyArray<VkDescriptorBufferInfo>(const VkDescriptorBufferInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDescriptorBufferInfo *>(m_allocator.Alloc(sizeof(VkDescriptorBufferInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].buffer = src[start_index + i].buffer;
      ptr[i].offset = src[start_index + i].offset;
      ptr[i].range = src[start_index + i].range;
  }
  return ptr;
}

template<>
VkDescriptorImageInfo *CommandRecorder::CopyArray<VkDescriptorImageInfo>(const VkDescriptorImageInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDescriptorImageInfo *>(m_allocator.Alloc(sizeof(VkDescriptorImageInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sampler = src[start_index + i].sampler;
      ptr[i].imageView = src[start_index + i].imageView;
      ptr[i].imageLayout = src[start_index + i].imageLayout;
  }
  return ptr;
}

template<>
VkWriteDescriptorSet *CommandRecorder::CopyArray<VkWriteDescriptorSet>(const VkWriteDescriptorSet *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkWriteDescriptorSet *>(m_allocator.Alloc(sizeof(VkWriteDescriptorSet) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].dstSet = src[start_index + i].dstSet;
      ptr[i].dstBinding = src[start_index + i].dstBinding;
      ptr[i].dstArrayElement = src[start_index + i].dstArrayElement;
      ptr[i].descriptorCount = src[start_index + i].descriptorCount;
      ptr[i].descriptorType = src[start_index + i].descriptorType;
      ptr[i].pImageInfo = nullptr;
      if (src[start_index + i].pImageInfo) {
        ptr[i].pImageInfo = CopyArray<>(src[start_index + i].pImageInfo, 0, 1);
      }
      ptr[i].pBufferInfo = nullptr;
      if (src[start_index + i].pBufferInfo) {
        ptr[i].pBufferInfo = CopyArray<>(src[start_index + i].pBufferInfo, 0, 1);
      }
      ptr[i].pTexelBufferView = nullptr;
      if (src[start_index + i].pTexelBufferView) {
        ptr[i].pTexelBufferView = CopyArray<>(src[start_index + i].pTexelBufferView, 0, 1);
      }
  }
  return ptr;
}

template<>
VkCopyDescriptorSet *CommandRecorder::CopyArray<VkCopyDescriptorSet>(const VkCopyDescriptorSet *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkCopyDescriptorSet *>(m_allocator.Alloc(sizeof(VkCopyDescriptorSet) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcSet = src[start_index + i].srcSet;
      ptr[i].srcBinding = src[start_index + i].srcBinding;
      ptr[i].srcArrayElement = src[start_index + i].srcArrayElement;
      ptr[i].dstSet = src[start_index + i].dstSet;
      ptr[i].dstBinding = src[start_index + i].dstBinding;
      ptr[i].dstArrayElement = src[start_index + i].dstArrayElement;
      ptr[i].descriptorCount = src[start_index + i].descriptorCount;
  }
  return ptr;
}

template<>
VkBufferCreateInfo *CommandRecorder::CopyArray<VkBufferCreateInfo>(const VkBufferCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBufferCreateInfo *>(m_allocator.Alloc(sizeof(VkBufferCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].size = src[start_index + i].size;
      ptr[i].usage = src[start_index + i].usage;
      ptr[i].sharingMode = src[start_index + i].sharingMode;
      ptr[i].queueFamilyIndexCount = src[start_index + i].queueFamilyIndexCount;
      ptr[i].pQueueFamilyIndices = nullptr;
      if (src[start_index + i].pQueueFamilyIndices) {
        ptr[i].pQueueFamilyIndices = CopyArray<>(src[start_index + i].pQueueFamilyIndices, 0, 1);
      }
  }
  return ptr;
}

template<>
VkBufferViewCreateInfo *CommandRecorder::CopyArray<VkBufferViewCreateInfo>(const VkBufferViewCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBufferViewCreateInfo *>(m_allocator.Alloc(sizeof(VkBufferViewCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].buffer = src[start_index + i].buffer;
      ptr[i].format = src[start_index + i].format;
      ptr[i].offset = src[start_index + i].offset;
      ptr[i].range = src[start_index + i].range;
  }
  return ptr;
}

template<>
VkImageSubresource *CommandRecorder::CopyArray<VkImageSubresource>(const VkImageSubresource *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageSubresource *>(m_allocator.Alloc(sizeof(VkImageSubresource) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].aspectMask = src[start_index + i].aspectMask;
      ptr[i].mipLevel = src[start_index + i].mipLevel;
      ptr[i].arrayLayer = src[start_index + i].arrayLayer;
  }
  return ptr;
}

template<>
VkImageSubresourceLayers *CommandRecorder::CopyArray<VkImageSubresourceLayers>(const VkImageSubresourceLayers *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageSubresourceLayers *>(m_allocator.Alloc(sizeof(VkImageSubresourceLayers) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].aspectMask = src[start_index + i].aspectMask;
      ptr[i].mipLevel = src[start_index + i].mipLevel;
      ptr[i].baseArrayLayer = src[start_index + i].baseArrayLayer;
      ptr[i].layerCount = src[start_index + i].layerCount;
  }
  return ptr;
}

template<>
VkImageSubresourceRange *CommandRecorder::CopyArray<VkImageSubresourceRange>(const VkImageSubresourceRange *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageSubresourceRange *>(m_allocator.Alloc(sizeof(VkImageSubresourceRange) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].aspectMask = src[start_index + i].aspectMask;
      ptr[i].baseMipLevel = src[start_index + i].baseMipLevel;
      ptr[i].levelCount = src[start_index + i].levelCount;
      ptr[i].baseArrayLayer = src[start_index + i].baseArrayLayer;
      ptr[i].layerCount = src[start_index + i].layerCount;
  }
  return ptr;
}

template<>
VkMemoryBarrier *CommandRecorder::CopyArray<VkMemoryBarrier>(const VkMemoryBarrier *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMemoryBarrier *>(m_allocator.Alloc(sizeof(VkMemoryBarrier) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
      ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
  }
  return ptr;
}

template<>
VkBufferMemoryBarrier *CommandRecorder::CopyArray<VkBufferMemoryBarrier>(const VkBufferMemoryBarrier *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBufferMemoryBarrier *>(m_allocator.Alloc(sizeof(VkBufferMemoryBarrier) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
      ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
      ptr[i].srcQueueFamilyIndex = src[start_index + i].srcQueueFamilyIndex;
      ptr[i].dstQueueFamilyIndex = src[start_index + i].dstQueueFamilyIndex;
      ptr[i].buffer = src[start_index + i].buffer;
      ptr[i].offset = src[start_index + i].offset;
      ptr[i].size = src[start_index + i].size;
  }
  return ptr;
}

template<>
VkImageMemoryBarrier *CommandRecorder::CopyArray<VkImageMemoryBarrier>(const VkImageMemoryBarrier *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageMemoryBarrier *>(m_allocator.Alloc(sizeof(VkImageMemoryBarrier) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
      ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
      ptr[i].oldLayout = src[start_index + i].oldLayout;
      ptr[i].newLayout = src[start_index + i].newLayout;
      ptr[i].srcQueueFamilyIndex = src[start_index + i].srcQueueFamilyIndex;
      ptr[i].dstQueueFamilyIndex = src[start_index + i].dstQueueFamilyIndex;
      ptr[i].image = src[start_index + i].image;
      ptr[i].subresourceRange = src[start_index + i].subresourceRange;
  }
  return ptr;
}

template<>
VkImageCreateInfo *CommandRecorder::CopyArray<VkImageCreateInfo>(const VkImageCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageCreateInfo *>(m_allocator.Alloc(sizeof(VkImageCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].imageType = src[start_index + i].imageType;
      ptr[i].format = src[start_index + i].format;
      ptr[i].extent = src[start_index + i].extent;
      ptr[i].mipLevels = src[start_index + i].mipLevels;
      ptr[i].arrayLayers = src[start_index + i].arrayLayers;
      ptr[i].samples = src[start_index + i].samples;
      ptr[i].tiling = src[start_index + i].tiling;
      ptr[i].usage = src[start_index + i].usage;
      ptr[i].sharingMode = src[start_index + i].sharingMode;
      ptr[i].queueFamilyIndexCount = src[start_index + i].queueFamilyIndexCount;
      ptr[i].pQueueFamilyIndices = nullptr;
      if (src[start_index + i].pQueueFamilyIndices) {
        ptr[i].pQueueFamilyIndices = CopyArray<>(src[start_index + i].pQueueFamilyIndices, 0, 1);
      }
      ptr[i].initialLayout = src[start_index + i].initialLayout;
  }
  return ptr;
}

template<>
VkSubresourceLayout *CommandRecorder::CopyArray<VkSubresourceLayout>(const VkSubresourceLayout *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSubresourceLayout *>(m_allocator.Alloc(sizeof(VkSubresourceLayout) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].offset = src[start_index + i].offset;
      ptr[i].size = src[start_index + i].size;
      ptr[i].rowPitch = src[start_index + i].rowPitch;
      ptr[i].arrayPitch = src[start_index + i].arrayPitch;
      ptr[i].depthPitch = src[start_index + i].depthPitch;
  }
  return ptr;
}

template<>
VkImageViewCreateInfo *CommandRecorder::CopyArray<VkImageViewCreateInfo>(const VkImageViewCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageViewCreateInfo *>(m_allocator.Alloc(sizeof(VkImageViewCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].image = src[start_index + i].image;
      ptr[i].viewType = src[start_index + i].viewType;
      ptr[i].format = src[start_index + i].format;
      ptr[i].components = src[start_index + i].components;
      ptr[i].subresourceRange = src[start_index + i].subresourceRange;
  }
  return ptr;
}

template<>
VkBufferCopy *CommandRecorder::CopyArray<VkBufferCopy>(const VkBufferCopy *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBufferCopy *>(m_allocator.Alloc(sizeof(VkBufferCopy) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].srcOffset = src[start_index + i].srcOffset;
      ptr[i].dstOffset = src[start_index + i].dstOffset;
      ptr[i].size = src[start_index + i].size;
  }
  return ptr;
}

template<>
VkSparseMemoryBind *CommandRecorder::CopyArray<VkSparseMemoryBind>(const VkSparseMemoryBind *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSparseMemoryBind *>(m_allocator.Alloc(sizeof(VkSparseMemoryBind) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].resourceOffset = src[start_index + i].resourceOffset;
      ptr[i].size = src[start_index + i].size;
      ptr[i].memory = src[start_index + i].memory;
      ptr[i].memoryOffset = src[start_index + i].memoryOffset;
      ptr[i].flags = src[start_index + i].flags;
  }
  return ptr;
}

template<>
VkSparseImageMemoryBind *CommandRecorder::CopyArray<VkSparseImageMemoryBind>(const VkSparseImageMemoryBind *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSparseImageMemoryBind *>(m_allocator.Alloc(sizeof(VkSparseImageMemoryBind) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].subresource = src[start_index + i].subresource;
      ptr[i].offset = src[start_index + i].offset;
      ptr[i].extent = src[start_index + i].extent;
      ptr[i].memory = src[start_index + i].memory;
      ptr[i].memoryOffset = src[start_index + i].memoryOffset;
      ptr[i].flags = src[start_index + i].flags;
  }
  return ptr;
}

template<>
VkSparseBufferMemoryBindInfo *CommandRecorder::CopyArray<VkSparseBufferMemoryBindInfo>(const VkSparseBufferMemoryBindInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSparseBufferMemoryBindInfo *>(m_allocator.Alloc(sizeof(VkSparseBufferMemoryBindInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].buffer = src[start_index + i].buffer;
      ptr[i].bindCount = src[start_index + i].bindCount;
      ptr[i].pBinds = nullptr;
      if (src[start_index + i].pBinds) {
        ptr[i].pBinds = CopyArray<>(src[start_index + i].pBinds, 0, 1);
      }
  }
  return ptr;
}

template<>
VkSparseImageOpaqueMemoryBindInfo *CommandRecorder::CopyArray<VkSparseImageOpaqueMemoryBindInfo>(const VkSparseImageOpaqueMemoryBindInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSparseImageOpaqueMemoryBindInfo *>(m_allocator.Alloc(sizeof(VkSparseImageOpaqueMemoryBindInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].image = src[start_index + i].image;
      ptr[i].bindCount = src[start_index + i].bindCount;
      ptr[i].pBinds = nullptr;
      if (src[start_index + i].pBinds) {
        ptr[i].pBinds = CopyArray<>(src[start_index + i].pBinds, 0, 1);
      }
  }
  return ptr;
}

template<>
VkSparseImageMemoryBindInfo *CommandRecorder::CopyArray<VkSparseImageMemoryBindInfo>(const VkSparseImageMemoryBindInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSparseImageMemoryBindInfo *>(m_allocator.Alloc(sizeof(VkSparseImageMemoryBindInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].image = src[start_index + i].image;
      ptr[i].bindCount = src[start_index + i].bindCount;
      ptr[i].pBinds = nullptr;
      if (src[start_index + i].pBinds) {
        ptr[i].pBinds = CopyArray<>(src[start_index + i].pBinds, 0, 1);
      }
  }
  return ptr;
}

template<>
VkBindSparseInfo *CommandRecorder::CopyArray<VkBindSparseInfo>(const VkBindSparseInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBindSparseInfo *>(m_allocator.Alloc(sizeof(VkBindSparseInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].waitSemaphoreCount = src[start_index + i].waitSemaphoreCount;
      ptr[i].pWaitSemaphores = nullptr;
      if (src[start_index + i].pWaitSemaphores) {
        ptr[i].pWaitSemaphores = CopyArray<>(src[start_index + i].pWaitSemaphores, 0, 1);
      }
      ptr[i].bufferBindCount = src[start_index + i].bufferBindCount;
      ptr[i].pBufferBinds = nullptr;
      if (src[start_index + i].pBufferBinds) {
        ptr[i].pBufferBinds = CopyArray<>(src[start_index + i].pBufferBinds, 0, 1);
      }
      ptr[i].imageOpaqueBindCount = src[start_index + i].imageOpaqueBindCount;
      ptr[i].pImageOpaqueBinds = nullptr;
      if (src[start_index + i].pImageOpaqueBinds) {
        ptr[i].pImageOpaqueBinds = CopyArray<>(src[start_index + i].pImageOpaqueBinds, 0, 1);
      }
      ptr[i].imageBindCount = src[start_index + i].imageBindCount;
      ptr[i].pImageBinds = nullptr;
      if (src[start_index + i].pImageBinds) {
        ptr[i].pImageBinds = CopyArray<>(src[start_index + i].pImageBinds, 0, 1);
      }
      ptr[i].signalSemaphoreCount = src[start_index + i].signalSemaphoreCount;
      ptr[i].pSignalSemaphores = nullptr;
      if (src[start_index + i].pSignalSemaphores) {
        ptr[i].pSignalSemaphores = CopyArray<>(src[start_index + i].pSignalSemaphores, 0, 1);
      }
  }
  return ptr;
}

template<>
VkImageCopy *CommandRecorder::CopyArray<VkImageCopy>(const VkImageCopy *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageCopy *>(m_allocator.Alloc(sizeof(VkImageCopy) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].srcSubresource = src[start_index + i].srcSubresource;
      ptr[i].srcOffset = src[start_index + i].srcOffset;
      ptr[i].dstSubresource = src[start_index + i].dstSubresource;
      ptr[i].dstOffset = src[start_index + i].dstOffset;
      ptr[i].extent = src[start_index + i].extent;
  }
  return ptr;
}

template<>
VkImageBlit *CommandRecorder::CopyArray<VkImageBlit>(const VkImageBlit *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageBlit *>(m_allocator.Alloc(sizeof(VkImageBlit) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].srcSubresource = src[start_index + i].srcSubresource;
      std::memcpy(ptr[i].srcOffsets, src[start_index + i].srcOffsets, sizeof(src[start_index + i].srcOffsets));
      ptr[i].dstSubresource = src[start_index + i].dstSubresource;
      std::memcpy(ptr[i].dstOffsets, src[start_index + i].dstOffsets, sizeof(src[start_index + i].dstOffsets));
  }
  return ptr;
}

template<>
VkBufferImageCopy *CommandRecorder::CopyArray<VkBufferImageCopy>(const VkBufferImageCopy *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBufferImageCopy *>(m_allocator.Alloc(sizeof(VkBufferImageCopy) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].bufferOffset = src[start_index + i].bufferOffset;
      ptr[i].bufferRowLength = src[start_index + i].bufferRowLength;
      ptr[i].bufferImageHeight = src[start_index + i].bufferImageHeight;
      ptr[i].imageSubresource = src[start_index + i].imageSubresource;
      ptr[i].imageOffset = src[start_index + i].imageOffset;
      ptr[i].imageExtent = src[start_index + i].imageExtent;
  }
  return ptr;
}

template<>
VkImageResolve *CommandRecorder::CopyArray<VkImageResolve>(const VkImageResolve *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageResolve *>(m_allocator.Alloc(sizeof(VkImageResolve) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].srcSubresource = src[start_index + i].srcSubresource;
      ptr[i].srcOffset = src[start_index + i].srcOffset;
      ptr[i].dstSubresource = src[start_index + i].dstSubresource;
      ptr[i].dstOffset = src[start_index + i].dstOffset;
      ptr[i].extent = src[start_index + i].extent;
  }
  return ptr;
}

template<>
VkShaderModuleCreateInfo *CommandRecorder::CopyArray<VkShaderModuleCreateInfo>(const VkShaderModuleCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkShaderModuleCreateInfo *>(m_allocator.Alloc(sizeof(VkShaderModuleCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].codeSize = src[start_index + i].codeSize;
      ptr[i].pCode = nullptr;
      if (src[start_index + i].pCode) {
        ptr[i].pCode = CopyArray<>(src[start_index + i].pCode, 0, 1);
      }
  }
  return ptr;
}

template<>
VkDescriptorSetLayoutBinding *CommandRecorder::CopyArray<VkDescriptorSetLayoutBinding>(const VkDescriptorSetLayoutBinding *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDescriptorSetLayoutBinding *>(m_allocator.Alloc(sizeof(VkDescriptorSetLayoutBinding) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].binding = src[start_index + i].binding;
      ptr[i].descriptorType = src[start_index + i].descriptorType;
      ptr[i].descriptorCount = src[start_index + i].descriptorCount;
      ptr[i].stageFlags = src[start_index + i].stageFlags;
      ptr[i].pImmutableSamplers = nullptr;
      if (src[start_index + i].pImmutableSamplers) {
        ptr[i].pImmutableSamplers = CopyArray<>(src[start_index + i].pImmutableSamplers, 0, 1);
      }
  }
  return ptr;
}

template<>
VkDescriptorSetLayoutCreateInfo *CommandRecorder::CopyArray<VkDescriptorSetLayoutCreateInfo>(const VkDescriptorSetLayoutCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDescriptorSetLayoutCreateInfo *>(m_allocator.Alloc(sizeof(VkDescriptorSetLayoutCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].bindingCount = src[start_index + i].bindingCount;
      ptr[i].pBindings = nullptr;
      if (src[start_index + i].pBindings) {
        ptr[i].pBindings = CopyArray<>(src[start_index + i].pBindings, 0, 1);
      }
  }
  return ptr;
}

template<>
VkDescriptorPoolSize *CommandRecorder::CopyArray<VkDescriptorPoolSize>(const VkDescriptorPoolSize *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDescriptorPoolSize *>(m_allocator.Alloc(sizeof(VkDescriptorPoolSize) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].type = src[start_index + i].type;
      ptr[i].descriptorCount = src[start_index + i].descriptorCount;
  }
  return ptr;
}

template<>
VkDescriptorPoolCreateInfo *CommandRecorder::CopyArray<VkDescriptorPoolCreateInfo>(const VkDescriptorPoolCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDescriptorPoolCreateInfo *>(m_allocator.Alloc(sizeof(VkDescriptorPoolCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].maxSets = src[start_index + i].maxSets;
      ptr[i].poolSizeCount = src[start_index + i].poolSizeCount;
      ptr[i].pPoolSizes = nullptr;
      if (src[start_index + i].pPoolSizes) {
        ptr[i].pPoolSizes = CopyArray<>(src[start_index + i].pPoolSizes, 0, 1);
      }
  }
  return ptr;
}

template<>
VkDescriptorSetAllocateInfo *CommandRecorder::CopyArray<VkDescriptorSetAllocateInfo>(const VkDescriptorSetAllocateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDescriptorSetAllocateInfo *>(m_allocator.Alloc(sizeof(VkDescriptorSetAllocateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].descriptorPool = src[start_index + i].descriptorPool;
      ptr[i].descriptorSetCount = src[start_index + i].descriptorSetCount;
      ptr[i].pSetLayouts = nullptr;
      if (src[start_index + i].pSetLayouts) {
        ptr[i].pSetLayouts = CopyArray<>(src[start_index + i].pSetLayouts, 0, 1);
      }
  }
  return ptr;
}

template<>
VkSpecializationMapEntry *CommandRecorder::CopyArray<VkSpecializationMapEntry>(const VkSpecializationMapEntry *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSpecializationMapEntry *>(m_allocator.Alloc(sizeof(VkSpecializationMapEntry) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].constantID = src[start_index + i].constantID;
      ptr[i].offset = src[start_index + i].offset;
      ptr[i].size = src[start_index + i].size;
  }
  return ptr;
}

template<>
VkSpecializationInfo *CommandRecorder::CopyArray<VkSpecializationInfo>(const VkSpecializationInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSpecializationInfo *>(m_allocator.Alloc(sizeof(VkSpecializationInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].mapEntryCount = src[start_index + i].mapEntryCount;
      ptr[i].pMapEntries = nullptr;
      if (src[start_index + i].pMapEntries) {
        ptr[i].pMapEntries = CopyArray<>(src[start_index + i].pMapEntries, 0, 1);
      }
      ptr[i].dataSize = src[start_index + i].dataSize;
      ptr[i].pData = src[start_index + i].pData;
  }
  return ptr;
}

template<>
VkPipelineShaderStageCreateInfo *CommandRecorder::CopyArray<VkPipelineShaderStageCreateInfo>(const VkPipelineShaderStageCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineShaderStageCreateInfo *>(m_allocator.Alloc(sizeof(VkPipelineShaderStageCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].stage = src[start_index + i].stage;
      ptr[i].module = src[start_index + i].module;
      ptr[i].pName = nullptr;
    if (src[start_index + i].pName) {
      ptr[i].pName = CopyArray<>(src[start_index + i].pName, 0, strlen(src[start_index + i].pName));
    }
      ptr[i].pSpecializationInfo = nullptr;
      if (src[start_index + i].pSpecializationInfo) {
        ptr[i].pSpecializationInfo = CopyArray<>(src[start_index + i].pSpecializationInfo, 0, 1);
      }
  }
  return ptr;
}

template<>
VkComputePipelineCreateInfo *CommandRecorder::CopyArray<VkComputePipelineCreateInfo>(const VkComputePipelineCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkComputePipelineCreateInfo *>(m_allocator.Alloc(sizeof(VkComputePipelineCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].stage = src[start_index + i].stage;
      ptr[i].layout = src[start_index + i].layout;
      ptr[i].basePipelineHandle = src[start_index + i].basePipelineHandle;
      ptr[i].basePipelineIndex = src[start_index + i].basePipelineIndex;
  }
  return ptr;
}

template<>
VkVertexInputBindingDescription *CommandRecorder::CopyArray<VkVertexInputBindingDescription>(const VkVertexInputBindingDescription *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkVertexInputBindingDescription *>(m_allocator.Alloc(sizeof(VkVertexInputBindingDescription) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].binding = src[start_index + i].binding;
      ptr[i].stride = src[start_index + i].stride;
      ptr[i].inputRate = src[start_index + i].inputRate;
  }
  return ptr;
}

template<>
VkVertexInputAttributeDescription *CommandRecorder::CopyArray<VkVertexInputAttributeDescription>(const VkVertexInputAttributeDescription *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkVertexInputAttributeDescription *>(m_allocator.Alloc(sizeof(VkVertexInputAttributeDescription) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].location = src[start_index + i].location;
      ptr[i].binding = src[start_index + i].binding;
      ptr[i].format = src[start_index + i].format;
      ptr[i].offset = src[start_index + i].offset;
  }
  return ptr;
}

template<>
VkPipelineVertexInputStateCreateInfo *CommandRecorder::CopyArray<VkPipelineVertexInputStateCreateInfo>(const VkPipelineVertexInputStateCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineVertexInputStateCreateInfo *>(m_allocator.Alloc(sizeof(VkPipelineVertexInputStateCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].vertexBindingDescriptionCount = src[start_index + i].vertexBindingDescriptionCount;
      ptr[i].pVertexBindingDescriptions = nullptr;
      if (src[start_index + i].pVertexBindingDescriptions) {
        ptr[i].pVertexBindingDescriptions = CopyArray<>(src[start_index + i].pVertexBindingDescriptions, 0, 1);
      }
      ptr[i].vertexAttributeDescriptionCount = src[start_index + i].vertexAttributeDescriptionCount;
      ptr[i].pVertexAttributeDescriptions = nullptr;
      if (src[start_index + i].pVertexAttributeDescriptions) {
        ptr[i].pVertexAttributeDescriptions = CopyArray<>(src[start_index + i].pVertexAttributeDescriptions, 0, 1);
      }
  }
  return ptr;
}

template<>
VkPipelineInputAssemblyStateCreateInfo *CommandRecorder::CopyArray<VkPipelineInputAssemblyStateCreateInfo>(const VkPipelineInputAssemblyStateCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineInputAssemblyStateCreateInfo *>(m_allocator.Alloc(sizeof(VkPipelineInputAssemblyStateCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].topology = src[start_index + i].topology;
      ptr[i].primitiveRestartEnable = src[start_index + i].primitiveRestartEnable;
  }
  return ptr;
}

template<>
VkPipelineTessellationStateCreateInfo *CommandRecorder::CopyArray<VkPipelineTessellationStateCreateInfo>(const VkPipelineTessellationStateCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineTessellationStateCreateInfo *>(m_allocator.Alloc(sizeof(VkPipelineTessellationStateCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].patchControlPoints = src[start_index + i].patchControlPoints;
  }
  return ptr;
}

template<>
VkPipelineViewportStateCreateInfo *CommandRecorder::CopyArray<VkPipelineViewportStateCreateInfo>(const VkPipelineViewportStateCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineViewportStateCreateInfo *>(m_allocator.Alloc(sizeof(VkPipelineViewportStateCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].viewportCount = src[start_index + i].viewportCount;
      ptr[i].pViewports = nullptr;
      if (src[start_index + i].pViewports) {
        ptr[i].pViewports = CopyArray<>(src[start_index + i].pViewports, 0, 1);
      }
      ptr[i].scissorCount = src[start_index + i].scissorCount;
      ptr[i].pScissors = nullptr;
      if (src[start_index + i].pScissors) {
        ptr[i].pScissors = CopyArray<>(src[start_index + i].pScissors, 0, 1);
      }
  }
  return ptr;
}

template<>
VkPipelineRasterizationStateCreateInfo *CommandRecorder::CopyArray<VkPipelineRasterizationStateCreateInfo>(const VkPipelineRasterizationStateCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineRasterizationStateCreateInfo *>(m_allocator.Alloc(sizeof(VkPipelineRasterizationStateCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].depthClampEnable = src[start_index + i].depthClampEnable;
      ptr[i].rasterizerDiscardEnable = src[start_index + i].rasterizerDiscardEnable;
      ptr[i].polygonMode = src[start_index + i].polygonMode;
      ptr[i].cullMode = src[start_index + i].cullMode;
      ptr[i].frontFace = src[start_index + i].frontFace;
      ptr[i].depthBiasEnable = src[start_index + i].depthBiasEnable;
      ptr[i].depthBiasConstantFactor = src[start_index + i].depthBiasConstantFactor;
      ptr[i].depthBiasClamp = src[start_index + i].depthBiasClamp;
      ptr[i].depthBiasSlopeFactor = src[start_index + i].depthBiasSlopeFactor;
      ptr[i].lineWidth = src[start_index + i].lineWidth;
  }
  return ptr;
}

template<>
VkPipelineMultisampleStateCreateInfo *CommandRecorder::CopyArray<VkPipelineMultisampleStateCreateInfo>(const VkPipelineMultisampleStateCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineMultisampleStateCreateInfo *>(m_allocator.Alloc(sizeof(VkPipelineMultisampleStateCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].rasterizationSamples = src[start_index + i].rasterizationSamples;
      ptr[i].sampleShadingEnable = src[start_index + i].sampleShadingEnable;
      ptr[i].minSampleShading = src[start_index + i].minSampleShading;
      ptr[i].pSampleMask = nullptr;
      if (src[start_index + i].pSampleMask) {
        ptr[i].pSampleMask = CopyArray<>(src[start_index + i].pSampleMask, 0, 1);
      }
      ptr[i].alphaToCoverageEnable = src[start_index + i].alphaToCoverageEnable;
      ptr[i].alphaToOneEnable = src[start_index + i].alphaToOneEnable;
  }
  return ptr;
}

template<>
VkPipelineColorBlendAttachmentState *CommandRecorder::CopyArray<VkPipelineColorBlendAttachmentState>(const VkPipelineColorBlendAttachmentState *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineColorBlendAttachmentState *>(m_allocator.Alloc(sizeof(VkPipelineColorBlendAttachmentState) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].blendEnable = src[start_index + i].blendEnable;
      ptr[i].srcColorBlendFactor = src[start_index + i].srcColorBlendFactor;
      ptr[i].dstColorBlendFactor = src[start_index + i].dstColorBlendFactor;
      ptr[i].colorBlendOp = src[start_index + i].colorBlendOp;
      ptr[i].srcAlphaBlendFactor = src[start_index + i].srcAlphaBlendFactor;
      ptr[i].dstAlphaBlendFactor = src[start_index + i].dstAlphaBlendFactor;
      ptr[i].alphaBlendOp = src[start_index + i].alphaBlendOp;
      ptr[i].colorWriteMask = src[start_index + i].colorWriteMask;
  }
  return ptr;
}

template<>
VkPipelineColorBlendStateCreateInfo *CommandRecorder::CopyArray<VkPipelineColorBlendStateCreateInfo>(const VkPipelineColorBlendStateCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineColorBlendStateCreateInfo *>(m_allocator.Alloc(sizeof(VkPipelineColorBlendStateCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].logicOpEnable = src[start_index + i].logicOpEnable;
      ptr[i].logicOp = src[start_index + i].logicOp;
      ptr[i].attachmentCount = src[start_index + i].attachmentCount;
      ptr[i].pAttachments = nullptr;
      if (src[start_index + i].pAttachments) {
        ptr[i].pAttachments = CopyArray<>(src[start_index + i].pAttachments, 0, 1);
      }
      std::memcpy(ptr[i].blendConstants, src[start_index + i].blendConstants, sizeof(src[start_index + i].blendConstants));
  }
  return ptr;
}

template<>
VkPipelineDynamicStateCreateInfo *CommandRecorder::CopyArray<VkPipelineDynamicStateCreateInfo>(const VkPipelineDynamicStateCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineDynamicStateCreateInfo *>(m_allocator.Alloc(sizeof(VkPipelineDynamicStateCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].dynamicStateCount = src[start_index + i].dynamicStateCount;
      ptr[i].pDynamicStates = nullptr;
      if (src[start_index + i].pDynamicStates) {
        ptr[i].pDynamicStates = CopyArray<>(src[start_index + i].pDynamicStates, 0, 1);
      }
  }
  return ptr;
}

template<>
VkStencilOpState *CommandRecorder::CopyArray<VkStencilOpState>(const VkStencilOpState *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkStencilOpState *>(m_allocator.Alloc(sizeof(VkStencilOpState) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].failOp = src[start_index + i].failOp;
      ptr[i].passOp = src[start_index + i].passOp;
      ptr[i].depthFailOp = src[start_index + i].depthFailOp;
      ptr[i].compareOp = src[start_index + i].compareOp;
      ptr[i].compareMask = src[start_index + i].compareMask;
      ptr[i].writeMask = src[start_index + i].writeMask;
      ptr[i].reference = src[start_index + i].reference;
  }
  return ptr;
}

template<>
VkPipelineDepthStencilStateCreateInfo *CommandRecorder::CopyArray<VkPipelineDepthStencilStateCreateInfo>(const VkPipelineDepthStencilStateCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineDepthStencilStateCreateInfo *>(m_allocator.Alloc(sizeof(VkPipelineDepthStencilStateCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].depthTestEnable = src[start_index + i].depthTestEnable;
      ptr[i].depthWriteEnable = src[start_index + i].depthWriteEnable;
      ptr[i].depthCompareOp = src[start_index + i].depthCompareOp;
      ptr[i].depthBoundsTestEnable = src[start_index + i].depthBoundsTestEnable;
      ptr[i].stencilTestEnable = src[start_index + i].stencilTestEnable;
      ptr[i].front = src[start_index + i].front;
      ptr[i].back = src[start_index + i].back;
      ptr[i].minDepthBounds = src[start_index + i].minDepthBounds;
      ptr[i].maxDepthBounds = src[start_index + i].maxDepthBounds;
  }
  return ptr;
}

template<>
VkGraphicsPipelineCreateInfo *CommandRecorder::CopyArray<VkGraphicsPipelineCreateInfo>(const VkGraphicsPipelineCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkGraphicsPipelineCreateInfo *>(m_allocator.Alloc(sizeof(VkGraphicsPipelineCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].stageCount = src[start_index + i].stageCount;
      ptr[i].pStages = nullptr;
      if (src[start_index + i].pStages) {
        ptr[i].pStages = CopyArray<>(src[start_index + i].pStages, 0, 1);
      }
      ptr[i].pVertexInputState = nullptr;
      if (src[start_index + i].pVertexInputState) {
        ptr[i].pVertexInputState = CopyArray<>(src[start_index + i].pVertexInputState, 0, 1);
      }
      ptr[i].pInputAssemblyState = nullptr;
      if (src[start_index + i].pInputAssemblyState) {
        ptr[i].pInputAssemblyState = CopyArray<>(src[start_index + i].pInputAssemblyState, 0, 1);
      }
      ptr[i].pTessellationState = nullptr;
      if (src[start_index + i].pTessellationState) {
        ptr[i].pTessellationState = CopyArray<>(src[start_index + i].pTessellationState, 0, 1);
      }
      ptr[i].pViewportState = nullptr;
      if (src[start_index + i].pViewportState) {
        ptr[i].pViewportState = CopyArray<>(src[start_index + i].pViewportState, 0, 1);
      }
      ptr[i].pRasterizationState = nullptr;
      if (src[start_index + i].pRasterizationState) {
        ptr[i].pRasterizationState = CopyArray<>(src[start_index + i].pRasterizationState, 0, 1);
      }
      ptr[i].pMultisampleState = nullptr;
      if (src[start_index + i].pMultisampleState) {
        ptr[i].pMultisampleState = CopyArray<>(src[start_index + i].pMultisampleState, 0, 1);
      }
      ptr[i].pDepthStencilState = nullptr;
      if (src[start_index + i].pDepthStencilState) {
        ptr[i].pDepthStencilState = CopyArray<>(src[start_index + i].pDepthStencilState, 0, 1);
      }
      ptr[i].pColorBlendState = nullptr;
      if (src[start_index + i].pColorBlendState) {
        ptr[i].pColorBlendState = CopyArray<>(src[start_index + i].pColorBlendState, 0, 1);
      }
      ptr[i].pDynamicState = nullptr;
      if (src[start_index + i].pDynamicState) {
        ptr[i].pDynamicState = CopyArray<>(src[start_index + i].pDynamicState, 0, 1);
      }
      ptr[i].layout = src[start_index + i].layout;
      ptr[i].renderPass = src[start_index + i].renderPass;
      ptr[i].subpass = src[start_index + i].subpass;
      ptr[i].basePipelineHandle = src[start_index + i].basePipelineHandle;
      ptr[i].basePipelineIndex = src[start_index + i].basePipelineIndex;
  }
  return ptr;
}

template<>
VkPipelineCacheCreateInfo *CommandRecorder::CopyArray<VkPipelineCacheCreateInfo>(const VkPipelineCacheCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineCacheCreateInfo *>(m_allocator.Alloc(sizeof(VkPipelineCacheCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].initialDataSize = src[start_index + i].initialDataSize;
      ptr[i].pInitialData = src[start_index + i].pInitialData;
  }
  return ptr;
}

template<>
VkPushConstantRange *CommandRecorder::CopyArray<VkPushConstantRange>(const VkPushConstantRange *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPushConstantRange *>(m_allocator.Alloc(sizeof(VkPushConstantRange) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].stageFlags = src[start_index + i].stageFlags;
      ptr[i].offset = src[start_index + i].offset;
      ptr[i].size = src[start_index + i].size;
  }
  return ptr;
}

template<>
VkPipelineLayoutCreateInfo *CommandRecorder::CopyArray<VkPipelineLayoutCreateInfo>(const VkPipelineLayoutCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineLayoutCreateInfo *>(m_allocator.Alloc(sizeof(VkPipelineLayoutCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].setLayoutCount = src[start_index + i].setLayoutCount;
      ptr[i].pSetLayouts = nullptr;
      if (src[start_index + i].pSetLayouts) {
        ptr[i].pSetLayouts = CopyArray<>(src[start_index + i].pSetLayouts, 0, 1);
      }
      ptr[i].pushConstantRangeCount = src[start_index + i].pushConstantRangeCount;
      ptr[i].pPushConstantRanges = nullptr;
      if (src[start_index + i].pPushConstantRanges) {
        ptr[i].pPushConstantRanges = CopyArray<>(src[start_index + i].pPushConstantRanges, 0, 1);
      }
  }
  return ptr;
}

template<>
VkSamplerCreateInfo *CommandRecorder::CopyArray<VkSamplerCreateInfo>(const VkSamplerCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSamplerCreateInfo *>(m_allocator.Alloc(sizeof(VkSamplerCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].magFilter = src[start_index + i].magFilter;
      ptr[i].minFilter = src[start_index + i].minFilter;
      ptr[i].mipmapMode = src[start_index + i].mipmapMode;
      ptr[i].addressModeU = src[start_index + i].addressModeU;
      ptr[i].addressModeV = src[start_index + i].addressModeV;
      ptr[i].addressModeW = src[start_index + i].addressModeW;
      ptr[i].mipLodBias = src[start_index + i].mipLodBias;
      ptr[i].anisotropyEnable = src[start_index + i].anisotropyEnable;
      ptr[i].maxAnisotropy = src[start_index + i].maxAnisotropy;
      ptr[i].compareEnable = src[start_index + i].compareEnable;
      ptr[i].compareOp = src[start_index + i].compareOp;
      ptr[i].minLod = src[start_index + i].minLod;
      ptr[i].maxLod = src[start_index + i].maxLod;
      ptr[i].borderColor = src[start_index + i].borderColor;
      ptr[i].unnormalizedCoordinates = src[start_index + i].unnormalizedCoordinates;
  }
  return ptr;
}

template<>
VkCommandPoolCreateInfo *CommandRecorder::CopyArray<VkCommandPoolCreateInfo>(const VkCommandPoolCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkCommandPoolCreateInfo *>(m_allocator.Alloc(sizeof(VkCommandPoolCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].queueFamilyIndex = src[start_index + i].queueFamilyIndex;
  }
  return ptr;
}

template<>
VkCommandBufferAllocateInfo *CommandRecorder::CopyArray<VkCommandBufferAllocateInfo>(const VkCommandBufferAllocateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkCommandBufferAllocateInfo *>(m_allocator.Alloc(sizeof(VkCommandBufferAllocateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].commandPool = src[start_index + i].commandPool;
      ptr[i].level = src[start_index + i].level;
      ptr[i].commandBufferCount = src[start_index + i].commandBufferCount;
  }
  return ptr;
}

template<>
VkCommandBufferInheritanceInfo *CommandRecorder::CopyArray<VkCommandBufferInheritanceInfo>(const VkCommandBufferInheritanceInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkCommandBufferInheritanceInfo *>(m_allocator.Alloc(sizeof(VkCommandBufferInheritanceInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].renderPass = src[start_index + i].renderPass;
      ptr[i].subpass = src[start_index + i].subpass;
      ptr[i].framebuffer = src[start_index + i].framebuffer;
      ptr[i].occlusionQueryEnable = src[start_index + i].occlusionQueryEnable;
      ptr[i].queryFlags = src[start_index + i].queryFlags;
      ptr[i].pipelineStatistics = src[start_index + i].pipelineStatistics;
  }
  return ptr;
}

template<>
VkCommandBufferBeginInfo *CommandRecorder::CopyArray<VkCommandBufferBeginInfo>(const VkCommandBufferBeginInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkCommandBufferBeginInfo *>(m_allocator.Alloc(sizeof(VkCommandBufferBeginInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].pInheritanceInfo = nullptr;
      if (src[start_index + i].pInheritanceInfo) {
        ptr[i].pInheritanceInfo = CopyArray<>(src[start_index + i].pInheritanceInfo, 0, 1);
      }
  }
  return ptr;
}

template<>
VkRenderPassBeginInfo *CommandRecorder::CopyArray<VkRenderPassBeginInfo>(const VkRenderPassBeginInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkRenderPassBeginInfo *>(m_allocator.Alloc(sizeof(VkRenderPassBeginInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].renderPass = src[start_index + i].renderPass;
      ptr[i].framebuffer = src[start_index + i].framebuffer;
      ptr[i].renderArea = src[start_index + i].renderArea;
      ptr[i].clearValueCount = src[start_index + i].clearValueCount;
      ptr[i].pClearValues = nullptr;
      if (src[start_index + i].pClearValues) {
        ptr[i].pClearValues = CopyArray<>(src[start_index + i].pClearValues, 0, 1);
      }
  }
  return ptr;
}

template<>
VkClearColorValue *CommandRecorder::CopyArray<VkClearColorValue>(const VkClearColorValue *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkClearColorValue *>(m_allocator.Alloc(sizeof(VkClearColorValue) * count));
  for (uint64_t i = 0; i < count; ++i) {std::memcpy(ptr[i].float32, src[start_index + i].float32, sizeof(src[start_index + i].float32));
  }
  return ptr;
}

template<>
VkClearDepthStencilValue *CommandRecorder::CopyArray<VkClearDepthStencilValue>(const VkClearDepthStencilValue *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkClearDepthStencilValue *>(m_allocator.Alloc(sizeof(VkClearDepthStencilValue) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].depth = src[start_index + i].depth;
      ptr[i].stencil = src[start_index + i].stencil;
  }
  return ptr;
}

template<>
VkClearValue *CommandRecorder::CopyArray<VkClearValue>(const VkClearValue *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkClearValue *>(m_allocator.Alloc(sizeof(VkClearValue) * count));
  for (uint64_t i = 0; i < count; ++i) {ptr[i].color = src[start_index + i].color;
  }
  return ptr;
}

template<>
VkClearAttachment *CommandRecorder::CopyArray<VkClearAttachment>(const VkClearAttachment *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkClearAttachment *>(m_allocator.Alloc(sizeof(VkClearAttachment) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].aspectMask = src[start_index + i].aspectMask;
      ptr[i].colorAttachment = src[start_index + i].colorAttachment;
      ptr[i].clearValue = src[start_index + i].clearValue;
  }
  return ptr;
}

template<>
VkAttachmentDescription *CommandRecorder::CopyArray<VkAttachmentDescription>(const VkAttachmentDescription *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAttachmentDescription *>(m_allocator.Alloc(sizeof(VkAttachmentDescription) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].format = src[start_index + i].format;
      ptr[i].samples = src[start_index + i].samples;
      ptr[i].loadOp = src[start_index + i].loadOp;
      ptr[i].storeOp = src[start_index + i].storeOp;
      ptr[i].stencilLoadOp = src[start_index + i].stencilLoadOp;
      ptr[i].stencilStoreOp = src[start_index + i].stencilStoreOp;
      ptr[i].initialLayout = src[start_index + i].initialLayout;
      ptr[i].finalLayout = src[start_index + i].finalLayout;
  }
  return ptr;
}

template<>
VkAttachmentReference *CommandRecorder::CopyArray<VkAttachmentReference>(const VkAttachmentReference *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAttachmentReference *>(m_allocator.Alloc(sizeof(VkAttachmentReference) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].attachment = src[start_index + i].attachment;
      ptr[i].layout = src[start_index + i].layout;
  }
  return ptr;
}

template<>
VkSubpassDescription *CommandRecorder::CopyArray<VkSubpassDescription>(const VkSubpassDescription *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSubpassDescription *>(m_allocator.Alloc(sizeof(VkSubpassDescription) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].pipelineBindPoint = src[start_index + i].pipelineBindPoint;
      ptr[i].inputAttachmentCount = src[start_index + i].inputAttachmentCount;
      ptr[i].pInputAttachments = nullptr;
      if (src[start_index + i].pInputAttachments) {
        ptr[i].pInputAttachments = CopyArray<>(src[start_index + i].pInputAttachments, 0, 1);
      }
      ptr[i].colorAttachmentCount = src[start_index + i].colorAttachmentCount;
      ptr[i].pColorAttachments = nullptr;
      if (src[start_index + i].pColorAttachments) {
        ptr[i].pColorAttachments = CopyArray<>(src[start_index + i].pColorAttachments, 0, 1);
      }
      ptr[i].pResolveAttachments = nullptr;
      if (src[start_index + i].pResolveAttachments) {
        ptr[i].pResolveAttachments = CopyArray<>(src[start_index + i].pResolveAttachments, 0, 1);
      }
      ptr[i].pDepthStencilAttachment = nullptr;
      if (src[start_index + i].pDepthStencilAttachment) {
        ptr[i].pDepthStencilAttachment = CopyArray<>(src[start_index + i].pDepthStencilAttachment, 0, 1);
      }
      ptr[i].preserveAttachmentCount = src[start_index + i].preserveAttachmentCount;
      ptr[i].pPreserveAttachments = nullptr;
      if (src[start_index + i].pPreserveAttachments) {
        ptr[i].pPreserveAttachments = CopyArray<>(src[start_index + i].pPreserveAttachments, 0, 1);
      }
  }
  return ptr;
}

template<>
VkSubpassDependency *CommandRecorder::CopyArray<VkSubpassDependency>(const VkSubpassDependency *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSubpassDependency *>(m_allocator.Alloc(sizeof(VkSubpassDependency) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].srcSubpass = src[start_index + i].srcSubpass;
      ptr[i].dstSubpass = src[start_index + i].dstSubpass;
      ptr[i].srcStageMask = src[start_index + i].srcStageMask;
      ptr[i].dstStageMask = src[start_index + i].dstStageMask;
      ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
      ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
      ptr[i].dependencyFlags = src[start_index + i].dependencyFlags;
  }
  return ptr;
}

template<>
VkRenderPassCreateInfo *CommandRecorder::CopyArray<VkRenderPassCreateInfo>(const VkRenderPassCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkRenderPassCreateInfo *>(m_allocator.Alloc(sizeof(VkRenderPassCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].attachmentCount = src[start_index + i].attachmentCount;
      ptr[i].pAttachments = nullptr;
      if (src[start_index + i].pAttachments) {
        ptr[i].pAttachments = CopyArray<>(src[start_index + i].pAttachments, 0, 1);
      }
      ptr[i].subpassCount = src[start_index + i].subpassCount;
      ptr[i].pSubpasses = nullptr;
      if (src[start_index + i].pSubpasses) {
        ptr[i].pSubpasses = CopyArray<>(src[start_index + i].pSubpasses, 0, 1);
      }
      ptr[i].dependencyCount = src[start_index + i].dependencyCount;
      ptr[i].pDependencies = nullptr;
      if (src[start_index + i].pDependencies) {
        ptr[i].pDependencies = CopyArray<>(src[start_index + i].pDependencies, 0, 1);
      }
  }
  return ptr;
}

template<>
VkEventCreateInfo *CommandRecorder::CopyArray<VkEventCreateInfo>(const VkEventCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkEventCreateInfo *>(m_allocator.Alloc(sizeof(VkEventCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
  }
  return ptr;
}

template<>
VkFenceCreateInfo *CommandRecorder::CopyArray<VkFenceCreateInfo>(const VkFenceCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkFenceCreateInfo *>(m_allocator.Alloc(sizeof(VkFenceCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
  }
  return ptr;
}

template<>
VkPhysicalDeviceFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceFeatures>(const VkPhysicalDeviceFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].robustBufferAccess = src[start_index + i].robustBufferAccess;
      ptr[i].fullDrawIndexUint32 = src[start_index + i].fullDrawIndexUint32;
      ptr[i].imageCubeArray = src[start_index + i].imageCubeArray;
      ptr[i].independentBlend = src[start_index + i].independentBlend;
      ptr[i].geometryShader = src[start_index + i].geometryShader;
      ptr[i].tessellationShader = src[start_index + i].tessellationShader;
      ptr[i].sampleRateShading = src[start_index + i].sampleRateShading;
      ptr[i].dualSrcBlend = src[start_index + i].dualSrcBlend;
      ptr[i].logicOp = src[start_index + i].logicOp;
      ptr[i].multiDrawIndirect = src[start_index + i].multiDrawIndirect;
      ptr[i].drawIndirectFirstInstance = src[start_index + i].drawIndirectFirstInstance;
      ptr[i].depthClamp = src[start_index + i].depthClamp;
      ptr[i].depthBiasClamp = src[start_index + i].depthBiasClamp;
      ptr[i].fillModeNonSolid = src[start_index + i].fillModeNonSolid;
      ptr[i].depthBounds = src[start_index + i].depthBounds;
      ptr[i].wideLines = src[start_index + i].wideLines;
      ptr[i].largePoints = src[start_index + i].largePoints;
      ptr[i].alphaToOne = src[start_index + i].alphaToOne;
      ptr[i].multiViewport = src[start_index + i].multiViewport;
      ptr[i].samplerAnisotropy = src[start_index + i].samplerAnisotropy;
      ptr[i].textureCompressionETC2 = src[start_index + i].textureCompressionETC2;
      ptr[i].textureCompressionASTC_LDR = src[start_index + i].textureCompressionASTC_LDR;
      ptr[i].textureCompressionBC = src[start_index + i].textureCompressionBC;
      ptr[i].occlusionQueryPrecise = src[start_index + i].occlusionQueryPrecise;
      ptr[i].pipelineStatisticsQuery = src[start_index + i].pipelineStatisticsQuery;
      ptr[i].vertexPipelineStoresAndAtomics = src[start_index + i].vertexPipelineStoresAndAtomics;
      ptr[i].fragmentStoresAndAtomics = src[start_index + i].fragmentStoresAndAtomics;
      ptr[i].shaderTessellationAndGeometryPointSize = src[start_index + i].shaderTessellationAndGeometryPointSize;
      ptr[i].shaderImageGatherExtended = src[start_index + i].shaderImageGatherExtended;
      ptr[i].shaderStorageImageExtendedFormats = src[start_index + i].shaderStorageImageExtendedFormats;
      ptr[i].shaderStorageImageMultisample = src[start_index + i].shaderStorageImageMultisample;
      ptr[i].shaderStorageImageReadWithoutFormat = src[start_index + i].shaderStorageImageReadWithoutFormat;
      ptr[i].shaderStorageImageWriteWithoutFormat = src[start_index + i].shaderStorageImageWriteWithoutFormat;
      ptr[i].shaderUniformBufferArrayDynamicIndexing = src[start_index + i].shaderUniformBufferArrayDynamicIndexing;
      ptr[i].shaderSampledImageArrayDynamicIndexing = src[start_index + i].shaderSampledImageArrayDynamicIndexing;
      ptr[i].shaderStorageBufferArrayDynamicIndexing = src[start_index + i].shaderStorageBufferArrayDynamicIndexing;
      ptr[i].shaderStorageImageArrayDynamicIndexing = src[start_index + i].shaderStorageImageArrayDynamicIndexing;
      ptr[i].shaderClipDistance = src[start_index + i].shaderClipDistance;
      ptr[i].shaderCullDistance = src[start_index + i].shaderCullDistance;
      ptr[i].shaderFloat64 = src[start_index + i].shaderFloat64;
      ptr[i].shaderInt64 = src[start_index + i].shaderInt64;
      ptr[i].shaderInt16 = src[start_index + i].shaderInt16;
      ptr[i].shaderResourceResidency = src[start_index + i].shaderResourceResidency;
      ptr[i].shaderResourceMinLod = src[start_index + i].shaderResourceMinLod;
      ptr[i].sparseBinding = src[start_index + i].sparseBinding;
      ptr[i].sparseResidencyBuffer = src[start_index + i].sparseResidencyBuffer;
      ptr[i].sparseResidencyImage2D = src[start_index + i].sparseResidencyImage2D;
      ptr[i].sparseResidencyImage3D = src[start_index + i].sparseResidencyImage3D;
      ptr[i].sparseResidency2Samples = src[start_index + i].sparseResidency2Samples;
      ptr[i].sparseResidency4Samples = src[start_index + i].sparseResidency4Samples;
      ptr[i].sparseResidency8Samples = src[start_index + i].sparseResidency8Samples;
      ptr[i].sparseResidency16Samples = src[start_index + i].sparseResidency16Samples;
      ptr[i].sparseResidencyAliased = src[start_index + i].sparseResidencyAliased;
      ptr[i].variableMultisampleRate = src[start_index + i].variableMultisampleRate;
      ptr[i].inheritedQueries = src[start_index + i].inheritedQueries;
  }
  return ptr;
}

template<>
VkPhysicalDeviceSparseProperties *CommandRecorder::CopyArray<VkPhysicalDeviceSparseProperties>(const VkPhysicalDeviceSparseProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceSparseProperties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceSparseProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].residencyStandard2DBlockShape = src[start_index + i].residencyStandard2DBlockShape;
      ptr[i].residencyStandard2DMultisampleBlockShape = src[start_index + i].residencyStandard2DMultisampleBlockShape;
      ptr[i].residencyStandard3DBlockShape = src[start_index + i].residencyStandard3DBlockShape;
      ptr[i].residencyAlignedMipSize = src[start_index + i].residencyAlignedMipSize;
      ptr[i].residencyNonResidentStrict = src[start_index + i].residencyNonResidentStrict;
  }
  return ptr;
}

template<>
VkPhysicalDeviceLimits *CommandRecorder::CopyArray<VkPhysicalDeviceLimits>(const VkPhysicalDeviceLimits *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceLimits *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceLimits) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].maxImageDimension1D = src[start_index + i].maxImageDimension1D;
      ptr[i].maxImageDimension2D = src[start_index + i].maxImageDimension2D;
      ptr[i].maxImageDimension3D = src[start_index + i].maxImageDimension3D;
      ptr[i].maxImageDimensionCube = src[start_index + i].maxImageDimensionCube;
      ptr[i].maxImageArrayLayers = src[start_index + i].maxImageArrayLayers;
      ptr[i].maxTexelBufferElements = src[start_index + i].maxTexelBufferElements;
      ptr[i].maxUniformBufferRange = src[start_index + i].maxUniformBufferRange;
      ptr[i].maxStorageBufferRange = src[start_index + i].maxStorageBufferRange;
      ptr[i].maxPushConstantsSize = src[start_index + i].maxPushConstantsSize;
      ptr[i].maxMemoryAllocationCount = src[start_index + i].maxMemoryAllocationCount;
      ptr[i].maxSamplerAllocationCount = src[start_index + i].maxSamplerAllocationCount;
      ptr[i].bufferImageGranularity = src[start_index + i].bufferImageGranularity;
      ptr[i].sparseAddressSpaceSize = src[start_index + i].sparseAddressSpaceSize;
      ptr[i].maxBoundDescriptorSets = src[start_index + i].maxBoundDescriptorSets;
      ptr[i].maxPerStageDescriptorSamplers = src[start_index + i].maxPerStageDescriptorSamplers;
      ptr[i].maxPerStageDescriptorUniformBuffers = src[start_index + i].maxPerStageDescriptorUniformBuffers;
      ptr[i].maxPerStageDescriptorStorageBuffers = src[start_index + i].maxPerStageDescriptorStorageBuffers;
      ptr[i].maxPerStageDescriptorSampledImages = src[start_index + i].maxPerStageDescriptorSampledImages;
      ptr[i].maxPerStageDescriptorStorageImages = src[start_index + i].maxPerStageDescriptorStorageImages;
      ptr[i].maxPerStageDescriptorInputAttachments = src[start_index + i].maxPerStageDescriptorInputAttachments;
      ptr[i].maxPerStageResources = src[start_index + i].maxPerStageResources;
      ptr[i].maxDescriptorSetSamplers = src[start_index + i].maxDescriptorSetSamplers;
      ptr[i].maxDescriptorSetUniformBuffers = src[start_index + i].maxDescriptorSetUniformBuffers;
      ptr[i].maxDescriptorSetUniformBuffersDynamic = src[start_index + i].maxDescriptorSetUniformBuffersDynamic;
      ptr[i].maxDescriptorSetStorageBuffers = src[start_index + i].maxDescriptorSetStorageBuffers;
      ptr[i].maxDescriptorSetStorageBuffersDynamic = src[start_index + i].maxDescriptorSetStorageBuffersDynamic;
      ptr[i].maxDescriptorSetSampledImages = src[start_index + i].maxDescriptorSetSampledImages;
      ptr[i].maxDescriptorSetStorageImages = src[start_index + i].maxDescriptorSetStorageImages;
      ptr[i].maxDescriptorSetInputAttachments = src[start_index + i].maxDescriptorSetInputAttachments;
      ptr[i].maxVertexInputAttributes = src[start_index + i].maxVertexInputAttributes;
      ptr[i].maxVertexInputBindings = src[start_index + i].maxVertexInputBindings;
      ptr[i].maxVertexInputAttributeOffset = src[start_index + i].maxVertexInputAttributeOffset;
      ptr[i].maxVertexInputBindingStride = src[start_index + i].maxVertexInputBindingStride;
      ptr[i].maxVertexOutputComponents = src[start_index + i].maxVertexOutputComponents;
      ptr[i].maxTessellationGenerationLevel = src[start_index + i].maxTessellationGenerationLevel;
      ptr[i].maxTessellationPatchSize = src[start_index + i].maxTessellationPatchSize;
      ptr[i].maxTessellationControlPerVertexInputComponents = src[start_index + i].maxTessellationControlPerVertexInputComponents;
      ptr[i].maxTessellationControlPerVertexOutputComponents = src[start_index + i].maxTessellationControlPerVertexOutputComponents;
      ptr[i].maxTessellationControlPerPatchOutputComponents = src[start_index + i].maxTessellationControlPerPatchOutputComponents;
      ptr[i].maxTessellationControlTotalOutputComponents = src[start_index + i].maxTessellationControlTotalOutputComponents;
      ptr[i].maxTessellationEvaluationInputComponents = src[start_index + i].maxTessellationEvaluationInputComponents;
      ptr[i].maxTessellationEvaluationOutputComponents = src[start_index + i].maxTessellationEvaluationOutputComponents;
      ptr[i].maxGeometryShaderInvocations = src[start_index + i].maxGeometryShaderInvocations;
      ptr[i].maxGeometryInputComponents = src[start_index + i].maxGeometryInputComponents;
      ptr[i].maxGeometryOutputComponents = src[start_index + i].maxGeometryOutputComponents;
      ptr[i].maxGeometryOutputVertices = src[start_index + i].maxGeometryOutputVertices;
      ptr[i].maxGeometryTotalOutputComponents = src[start_index + i].maxGeometryTotalOutputComponents;
      ptr[i].maxFragmentInputComponents = src[start_index + i].maxFragmentInputComponents;
      ptr[i].maxFragmentOutputAttachments = src[start_index + i].maxFragmentOutputAttachments;
      ptr[i].maxFragmentDualSrcAttachments = src[start_index + i].maxFragmentDualSrcAttachments;
      ptr[i].maxFragmentCombinedOutputResources = src[start_index + i].maxFragmentCombinedOutputResources;
      ptr[i].maxComputeSharedMemorySize = src[start_index + i].maxComputeSharedMemorySize;
      std::memcpy(ptr[i].maxComputeWorkGroupCount, src[start_index + i].maxComputeWorkGroupCount, sizeof(src[start_index + i].maxComputeWorkGroupCount));
      ptr[i].maxComputeWorkGroupInvocations = src[start_index + i].maxComputeWorkGroupInvocations;
      std::memcpy(ptr[i].maxComputeWorkGroupSize, src[start_index + i].maxComputeWorkGroupSize, sizeof(src[start_index + i].maxComputeWorkGroupSize));
      ptr[i].subPixelPrecisionBits = src[start_index + i].subPixelPrecisionBits;
      ptr[i].subTexelPrecisionBits = src[start_index + i].subTexelPrecisionBits;
      ptr[i].mipmapPrecisionBits = src[start_index + i].mipmapPrecisionBits;
      ptr[i].maxDrawIndexedIndexValue = src[start_index + i].maxDrawIndexedIndexValue;
      ptr[i].maxDrawIndirectCount = src[start_index + i].maxDrawIndirectCount;
      ptr[i].maxSamplerLodBias = src[start_index + i].maxSamplerLodBias;
      ptr[i].maxSamplerAnisotropy = src[start_index + i].maxSamplerAnisotropy;
      ptr[i].maxViewports = src[start_index + i].maxViewports;
      std::memcpy(ptr[i].maxViewportDimensions, src[start_index + i].maxViewportDimensions, sizeof(src[start_index + i].maxViewportDimensions));
      std::memcpy(ptr[i].viewportBoundsRange, src[start_index + i].viewportBoundsRange, sizeof(src[start_index + i].viewportBoundsRange));
      ptr[i].viewportSubPixelBits = src[start_index + i].viewportSubPixelBits;
      ptr[i].minMemoryMapAlignment = src[start_index + i].minMemoryMapAlignment;
      ptr[i].minTexelBufferOffsetAlignment = src[start_index + i].minTexelBufferOffsetAlignment;
      ptr[i].minUniformBufferOffsetAlignment = src[start_index + i].minUniformBufferOffsetAlignment;
      ptr[i].minStorageBufferOffsetAlignment = src[start_index + i].minStorageBufferOffsetAlignment;
      ptr[i].minTexelOffset = src[start_index + i].minTexelOffset;
      ptr[i].maxTexelOffset = src[start_index + i].maxTexelOffset;
      ptr[i].minTexelGatherOffset = src[start_index + i].minTexelGatherOffset;
      ptr[i].maxTexelGatherOffset = src[start_index + i].maxTexelGatherOffset;
      ptr[i].minInterpolationOffset = src[start_index + i].minInterpolationOffset;
      ptr[i].maxInterpolationOffset = src[start_index + i].maxInterpolationOffset;
      ptr[i].subPixelInterpolationOffsetBits = src[start_index + i].subPixelInterpolationOffsetBits;
      ptr[i].maxFramebufferWidth = src[start_index + i].maxFramebufferWidth;
      ptr[i].maxFramebufferHeight = src[start_index + i].maxFramebufferHeight;
      ptr[i].maxFramebufferLayers = src[start_index + i].maxFramebufferLayers;
      ptr[i].framebufferColorSampleCounts = src[start_index + i].framebufferColorSampleCounts;
      ptr[i].framebufferDepthSampleCounts = src[start_index + i].framebufferDepthSampleCounts;
      ptr[i].framebufferStencilSampleCounts = src[start_index + i].framebufferStencilSampleCounts;
      ptr[i].framebufferNoAttachmentsSampleCounts = src[start_index + i].framebufferNoAttachmentsSampleCounts;
      ptr[i].maxColorAttachments = src[start_index + i].maxColorAttachments;
      ptr[i].sampledImageColorSampleCounts = src[start_index + i].sampledImageColorSampleCounts;
      ptr[i].sampledImageIntegerSampleCounts = src[start_index + i].sampledImageIntegerSampleCounts;
      ptr[i].sampledImageDepthSampleCounts = src[start_index + i].sampledImageDepthSampleCounts;
      ptr[i].sampledImageStencilSampleCounts = src[start_index + i].sampledImageStencilSampleCounts;
      ptr[i].storageImageSampleCounts = src[start_index + i].storageImageSampleCounts;
      ptr[i].maxSampleMaskWords = src[start_index + i].maxSampleMaskWords;
      ptr[i].timestampComputeAndGraphics = src[start_index + i].timestampComputeAndGraphics;
      ptr[i].timestampPeriod = src[start_index + i].timestampPeriod;
      ptr[i].maxClipDistances = src[start_index + i].maxClipDistances;
      ptr[i].maxCullDistances = src[start_index + i].maxCullDistances;
      ptr[i].maxCombinedClipAndCullDistances = src[start_index + i].maxCombinedClipAndCullDistances;
      ptr[i].discreteQueuePriorities = src[start_index + i].discreteQueuePriorities;
      std::memcpy(ptr[i].pointSizeRange, src[start_index + i].pointSizeRange, sizeof(src[start_index + i].pointSizeRange));
      std::memcpy(ptr[i].lineWidthRange, src[start_index + i].lineWidthRange, sizeof(src[start_index + i].lineWidthRange));
      ptr[i].pointSizeGranularity = src[start_index + i].pointSizeGranularity;
      ptr[i].lineWidthGranularity = src[start_index + i].lineWidthGranularity;
      ptr[i].strictLines = src[start_index + i].strictLines;
      ptr[i].standardSampleLocations = src[start_index + i].standardSampleLocations;
      ptr[i].optimalBufferCopyOffsetAlignment = src[start_index + i].optimalBufferCopyOffsetAlignment;
      ptr[i].optimalBufferCopyRowPitchAlignment = src[start_index + i].optimalBufferCopyRowPitchAlignment;
      ptr[i].nonCoherentAtomSize = src[start_index + i].nonCoherentAtomSize;
  }
  return ptr;
}

template<>
VkSemaphoreCreateInfo *CommandRecorder::CopyArray<VkSemaphoreCreateInfo>(const VkSemaphoreCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSemaphoreCreateInfo *>(m_allocator.Alloc(sizeof(VkSemaphoreCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
  }
  return ptr;
}

template<>
VkQueryPoolCreateInfo *CommandRecorder::CopyArray<VkQueryPoolCreateInfo>(const VkQueryPoolCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkQueryPoolCreateInfo *>(m_allocator.Alloc(sizeof(VkQueryPoolCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].queryType = src[start_index + i].queryType;
      ptr[i].queryCount = src[start_index + i].queryCount;
      ptr[i].pipelineStatistics = src[start_index + i].pipelineStatistics;
  }
  return ptr;
}

template<>
VkFramebufferCreateInfo *CommandRecorder::CopyArray<VkFramebufferCreateInfo>(const VkFramebufferCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkFramebufferCreateInfo *>(m_allocator.Alloc(sizeof(VkFramebufferCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].renderPass = src[start_index + i].renderPass;
      ptr[i].attachmentCount = src[start_index + i].attachmentCount;
      ptr[i].pAttachments = nullptr;
      if (src[start_index + i].pAttachments) {
        ptr[i].pAttachments = CopyArray<>(src[start_index + i].pAttachments, 0, 1);
      }
      ptr[i].width = src[start_index + i].width;
      ptr[i].height = src[start_index + i].height;
      ptr[i].layers = src[start_index + i].layers;
  }
  return ptr;
}

template<>
VkDrawIndirectCommand *CommandRecorder::CopyArray<VkDrawIndirectCommand>(const VkDrawIndirectCommand *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDrawIndirectCommand *>(m_allocator.Alloc(sizeof(VkDrawIndirectCommand) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].vertexCount = src[start_index + i].vertexCount;
      ptr[i].instanceCount = src[start_index + i].instanceCount;
      ptr[i].firstVertex = src[start_index + i].firstVertex;
      ptr[i].firstInstance = src[start_index + i].firstInstance;
  }
  return ptr;
}

template<>
VkDrawIndexedIndirectCommand *CommandRecorder::CopyArray<VkDrawIndexedIndirectCommand>(const VkDrawIndexedIndirectCommand *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDrawIndexedIndirectCommand *>(m_allocator.Alloc(sizeof(VkDrawIndexedIndirectCommand) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].indexCount = src[start_index + i].indexCount;
      ptr[i].instanceCount = src[start_index + i].instanceCount;
      ptr[i].firstIndex = src[start_index + i].firstIndex;
      ptr[i].vertexOffset = src[start_index + i].vertexOffset;
      ptr[i].firstInstance = src[start_index + i].firstInstance;
  }
  return ptr;
}

template<>
VkDispatchIndirectCommand *CommandRecorder::CopyArray<VkDispatchIndirectCommand>(const VkDispatchIndirectCommand *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDispatchIndirectCommand *>(m_allocator.Alloc(sizeof(VkDispatchIndirectCommand) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].x = src[start_index + i].x;
      ptr[i].y = src[start_index + i].y;
      ptr[i].z = src[start_index + i].z;
  }
  return ptr;
}

template<>
VkSubmitInfo *CommandRecorder::CopyArray<VkSubmitInfo>(const VkSubmitInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSubmitInfo *>(m_allocator.Alloc(sizeof(VkSubmitInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].waitSemaphoreCount = src[start_index + i].waitSemaphoreCount;
      ptr[i].pWaitSemaphores = nullptr;
      if (src[start_index + i].pWaitSemaphores) {
        ptr[i].pWaitSemaphores = CopyArray<>(src[start_index + i].pWaitSemaphores, 0, 1);
      }
      ptr[i].pWaitDstStageMask = nullptr;
      if (src[start_index + i].pWaitDstStageMask) {
        ptr[i].pWaitDstStageMask = CopyArray<>(src[start_index + i].pWaitDstStageMask, 0, 1);
      }
      ptr[i].commandBufferCount = src[start_index + i].commandBufferCount;
      ptr[i].pCommandBuffers = nullptr;
      if (src[start_index + i].pCommandBuffers) {
        ptr[i].pCommandBuffers = CopyArray<>(src[start_index + i].pCommandBuffers, 0, 1);
      }
      ptr[i].signalSemaphoreCount = src[start_index + i].signalSemaphoreCount;
      ptr[i].pSignalSemaphores = nullptr;
      if (src[start_index + i].pSignalSemaphores) {
        ptr[i].pSignalSemaphores = CopyArray<>(src[start_index + i].pSignalSemaphores, 0, 1);
      }
  }
  return ptr;
}

template<>
VkPhysicalDeviceFeatures2 *CommandRecorder::CopyArray<VkPhysicalDeviceFeatures2>(const VkPhysicalDeviceFeatures2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceFeatures2 *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceFeatures2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].features = src[start_index + i].features;
  }
  return ptr;
}

template<>
VkPhysicalDeviceProperties2 *CommandRecorder::CopyArray<VkPhysicalDeviceProperties2>(const VkPhysicalDeviceProperties2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceProperties2 *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceProperties2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].properties = src[start_index + i].properties;
  }
  return ptr;
}

template<>
VkFormatProperties2 *CommandRecorder::CopyArray<VkFormatProperties2>(const VkFormatProperties2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkFormatProperties2 *>(m_allocator.Alloc(sizeof(VkFormatProperties2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].formatProperties = src[start_index + i].formatProperties;
  }
  return ptr;
}

template<>
VkImageFormatProperties2 *CommandRecorder::CopyArray<VkImageFormatProperties2>(const VkImageFormatProperties2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageFormatProperties2 *>(m_allocator.Alloc(sizeof(VkImageFormatProperties2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].imageFormatProperties = src[start_index + i].imageFormatProperties;
  }
  return ptr;
}

template<>
VkPhysicalDeviceImageFormatInfo2 *CommandRecorder::CopyArray<VkPhysicalDeviceImageFormatInfo2>(const VkPhysicalDeviceImageFormatInfo2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceImageFormatInfo2 *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceImageFormatInfo2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].format = src[start_index + i].format;
      ptr[i].type = src[start_index + i].type;
      ptr[i].tiling = src[start_index + i].tiling;
      ptr[i].usage = src[start_index + i].usage;
      ptr[i].flags = src[start_index + i].flags;
  }
  return ptr;
}

template<>
VkQueueFamilyProperties2 *CommandRecorder::CopyArray<VkQueueFamilyProperties2>(const VkQueueFamilyProperties2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkQueueFamilyProperties2 *>(m_allocator.Alloc(sizeof(VkQueueFamilyProperties2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].queueFamilyProperties = src[start_index + i].queueFamilyProperties;
  }
  return ptr;
}

template<>
VkPhysicalDeviceMemoryProperties2 *CommandRecorder::CopyArray<VkPhysicalDeviceMemoryProperties2>(const VkPhysicalDeviceMemoryProperties2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceMemoryProperties2 *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceMemoryProperties2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].memoryProperties = src[start_index + i].memoryProperties;
  }
  return ptr;
}

template<>
VkSparseImageFormatProperties2 *CommandRecorder::CopyArray<VkSparseImageFormatProperties2>(const VkSparseImageFormatProperties2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSparseImageFormatProperties2 *>(m_allocator.Alloc(sizeof(VkSparseImageFormatProperties2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].properties = src[start_index + i].properties;
  }
  return ptr;
}

template<>
VkPhysicalDeviceSparseImageFormatInfo2 *CommandRecorder::CopyArray<VkPhysicalDeviceSparseImageFormatInfo2>(const VkPhysicalDeviceSparseImageFormatInfo2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceSparseImageFormatInfo2 *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceSparseImageFormatInfo2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].format = src[start_index + i].format;
      ptr[i].type = src[start_index + i].type;
      ptr[i].samples = src[start_index + i].samples;
      ptr[i].usage = src[start_index + i].usage;
      ptr[i].tiling = src[start_index + i].tiling;
  }
  return ptr;
}

template<>
VkConformanceVersion *CommandRecorder::CopyArray<VkConformanceVersion>(const VkConformanceVersion *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkConformanceVersion *>(m_allocator.Alloc(sizeof(VkConformanceVersion) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].major = src[start_index + i].major;
      ptr[i].minor = src[start_index + i].minor;
      ptr[i].subminor = src[start_index + i].subminor;
      ptr[i].patch = src[start_index + i].patch;
  }
  return ptr;
}

template<>
VkPhysicalDeviceDriverProperties *CommandRecorder::CopyArray<VkPhysicalDeviceDriverProperties>(const VkPhysicalDeviceDriverProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceDriverProperties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceDriverProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].driverID = src[start_index + i].driverID;
      std::memcpy(ptr[i].driverName, src[start_index + i].driverName, sizeof(src[start_index + i].driverName));
      std::memcpy(ptr[i].driverInfo, src[start_index + i].driverInfo, sizeof(src[start_index + i].driverInfo));
      ptr[i].conformanceVersion = src[start_index + i].conformanceVersion;
  }
  return ptr;
}

template<>
VkPhysicalDeviceVariablePointersFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceVariablePointersFeatures>(const VkPhysicalDeviceVariablePointersFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceVariablePointersFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceVariablePointersFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].variablePointersStorageBuffer = src[start_index + i].variablePointersStorageBuffer;
      ptr[i].variablePointers = src[start_index + i].variablePointers;
  }
  return ptr;
}

template<>
VkExternalMemoryProperties *CommandRecorder::CopyArray<VkExternalMemoryProperties>(const VkExternalMemoryProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkExternalMemoryProperties *>(m_allocator.Alloc(sizeof(VkExternalMemoryProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].externalMemoryFeatures = src[start_index + i].externalMemoryFeatures;
      ptr[i].exportFromImportedHandleTypes = src[start_index + i].exportFromImportedHandleTypes;
      ptr[i].compatibleHandleTypes = src[start_index + i].compatibleHandleTypes;
  }
  return ptr;
}

template<>
VkPhysicalDeviceExternalImageFormatInfo *CommandRecorder::CopyArray<VkPhysicalDeviceExternalImageFormatInfo>(const VkPhysicalDeviceExternalImageFormatInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceExternalImageFormatInfo *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceExternalImageFormatInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].handleType = src[start_index + i].handleType;
  }
  return ptr;
}

template<>
VkExternalImageFormatProperties *CommandRecorder::CopyArray<VkExternalImageFormatProperties>(const VkExternalImageFormatProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkExternalImageFormatProperties *>(m_allocator.Alloc(sizeof(VkExternalImageFormatProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].externalMemoryProperties = src[start_index + i].externalMemoryProperties;
  }
  return ptr;
}

template<>
VkPhysicalDeviceExternalBufferInfo *CommandRecorder::CopyArray<VkPhysicalDeviceExternalBufferInfo>(const VkPhysicalDeviceExternalBufferInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceExternalBufferInfo *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceExternalBufferInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].usage = src[start_index + i].usage;
      ptr[i].handleType = src[start_index + i].handleType;
  }
  return ptr;
}

template<>
VkExternalBufferProperties *CommandRecorder::CopyArray<VkExternalBufferProperties>(const VkExternalBufferProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkExternalBufferProperties *>(m_allocator.Alloc(sizeof(VkExternalBufferProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].externalMemoryProperties = src[start_index + i].externalMemoryProperties;
  }
  return ptr;
}

template<>
VkPhysicalDeviceIDProperties *CommandRecorder::CopyArray<VkPhysicalDeviceIDProperties>(const VkPhysicalDeviceIDProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceIDProperties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceIDProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      std::memcpy(ptr[i].deviceUUID, src[start_index + i].deviceUUID, sizeof(src[start_index + i].deviceUUID));
      std::memcpy(ptr[i].driverUUID, src[start_index + i].driverUUID, sizeof(src[start_index + i].driverUUID));
      std::memcpy(ptr[i].deviceLUID, src[start_index + i].deviceLUID, sizeof(src[start_index + i].deviceLUID));
      ptr[i].deviceNodeMask = src[start_index + i].deviceNodeMask;
      ptr[i].deviceLUIDValid = src[start_index + i].deviceLUIDValid;
  }
  return ptr;
}

template<>
VkExternalMemoryImageCreateInfo *CommandRecorder::CopyArray<VkExternalMemoryImageCreateInfo>(const VkExternalMemoryImageCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkExternalMemoryImageCreateInfo *>(m_allocator.Alloc(sizeof(VkExternalMemoryImageCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].handleTypes = src[start_index + i].handleTypes;
  }
  return ptr;
}

template<>
VkExternalMemoryBufferCreateInfo *CommandRecorder::CopyArray<VkExternalMemoryBufferCreateInfo>(const VkExternalMemoryBufferCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkExternalMemoryBufferCreateInfo *>(m_allocator.Alloc(sizeof(VkExternalMemoryBufferCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].handleTypes = src[start_index + i].handleTypes;
  }
  return ptr;
}

template<>
VkExportMemoryAllocateInfo *CommandRecorder::CopyArray<VkExportMemoryAllocateInfo>(const VkExportMemoryAllocateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkExportMemoryAllocateInfo *>(m_allocator.Alloc(sizeof(VkExportMemoryAllocateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].handleTypes = src[start_index + i].handleTypes;
  }
  return ptr;
}

template<>
VkPhysicalDeviceExternalSemaphoreInfo *CommandRecorder::CopyArray<VkPhysicalDeviceExternalSemaphoreInfo>(const VkPhysicalDeviceExternalSemaphoreInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceExternalSemaphoreInfo *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceExternalSemaphoreInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].handleType = src[start_index + i].handleType;
  }
  return ptr;
}

template<>
VkExternalSemaphoreProperties *CommandRecorder::CopyArray<VkExternalSemaphoreProperties>(const VkExternalSemaphoreProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkExternalSemaphoreProperties *>(m_allocator.Alloc(sizeof(VkExternalSemaphoreProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].exportFromImportedHandleTypes = src[start_index + i].exportFromImportedHandleTypes;
      ptr[i].compatibleHandleTypes = src[start_index + i].compatibleHandleTypes;
      ptr[i].externalSemaphoreFeatures = src[start_index + i].externalSemaphoreFeatures;
  }
  return ptr;
}

template<>
VkExportSemaphoreCreateInfo *CommandRecorder::CopyArray<VkExportSemaphoreCreateInfo>(const VkExportSemaphoreCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkExportSemaphoreCreateInfo *>(m_allocator.Alloc(sizeof(VkExportSemaphoreCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].handleTypes = src[start_index + i].handleTypes;
  }
  return ptr;
}

template<>
VkPhysicalDeviceExternalFenceInfo *CommandRecorder::CopyArray<VkPhysicalDeviceExternalFenceInfo>(const VkPhysicalDeviceExternalFenceInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceExternalFenceInfo *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceExternalFenceInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].handleType = src[start_index + i].handleType;
  }
  return ptr;
}

template<>
VkExternalFenceProperties *CommandRecorder::CopyArray<VkExternalFenceProperties>(const VkExternalFenceProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkExternalFenceProperties *>(m_allocator.Alloc(sizeof(VkExternalFenceProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].exportFromImportedHandleTypes = src[start_index + i].exportFromImportedHandleTypes;
      ptr[i].compatibleHandleTypes = src[start_index + i].compatibleHandleTypes;
      ptr[i].externalFenceFeatures = src[start_index + i].externalFenceFeatures;
  }
  return ptr;
}

template<>
VkExportFenceCreateInfo *CommandRecorder::CopyArray<VkExportFenceCreateInfo>(const VkExportFenceCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkExportFenceCreateInfo *>(m_allocator.Alloc(sizeof(VkExportFenceCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].handleTypes = src[start_index + i].handleTypes;
  }
  return ptr;
}

template<>
VkPhysicalDeviceMultiviewFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceMultiviewFeatures>(const VkPhysicalDeviceMultiviewFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceMultiviewFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceMultiviewFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].multiview = src[start_index + i].multiview;
      ptr[i].multiviewGeometryShader = src[start_index + i].multiviewGeometryShader;
      ptr[i].multiviewTessellationShader = src[start_index + i].multiviewTessellationShader;
  }
  return ptr;
}

template<>
VkPhysicalDeviceMultiviewProperties *CommandRecorder::CopyArray<VkPhysicalDeviceMultiviewProperties>(const VkPhysicalDeviceMultiviewProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceMultiviewProperties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceMultiviewProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].maxMultiviewViewCount = src[start_index + i].maxMultiviewViewCount;
      ptr[i].maxMultiviewInstanceIndex = src[start_index + i].maxMultiviewInstanceIndex;
  }
  return ptr;
}

template<>
VkRenderPassMultiviewCreateInfo *CommandRecorder::CopyArray<VkRenderPassMultiviewCreateInfo>(const VkRenderPassMultiviewCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkRenderPassMultiviewCreateInfo *>(m_allocator.Alloc(sizeof(VkRenderPassMultiviewCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].subpassCount = src[start_index + i].subpassCount;
      ptr[i].pViewMasks = nullptr;
      if (src[start_index + i].pViewMasks) {
        ptr[i].pViewMasks = CopyArray<>(src[start_index + i].pViewMasks, 0, 1);
      }
      ptr[i].dependencyCount = src[start_index + i].dependencyCount;
      ptr[i].pViewOffsets = nullptr;
      if (src[start_index + i].pViewOffsets) {
        ptr[i].pViewOffsets = CopyArray<>(src[start_index + i].pViewOffsets, 0, 1);
      }
      ptr[i].correlationMaskCount = src[start_index + i].correlationMaskCount;
      ptr[i].pCorrelationMasks = nullptr;
      if (src[start_index + i].pCorrelationMasks) {
        ptr[i].pCorrelationMasks = CopyArray<>(src[start_index + i].pCorrelationMasks, 0, 1);
      }
  }
  return ptr;
}

template<>
VkPhysicalDeviceGroupProperties *CommandRecorder::CopyArray<VkPhysicalDeviceGroupProperties>(const VkPhysicalDeviceGroupProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceGroupProperties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceGroupProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].physicalDeviceCount = src[start_index + i].physicalDeviceCount;
      std::memcpy(ptr[i].physicalDevices, src[start_index + i].physicalDevices, sizeof(src[start_index + i].physicalDevices));
      ptr[i].subsetAllocation = src[start_index + i].subsetAllocation;
  }
  return ptr;
}

template<>
VkMemoryAllocateFlagsInfo *CommandRecorder::CopyArray<VkMemoryAllocateFlagsInfo>(const VkMemoryAllocateFlagsInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMemoryAllocateFlagsInfo *>(m_allocator.Alloc(sizeof(VkMemoryAllocateFlagsInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].deviceMask = src[start_index + i].deviceMask;
  }
  return ptr;
}

template<>
VkBindBufferMemoryInfo *CommandRecorder::CopyArray<VkBindBufferMemoryInfo>(const VkBindBufferMemoryInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBindBufferMemoryInfo *>(m_allocator.Alloc(sizeof(VkBindBufferMemoryInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].buffer = src[start_index + i].buffer;
      ptr[i].memory = src[start_index + i].memory;
      ptr[i].memoryOffset = src[start_index + i].memoryOffset;
  }
  return ptr;
}

template<>
VkBindBufferMemoryDeviceGroupInfo *CommandRecorder::CopyArray<VkBindBufferMemoryDeviceGroupInfo>(const VkBindBufferMemoryDeviceGroupInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBindBufferMemoryDeviceGroupInfo *>(m_allocator.Alloc(sizeof(VkBindBufferMemoryDeviceGroupInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].deviceIndexCount = src[start_index + i].deviceIndexCount;
      ptr[i].pDeviceIndices = nullptr;
      if (src[start_index + i].pDeviceIndices) {
        ptr[i].pDeviceIndices = CopyArray<>(src[start_index + i].pDeviceIndices, 0, 1);
      }
  }
  return ptr;
}

template<>
VkBindImageMemoryInfo *CommandRecorder::CopyArray<VkBindImageMemoryInfo>(const VkBindImageMemoryInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBindImageMemoryInfo *>(m_allocator.Alloc(sizeof(VkBindImageMemoryInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].image = src[start_index + i].image;
      ptr[i].memory = src[start_index + i].memory;
      ptr[i].memoryOffset = src[start_index + i].memoryOffset;
  }
  return ptr;
}

template<>
VkBindImageMemoryDeviceGroupInfo *CommandRecorder::CopyArray<VkBindImageMemoryDeviceGroupInfo>(const VkBindImageMemoryDeviceGroupInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBindImageMemoryDeviceGroupInfo *>(m_allocator.Alloc(sizeof(VkBindImageMemoryDeviceGroupInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].deviceIndexCount = src[start_index + i].deviceIndexCount;
      ptr[i].pDeviceIndices = nullptr;
      if (src[start_index + i].pDeviceIndices) {
        ptr[i].pDeviceIndices = CopyArray<>(src[start_index + i].pDeviceIndices, 0, 1);
      }
      ptr[i].splitInstanceBindRegionCount = src[start_index + i].splitInstanceBindRegionCount;
      ptr[i].pSplitInstanceBindRegions = nullptr;
      if (src[start_index + i].pSplitInstanceBindRegions) {
        ptr[i].pSplitInstanceBindRegions = CopyArray<>(src[start_index + i].pSplitInstanceBindRegions, 0, 1);
      }
  }
  return ptr;
}

template<>
VkDeviceGroupRenderPassBeginInfo *CommandRecorder::CopyArray<VkDeviceGroupRenderPassBeginInfo>(const VkDeviceGroupRenderPassBeginInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceGroupRenderPassBeginInfo *>(m_allocator.Alloc(sizeof(VkDeviceGroupRenderPassBeginInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].deviceMask = src[start_index + i].deviceMask;
      ptr[i].deviceRenderAreaCount = src[start_index + i].deviceRenderAreaCount;
      ptr[i].pDeviceRenderAreas = nullptr;
      if (src[start_index + i].pDeviceRenderAreas) {
        ptr[i].pDeviceRenderAreas = CopyArray<>(src[start_index + i].pDeviceRenderAreas, 0, 1);
      }
  }
  return ptr;
}

template<>
VkDeviceGroupCommandBufferBeginInfo *CommandRecorder::CopyArray<VkDeviceGroupCommandBufferBeginInfo>(const VkDeviceGroupCommandBufferBeginInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceGroupCommandBufferBeginInfo *>(m_allocator.Alloc(sizeof(VkDeviceGroupCommandBufferBeginInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].deviceMask = src[start_index + i].deviceMask;
  }
  return ptr;
}

template<>
VkDeviceGroupSubmitInfo *CommandRecorder::CopyArray<VkDeviceGroupSubmitInfo>(const VkDeviceGroupSubmitInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceGroupSubmitInfo *>(m_allocator.Alloc(sizeof(VkDeviceGroupSubmitInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].waitSemaphoreCount = src[start_index + i].waitSemaphoreCount;
      ptr[i].pWaitSemaphoreDeviceIndices = nullptr;
      if (src[start_index + i].pWaitSemaphoreDeviceIndices) {
        ptr[i].pWaitSemaphoreDeviceIndices = CopyArray<>(src[start_index + i].pWaitSemaphoreDeviceIndices, 0, 1);
      }
      ptr[i].commandBufferCount = src[start_index + i].commandBufferCount;
      ptr[i].pCommandBufferDeviceMasks = nullptr;
      if (src[start_index + i].pCommandBufferDeviceMasks) {
        ptr[i].pCommandBufferDeviceMasks = CopyArray<>(src[start_index + i].pCommandBufferDeviceMasks, 0, 1);
      }
      ptr[i].signalSemaphoreCount = src[start_index + i].signalSemaphoreCount;
      ptr[i].pSignalSemaphoreDeviceIndices = nullptr;
      if (src[start_index + i].pSignalSemaphoreDeviceIndices) {
        ptr[i].pSignalSemaphoreDeviceIndices = CopyArray<>(src[start_index + i].pSignalSemaphoreDeviceIndices, 0, 1);
      }
  }
  return ptr;
}

template<>
VkDeviceGroupBindSparseInfo *CommandRecorder::CopyArray<VkDeviceGroupBindSparseInfo>(const VkDeviceGroupBindSparseInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceGroupBindSparseInfo *>(m_allocator.Alloc(sizeof(VkDeviceGroupBindSparseInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].resourceDeviceIndex = src[start_index + i].resourceDeviceIndex;
      ptr[i].memoryDeviceIndex = src[start_index + i].memoryDeviceIndex;
  }
  return ptr;
}

template<>
VkDeviceGroupDeviceCreateInfo *CommandRecorder::CopyArray<VkDeviceGroupDeviceCreateInfo>(const VkDeviceGroupDeviceCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceGroupDeviceCreateInfo *>(m_allocator.Alloc(sizeof(VkDeviceGroupDeviceCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].physicalDeviceCount = src[start_index + i].physicalDeviceCount;
      ptr[i].pPhysicalDevices = nullptr;
      if (src[start_index + i].pPhysicalDevices) {
        ptr[i].pPhysicalDevices = CopyArray<>(src[start_index + i].pPhysicalDevices, 0, 1);
      }
  }
  return ptr;
}

template<>
VkDescriptorUpdateTemplateEntry *CommandRecorder::CopyArray<VkDescriptorUpdateTemplateEntry>(const VkDescriptorUpdateTemplateEntry *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDescriptorUpdateTemplateEntry *>(m_allocator.Alloc(sizeof(VkDescriptorUpdateTemplateEntry) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].dstBinding = src[start_index + i].dstBinding;
      ptr[i].dstArrayElement = src[start_index + i].dstArrayElement;
      ptr[i].descriptorCount = src[start_index + i].descriptorCount;
      ptr[i].descriptorType = src[start_index + i].descriptorType;
      ptr[i].offset = src[start_index + i].offset;
      ptr[i].stride = src[start_index + i].stride;
  }
  return ptr;
}

template<>
VkDescriptorUpdateTemplateCreateInfo *CommandRecorder::CopyArray<VkDescriptorUpdateTemplateCreateInfo>(const VkDescriptorUpdateTemplateCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDescriptorUpdateTemplateCreateInfo *>(m_allocator.Alloc(sizeof(VkDescriptorUpdateTemplateCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].descriptorUpdateEntryCount = src[start_index + i].descriptorUpdateEntryCount;
      ptr[i].pDescriptorUpdateEntries = nullptr;
      if (src[start_index + i].pDescriptorUpdateEntries) {
        ptr[i].pDescriptorUpdateEntries = CopyArray<>(src[start_index + i].pDescriptorUpdateEntries, 0, 1);
      }
      ptr[i].templateType = src[start_index + i].templateType;
      ptr[i].descriptorSetLayout = src[start_index + i].descriptorSetLayout;
      ptr[i].pipelineBindPoint = src[start_index + i].pipelineBindPoint;
      ptr[i].pipelineLayout = src[start_index + i].pipelineLayout;
      ptr[i].set = src[start_index + i].set;
  }
  return ptr;
}

template<>
VkInputAttachmentAspectReference *CommandRecorder::CopyArray<VkInputAttachmentAspectReference>(const VkInputAttachmentAspectReference *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkInputAttachmentAspectReference *>(m_allocator.Alloc(sizeof(VkInputAttachmentAspectReference) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].subpass = src[start_index + i].subpass;
      ptr[i].inputAttachmentIndex = src[start_index + i].inputAttachmentIndex;
      ptr[i].aspectMask = src[start_index + i].aspectMask;
  }
  return ptr;
}

template<>
VkRenderPassInputAttachmentAspectCreateInfo *CommandRecorder::CopyArray<VkRenderPassInputAttachmentAspectCreateInfo>(const VkRenderPassInputAttachmentAspectCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkRenderPassInputAttachmentAspectCreateInfo *>(m_allocator.Alloc(sizeof(VkRenderPassInputAttachmentAspectCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].aspectReferenceCount = src[start_index + i].aspectReferenceCount;
      ptr[i].pAspectReferences = nullptr;
      if (src[start_index + i].pAspectReferences) {
        ptr[i].pAspectReferences = CopyArray<>(src[start_index + i].pAspectReferences, 0, 1);
      }
  }
  return ptr;
}

template<>
VkPhysicalDevice16BitStorageFeatures *CommandRecorder::CopyArray<VkPhysicalDevice16BitStorageFeatures>(const VkPhysicalDevice16BitStorageFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDevice16BitStorageFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDevice16BitStorageFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].storageBuffer16BitAccess = src[start_index + i].storageBuffer16BitAccess;
      ptr[i].uniformAndStorageBuffer16BitAccess = src[start_index + i].uniformAndStorageBuffer16BitAccess;
      ptr[i].storagePushConstant16 = src[start_index + i].storagePushConstant16;
      ptr[i].storageInputOutput16 = src[start_index + i].storageInputOutput16;
  }
  return ptr;
}

template<>
VkPhysicalDeviceSubgroupProperties *CommandRecorder::CopyArray<VkPhysicalDeviceSubgroupProperties>(const VkPhysicalDeviceSubgroupProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceSubgroupProperties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceSubgroupProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].subgroupSize = src[start_index + i].subgroupSize;
      ptr[i].supportedStages = src[start_index + i].supportedStages;
      ptr[i].supportedOperations = src[start_index + i].supportedOperations;
      ptr[i].quadOperationsInAllStages = src[start_index + i].quadOperationsInAllStages;
  }
  return ptr;
}

template<>
VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>(const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].shaderSubgroupExtendedTypes = src[start_index + i].shaderSubgroupExtendedTypes;
  }
  return ptr;
}

template<>
VkBufferMemoryRequirementsInfo2 *CommandRecorder::CopyArray<VkBufferMemoryRequirementsInfo2>(const VkBufferMemoryRequirementsInfo2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBufferMemoryRequirementsInfo2 *>(m_allocator.Alloc(sizeof(VkBufferMemoryRequirementsInfo2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].buffer = src[start_index + i].buffer;
  }
  return ptr;
}

template<>
VkImageMemoryRequirementsInfo2 *CommandRecorder::CopyArray<VkImageMemoryRequirementsInfo2>(const VkImageMemoryRequirementsInfo2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageMemoryRequirementsInfo2 *>(m_allocator.Alloc(sizeof(VkImageMemoryRequirementsInfo2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].image = src[start_index + i].image;
  }
  return ptr;
}

template<>
VkImageSparseMemoryRequirementsInfo2 *CommandRecorder::CopyArray<VkImageSparseMemoryRequirementsInfo2>(const VkImageSparseMemoryRequirementsInfo2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageSparseMemoryRequirementsInfo2 *>(m_allocator.Alloc(sizeof(VkImageSparseMemoryRequirementsInfo2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].image = src[start_index + i].image;
  }
  return ptr;
}

template<>
VkMemoryRequirements2 *CommandRecorder::CopyArray<VkMemoryRequirements2>(const VkMemoryRequirements2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMemoryRequirements2 *>(m_allocator.Alloc(sizeof(VkMemoryRequirements2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].memoryRequirements = src[start_index + i].memoryRequirements;
  }
  return ptr;
}

template<>
VkSparseImageMemoryRequirements2 *CommandRecorder::CopyArray<VkSparseImageMemoryRequirements2>(const VkSparseImageMemoryRequirements2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSparseImageMemoryRequirements2 *>(m_allocator.Alloc(sizeof(VkSparseImageMemoryRequirements2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].memoryRequirements = src[start_index + i].memoryRequirements;
  }
  return ptr;
}

template<>
VkPhysicalDevicePointClippingProperties *CommandRecorder::CopyArray<VkPhysicalDevicePointClippingProperties>(const VkPhysicalDevicePointClippingProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDevicePointClippingProperties *>(m_allocator.Alloc(sizeof(VkPhysicalDevicePointClippingProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].pointClippingBehavior = src[start_index + i].pointClippingBehavior;
  }
  return ptr;
}

template<>
VkMemoryDedicatedRequirements *CommandRecorder::CopyArray<VkMemoryDedicatedRequirements>(const VkMemoryDedicatedRequirements *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMemoryDedicatedRequirements *>(m_allocator.Alloc(sizeof(VkMemoryDedicatedRequirements) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].prefersDedicatedAllocation = src[start_index + i].prefersDedicatedAllocation;
      ptr[i].requiresDedicatedAllocation = src[start_index + i].requiresDedicatedAllocation;
  }
  return ptr;
}

template<>
VkMemoryDedicatedAllocateInfo *CommandRecorder::CopyArray<VkMemoryDedicatedAllocateInfo>(const VkMemoryDedicatedAllocateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMemoryDedicatedAllocateInfo *>(m_allocator.Alloc(sizeof(VkMemoryDedicatedAllocateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].image = src[start_index + i].image;
      ptr[i].buffer = src[start_index + i].buffer;
  }
  return ptr;
}

template<>
VkImageViewUsageCreateInfo *CommandRecorder::CopyArray<VkImageViewUsageCreateInfo>(const VkImageViewUsageCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageViewUsageCreateInfo *>(m_allocator.Alloc(sizeof(VkImageViewUsageCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].usage = src[start_index + i].usage;
  }
  return ptr;
}

template<>
VkPipelineTessellationDomainOriginStateCreateInfo *CommandRecorder::CopyArray<VkPipelineTessellationDomainOriginStateCreateInfo>(const VkPipelineTessellationDomainOriginStateCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPipelineTessellationDomainOriginStateCreateInfo *>(m_allocator.Alloc(sizeof(VkPipelineTessellationDomainOriginStateCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].domainOrigin = src[start_index + i].domainOrigin;
  }
  return ptr;
}

template<>
VkSamplerYcbcrConversionInfo *CommandRecorder::CopyArray<VkSamplerYcbcrConversionInfo>(const VkSamplerYcbcrConversionInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSamplerYcbcrConversionInfo *>(m_allocator.Alloc(sizeof(VkSamplerYcbcrConversionInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].conversion = src[start_index + i].conversion;
  }
  return ptr;
}

template<>
VkSamplerYcbcrConversionCreateInfo *CommandRecorder::CopyArray<VkSamplerYcbcrConversionCreateInfo>(const VkSamplerYcbcrConversionCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSamplerYcbcrConversionCreateInfo *>(m_allocator.Alloc(sizeof(VkSamplerYcbcrConversionCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].format = src[start_index + i].format;
      ptr[i].ycbcrModel = src[start_index + i].ycbcrModel;
      ptr[i].ycbcrRange = src[start_index + i].ycbcrRange;
      ptr[i].components = src[start_index + i].components;
      ptr[i].xChromaOffset = src[start_index + i].xChromaOffset;
      ptr[i].yChromaOffset = src[start_index + i].yChromaOffset;
      ptr[i].chromaFilter = src[start_index + i].chromaFilter;
      ptr[i].forceExplicitReconstruction = src[start_index + i].forceExplicitReconstruction;
  }
  return ptr;
}

template<>
VkBindImagePlaneMemoryInfo *CommandRecorder::CopyArray<VkBindImagePlaneMemoryInfo>(const VkBindImagePlaneMemoryInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBindImagePlaneMemoryInfo *>(m_allocator.Alloc(sizeof(VkBindImagePlaneMemoryInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].planeAspect = src[start_index + i].planeAspect;
  }
  return ptr;
}

template<>
VkImagePlaneMemoryRequirementsInfo *CommandRecorder::CopyArray<VkImagePlaneMemoryRequirementsInfo>(const VkImagePlaneMemoryRequirementsInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImagePlaneMemoryRequirementsInfo *>(m_allocator.Alloc(sizeof(VkImagePlaneMemoryRequirementsInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].planeAspect = src[start_index + i].planeAspect;
  }
  return ptr;
}

template<>
VkPhysicalDeviceSamplerYcbcrConversionFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceSamplerYcbcrConversionFeatures>(const VkPhysicalDeviceSamplerYcbcrConversionFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceSamplerYcbcrConversionFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceSamplerYcbcrConversionFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].samplerYcbcrConversion = src[start_index + i].samplerYcbcrConversion;
  }
  return ptr;
}

template<>
VkSamplerYcbcrConversionImageFormatProperties *CommandRecorder::CopyArray<VkSamplerYcbcrConversionImageFormatProperties>(const VkSamplerYcbcrConversionImageFormatProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSamplerYcbcrConversionImageFormatProperties *>(m_allocator.Alloc(sizeof(VkSamplerYcbcrConversionImageFormatProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].combinedImageSamplerDescriptorCount = src[start_index + i].combinedImageSamplerDescriptorCount;
  }
  return ptr;
}

template<>
VkProtectedSubmitInfo *CommandRecorder::CopyArray<VkProtectedSubmitInfo>(const VkProtectedSubmitInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkProtectedSubmitInfo *>(m_allocator.Alloc(sizeof(VkProtectedSubmitInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].protectedSubmit = src[start_index + i].protectedSubmit;
  }
  return ptr;
}

template<>
VkPhysicalDeviceProtectedMemoryFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceProtectedMemoryFeatures>(const VkPhysicalDeviceProtectedMemoryFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceProtectedMemoryFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceProtectedMemoryFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].protectedMemory = src[start_index + i].protectedMemory;
  }
  return ptr;
}

template<>
VkPhysicalDeviceProtectedMemoryProperties *CommandRecorder::CopyArray<VkPhysicalDeviceProtectedMemoryProperties>(const VkPhysicalDeviceProtectedMemoryProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceProtectedMemoryProperties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceProtectedMemoryProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].protectedNoFault = src[start_index + i].protectedNoFault;
  }
  return ptr;
}

template<>
VkDeviceQueueInfo2 *CommandRecorder::CopyArray<VkDeviceQueueInfo2>(const VkDeviceQueueInfo2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceQueueInfo2 *>(m_allocator.Alloc(sizeof(VkDeviceQueueInfo2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].queueFamilyIndex = src[start_index + i].queueFamilyIndex;
      ptr[i].queueIndex = src[start_index + i].queueIndex;
  }
  return ptr;
}

template<>
VkPhysicalDeviceSamplerFilterMinmaxProperties *CommandRecorder::CopyArray<VkPhysicalDeviceSamplerFilterMinmaxProperties>(const VkPhysicalDeviceSamplerFilterMinmaxProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceSamplerFilterMinmaxProperties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceSamplerFilterMinmaxProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].filterMinmaxSingleComponentFormats = src[start_index + i].filterMinmaxSingleComponentFormats;
      ptr[i].filterMinmaxImageComponentMapping = src[start_index + i].filterMinmaxImageComponentMapping;
  }
  return ptr;
}

template<>
VkSamplerReductionModeCreateInfo *CommandRecorder::CopyArray<VkSamplerReductionModeCreateInfo>(const VkSamplerReductionModeCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSamplerReductionModeCreateInfo *>(m_allocator.Alloc(sizeof(VkSamplerReductionModeCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].reductionMode = src[start_index + i].reductionMode;
  }
  return ptr;
}

template<>
VkImageFormatListCreateInfo *CommandRecorder::CopyArray<VkImageFormatListCreateInfo>(const VkImageFormatListCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageFormatListCreateInfo *>(m_allocator.Alloc(sizeof(VkImageFormatListCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].viewFormatCount = src[start_index + i].viewFormatCount;
      ptr[i].pViewFormats = nullptr;
      if (src[start_index + i].pViewFormats) {
        ptr[i].pViewFormats = CopyArray<>(src[start_index + i].pViewFormats, 0, 1);
      }
  }
  return ptr;
}

template<>
VkPhysicalDeviceMaintenance3Properties *CommandRecorder::CopyArray<VkPhysicalDeviceMaintenance3Properties>(const VkPhysicalDeviceMaintenance3Properties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceMaintenance3Properties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceMaintenance3Properties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].maxPerSetDescriptors = src[start_index + i].maxPerSetDescriptors;
      ptr[i].maxMemoryAllocationSize = src[start_index + i].maxMemoryAllocationSize;
  }
  return ptr;
}

template<>
VkDescriptorSetLayoutSupport *CommandRecorder::CopyArray<VkDescriptorSetLayoutSupport>(const VkDescriptorSetLayoutSupport *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDescriptorSetLayoutSupport *>(m_allocator.Alloc(sizeof(VkDescriptorSetLayoutSupport) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].supported = src[start_index + i].supported;
  }
  return ptr;
}

template<>
VkPhysicalDeviceShaderDrawParametersFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceShaderDrawParametersFeatures>(const VkPhysicalDeviceShaderDrawParametersFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceShaderDrawParametersFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderDrawParametersFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].shaderDrawParameters = src[start_index + i].shaderDrawParameters;
  }
  return ptr;
}

template<>
VkPhysicalDeviceShaderFloat16Int8Features *CommandRecorder::CopyArray<VkPhysicalDeviceShaderFloat16Int8Features>(const VkPhysicalDeviceShaderFloat16Int8Features *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceShaderFloat16Int8Features *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderFloat16Int8Features) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].shaderFloat16 = src[start_index + i].shaderFloat16;
      ptr[i].shaderInt8 = src[start_index + i].shaderInt8;
  }
  return ptr;
}

template<>
VkPhysicalDeviceFloatControlsProperties *CommandRecorder::CopyArray<VkPhysicalDeviceFloatControlsProperties>(const VkPhysicalDeviceFloatControlsProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceFloatControlsProperties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceFloatControlsProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].denormBehaviorIndependence = src[start_index + i].denormBehaviorIndependence;
      ptr[i].roundingModeIndependence = src[start_index + i].roundingModeIndependence;
      ptr[i].shaderSignedZeroInfNanPreserveFloat16 = src[start_index + i].shaderSignedZeroInfNanPreserveFloat16;
      ptr[i].shaderSignedZeroInfNanPreserveFloat32 = src[start_index + i].shaderSignedZeroInfNanPreserveFloat32;
      ptr[i].shaderSignedZeroInfNanPreserveFloat64 = src[start_index + i].shaderSignedZeroInfNanPreserveFloat64;
      ptr[i].shaderDenormPreserveFloat16 = src[start_index + i].shaderDenormPreserveFloat16;
      ptr[i].shaderDenormPreserveFloat32 = src[start_index + i].shaderDenormPreserveFloat32;
      ptr[i].shaderDenormPreserveFloat64 = src[start_index + i].shaderDenormPreserveFloat64;
      ptr[i].shaderDenormFlushToZeroFloat16 = src[start_index + i].shaderDenormFlushToZeroFloat16;
      ptr[i].shaderDenormFlushToZeroFloat32 = src[start_index + i].shaderDenormFlushToZeroFloat32;
      ptr[i].shaderDenormFlushToZeroFloat64 = src[start_index + i].shaderDenormFlushToZeroFloat64;
      ptr[i].shaderRoundingModeRTEFloat16 = src[start_index + i].shaderRoundingModeRTEFloat16;
      ptr[i].shaderRoundingModeRTEFloat32 = src[start_index + i].shaderRoundingModeRTEFloat32;
      ptr[i].shaderRoundingModeRTEFloat64 = src[start_index + i].shaderRoundingModeRTEFloat64;
      ptr[i].shaderRoundingModeRTZFloat16 = src[start_index + i].shaderRoundingModeRTZFloat16;
      ptr[i].shaderRoundingModeRTZFloat32 = src[start_index + i].shaderRoundingModeRTZFloat32;
      ptr[i].shaderRoundingModeRTZFloat64 = src[start_index + i].shaderRoundingModeRTZFloat64;
  }
  return ptr;
}

template<>
VkPhysicalDeviceHostQueryResetFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceHostQueryResetFeatures>(const VkPhysicalDeviceHostQueryResetFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceHostQueryResetFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceHostQueryResetFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].hostQueryReset = src[start_index + i].hostQueryReset;
  }
  return ptr;
}

template<>
VkPhysicalDeviceDescriptorIndexingFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorIndexingFeatures>(const VkPhysicalDeviceDescriptorIndexingFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceDescriptorIndexingFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceDescriptorIndexingFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].shaderInputAttachmentArrayDynamicIndexing = src[start_index + i].shaderInputAttachmentArrayDynamicIndexing;
      ptr[i].shaderUniformTexelBufferArrayDynamicIndexing = src[start_index + i].shaderUniformTexelBufferArrayDynamicIndexing;
      ptr[i].shaderStorageTexelBufferArrayDynamicIndexing = src[start_index + i].shaderStorageTexelBufferArrayDynamicIndexing;
      ptr[i].shaderUniformBufferArrayNonUniformIndexing = src[start_index + i].shaderUniformBufferArrayNonUniformIndexing;
      ptr[i].shaderSampledImageArrayNonUniformIndexing = src[start_index + i].shaderSampledImageArrayNonUniformIndexing;
      ptr[i].shaderStorageBufferArrayNonUniformIndexing = src[start_index + i].shaderStorageBufferArrayNonUniformIndexing;
      ptr[i].shaderStorageImageArrayNonUniformIndexing = src[start_index + i].shaderStorageImageArrayNonUniformIndexing;
      ptr[i].shaderInputAttachmentArrayNonUniformIndexing = src[start_index + i].shaderInputAttachmentArrayNonUniformIndexing;
      ptr[i].shaderUniformTexelBufferArrayNonUniformIndexing = src[start_index + i].shaderUniformTexelBufferArrayNonUniformIndexing;
      ptr[i].shaderStorageTexelBufferArrayNonUniformIndexing = src[start_index + i].shaderStorageTexelBufferArrayNonUniformIndexing;
      ptr[i].descriptorBindingUniformBufferUpdateAfterBind = src[start_index + i].descriptorBindingUniformBufferUpdateAfterBind;
      ptr[i].descriptorBindingSampledImageUpdateAfterBind = src[start_index + i].descriptorBindingSampledImageUpdateAfterBind;
      ptr[i].descriptorBindingStorageImageUpdateAfterBind = src[start_index + i].descriptorBindingStorageImageUpdateAfterBind;
      ptr[i].descriptorBindingStorageBufferUpdateAfterBind = src[start_index + i].descriptorBindingStorageBufferUpdateAfterBind;
      ptr[i].descriptorBindingUniformTexelBufferUpdateAfterBind = src[start_index + i].descriptorBindingUniformTexelBufferUpdateAfterBind;
      ptr[i].descriptorBindingStorageTexelBufferUpdateAfterBind = src[start_index + i].descriptorBindingStorageTexelBufferUpdateAfterBind;
      ptr[i].descriptorBindingUpdateUnusedWhilePending = src[start_index + i].descriptorBindingUpdateUnusedWhilePending;
      ptr[i].descriptorBindingPartiallyBound = src[start_index + i].descriptorBindingPartiallyBound;
      ptr[i].descriptorBindingVariableDescriptorCount = src[start_index + i].descriptorBindingVariableDescriptorCount;
      ptr[i].runtimeDescriptorArray = src[start_index + i].runtimeDescriptorArray;
  }
  return ptr;
}

template<>
VkPhysicalDeviceDescriptorIndexingProperties *CommandRecorder::CopyArray<VkPhysicalDeviceDescriptorIndexingProperties>(const VkPhysicalDeviceDescriptorIndexingProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceDescriptorIndexingProperties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceDescriptorIndexingProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].maxUpdateAfterBindDescriptorsInAllPools = src[start_index + i].maxUpdateAfterBindDescriptorsInAllPools;
      ptr[i].shaderUniformBufferArrayNonUniformIndexingNative = src[start_index + i].shaderUniformBufferArrayNonUniformIndexingNative;
      ptr[i].shaderSampledImageArrayNonUniformIndexingNative = src[start_index + i].shaderSampledImageArrayNonUniformIndexingNative;
      ptr[i].shaderStorageBufferArrayNonUniformIndexingNative = src[start_index + i].shaderStorageBufferArrayNonUniformIndexingNative;
      ptr[i].shaderStorageImageArrayNonUniformIndexingNative = src[start_index + i].shaderStorageImageArrayNonUniformIndexingNative;
      ptr[i].shaderInputAttachmentArrayNonUniformIndexingNative = src[start_index + i].shaderInputAttachmentArrayNonUniformIndexingNative;
      ptr[i].robustBufferAccessUpdateAfterBind = src[start_index + i].robustBufferAccessUpdateAfterBind;
      ptr[i].quadDivergentImplicitLod = src[start_index + i].quadDivergentImplicitLod;
      ptr[i].maxPerStageDescriptorUpdateAfterBindSamplers = src[start_index + i].maxPerStageDescriptorUpdateAfterBindSamplers;
      ptr[i].maxPerStageDescriptorUpdateAfterBindUniformBuffers = src[start_index + i].maxPerStageDescriptorUpdateAfterBindUniformBuffers;
      ptr[i].maxPerStageDescriptorUpdateAfterBindStorageBuffers = src[start_index + i].maxPerStageDescriptorUpdateAfterBindStorageBuffers;
      ptr[i].maxPerStageDescriptorUpdateAfterBindSampledImages = src[start_index + i].maxPerStageDescriptorUpdateAfterBindSampledImages;
      ptr[i].maxPerStageDescriptorUpdateAfterBindStorageImages = src[start_index + i].maxPerStageDescriptorUpdateAfterBindStorageImages;
      ptr[i].maxPerStageDescriptorUpdateAfterBindInputAttachments = src[start_index + i].maxPerStageDescriptorUpdateAfterBindInputAttachments;
      ptr[i].maxPerStageUpdateAfterBindResources = src[start_index + i].maxPerStageUpdateAfterBindResources;
      ptr[i].maxDescriptorSetUpdateAfterBindSamplers = src[start_index + i].maxDescriptorSetUpdateAfterBindSamplers;
      ptr[i].maxDescriptorSetUpdateAfterBindUniformBuffers = src[start_index + i].maxDescriptorSetUpdateAfterBindUniformBuffers;
      ptr[i].maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = src[start_index + i].maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
      ptr[i].maxDescriptorSetUpdateAfterBindStorageBuffers = src[start_index + i].maxDescriptorSetUpdateAfterBindStorageBuffers;
      ptr[i].maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = src[start_index + i].maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
      ptr[i].maxDescriptorSetUpdateAfterBindSampledImages = src[start_index + i].maxDescriptorSetUpdateAfterBindSampledImages;
      ptr[i].maxDescriptorSetUpdateAfterBindStorageImages = src[start_index + i].maxDescriptorSetUpdateAfterBindStorageImages;
      ptr[i].maxDescriptorSetUpdateAfterBindInputAttachments = src[start_index + i].maxDescriptorSetUpdateAfterBindInputAttachments;
  }
  return ptr;
}

template<>
VkDescriptorSetLayoutBindingFlagsCreateInfo *CommandRecorder::CopyArray<VkDescriptorSetLayoutBindingFlagsCreateInfo>(const VkDescriptorSetLayoutBindingFlagsCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDescriptorSetLayoutBindingFlagsCreateInfo *>(m_allocator.Alloc(sizeof(VkDescriptorSetLayoutBindingFlagsCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].bindingCount = src[start_index + i].bindingCount;
      ptr[i].pBindingFlags = nullptr;
      if (src[start_index + i].pBindingFlags) {
        ptr[i].pBindingFlags = CopyArray<>(src[start_index + i].pBindingFlags, 0, 1);
      }
  }
  return ptr;
}

template<>
VkDescriptorSetVariableDescriptorCountAllocateInfo *CommandRecorder::CopyArray<VkDescriptorSetVariableDescriptorCountAllocateInfo>(const VkDescriptorSetVariableDescriptorCountAllocateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDescriptorSetVariableDescriptorCountAllocateInfo *>(m_allocator.Alloc(sizeof(VkDescriptorSetVariableDescriptorCountAllocateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].descriptorSetCount = src[start_index + i].descriptorSetCount;
      ptr[i].pDescriptorCounts = nullptr;
      if (src[start_index + i].pDescriptorCounts) {
        ptr[i].pDescriptorCounts = CopyArray<>(src[start_index + i].pDescriptorCounts, 0, 1);
      }
  }
  return ptr;
}

template<>
VkDescriptorSetVariableDescriptorCountLayoutSupport *CommandRecorder::CopyArray<VkDescriptorSetVariableDescriptorCountLayoutSupport>(const VkDescriptorSetVariableDescriptorCountLayoutSupport *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDescriptorSetVariableDescriptorCountLayoutSupport *>(m_allocator.Alloc(sizeof(VkDescriptorSetVariableDescriptorCountLayoutSupport) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].maxVariableDescriptorCount = src[start_index + i].maxVariableDescriptorCount;
  }
  return ptr;
}

template<>
VkAttachmentDescription2 *CommandRecorder::CopyArray<VkAttachmentDescription2>(const VkAttachmentDescription2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAttachmentDescription2 *>(m_allocator.Alloc(sizeof(VkAttachmentDescription2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].format = src[start_index + i].format;
      ptr[i].samples = src[start_index + i].samples;
      ptr[i].loadOp = src[start_index + i].loadOp;
      ptr[i].storeOp = src[start_index + i].storeOp;
      ptr[i].stencilLoadOp = src[start_index + i].stencilLoadOp;
      ptr[i].stencilStoreOp = src[start_index + i].stencilStoreOp;
      ptr[i].initialLayout = src[start_index + i].initialLayout;
      ptr[i].finalLayout = src[start_index + i].finalLayout;
  }
  return ptr;
}

template<>
VkAttachmentReference2 *CommandRecorder::CopyArray<VkAttachmentReference2>(const VkAttachmentReference2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAttachmentReference2 *>(m_allocator.Alloc(sizeof(VkAttachmentReference2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].attachment = src[start_index + i].attachment;
      ptr[i].layout = src[start_index + i].layout;
      ptr[i].aspectMask = src[start_index + i].aspectMask;
  }
  return ptr;
}

template<>
VkSubpassDescription2 *CommandRecorder::CopyArray<VkSubpassDescription2>(const VkSubpassDescription2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSubpassDescription2 *>(m_allocator.Alloc(sizeof(VkSubpassDescription2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].pipelineBindPoint = src[start_index + i].pipelineBindPoint;
      ptr[i].viewMask = src[start_index + i].viewMask;
      ptr[i].inputAttachmentCount = src[start_index + i].inputAttachmentCount;
      ptr[i].pInputAttachments = nullptr;
      if (src[start_index + i].pInputAttachments) {
        ptr[i].pInputAttachments = CopyArray<>(src[start_index + i].pInputAttachments, 0, 1);
      }
      ptr[i].colorAttachmentCount = src[start_index + i].colorAttachmentCount;
      ptr[i].pColorAttachments = nullptr;
      if (src[start_index + i].pColorAttachments) {
        ptr[i].pColorAttachments = CopyArray<>(src[start_index + i].pColorAttachments, 0, 1);
      }
      ptr[i].pResolveAttachments = nullptr;
      if (src[start_index + i].pResolveAttachments) {
        ptr[i].pResolveAttachments = CopyArray<>(src[start_index + i].pResolveAttachments, 0, 1);
      }
      ptr[i].pDepthStencilAttachment = nullptr;
      if (src[start_index + i].pDepthStencilAttachment) {
        ptr[i].pDepthStencilAttachment = CopyArray<>(src[start_index + i].pDepthStencilAttachment, 0, 1);
      }
      ptr[i].preserveAttachmentCount = src[start_index + i].preserveAttachmentCount;
      ptr[i].pPreserveAttachments = nullptr;
      if (src[start_index + i].pPreserveAttachments) {
        ptr[i].pPreserveAttachments = CopyArray<>(src[start_index + i].pPreserveAttachments, 0, 1);
      }
  }
  return ptr;
}

template<>
VkSubpassDependency2 *CommandRecorder::CopyArray<VkSubpassDependency2>(const VkSubpassDependency2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSubpassDependency2 *>(m_allocator.Alloc(sizeof(VkSubpassDependency2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].srcSubpass = src[start_index + i].srcSubpass;
      ptr[i].dstSubpass = src[start_index + i].dstSubpass;
      ptr[i].srcStageMask = src[start_index + i].srcStageMask;
      ptr[i].dstStageMask = src[start_index + i].dstStageMask;
      ptr[i].srcAccessMask = src[start_index + i].srcAccessMask;
      ptr[i].dstAccessMask = src[start_index + i].dstAccessMask;
      ptr[i].dependencyFlags = src[start_index + i].dependencyFlags;
      ptr[i].viewOffset = src[start_index + i].viewOffset;
  }
  return ptr;
}

template<>
VkRenderPassCreateInfo2 *CommandRecorder::CopyArray<VkRenderPassCreateInfo2>(const VkRenderPassCreateInfo2 *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkRenderPassCreateInfo2 *>(m_allocator.Alloc(sizeof(VkRenderPassCreateInfo2) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].attachmentCount = src[start_index + i].attachmentCount;
      ptr[i].pAttachments = nullptr;
      if (src[start_index + i].pAttachments) {
        ptr[i].pAttachments = CopyArray<>(src[start_index + i].pAttachments, 0, 1);
      }
      ptr[i].subpassCount = src[start_index + i].subpassCount;
      ptr[i].pSubpasses = nullptr;
      if (src[start_index + i].pSubpasses) {
        ptr[i].pSubpasses = CopyArray<>(src[start_index + i].pSubpasses, 0, 1);
      }
      ptr[i].dependencyCount = src[start_index + i].dependencyCount;
      ptr[i].pDependencies = nullptr;
      if (src[start_index + i].pDependencies) {
        ptr[i].pDependencies = CopyArray<>(src[start_index + i].pDependencies, 0, 1);
      }
      ptr[i].correlatedViewMaskCount = src[start_index + i].correlatedViewMaskCount;
      ptr[i].pCorrelatedViewMasks = nullptr;
      if (src[start_index + i].pCorrelatedViewMasks) {
        ptr[i].pCorrelatedViewMasks = CopyArray<>(src[start_index + i].pCorrelatedViewMasks, 0, 1);
      }
  }
  return ptr;
}

template<>
VkSubpassBeginInfo *CommandRecorder::CopyArray<VkSubpassBeginInfo>(const VkSubpassBeginInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSubpassBeginInfo *>(m_allocator.Alloc(sizeof(VkSubpassBeginInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].contents = src[start_index + i].contents;
  }
  return ptr;
}

template<>
VkSubpassEndInfo *CommandRecorder::CopyArray<VkSubpassEndInfo>(const VkSubpassEndInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSubpassEndInfo *>(m_allocator.Alloc(sizeof(VkSubpassEndInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
  }
  return ptr;
}

template<>
VkPhysicalDeviceTimelineSemaphoreFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceTimelineSemaphoreFeatures>(const VkPhysicalDeviceTimelineSemaphoreFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceTimelineSemaphoreFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].timelineSemaphore = src[start_index + i].timelineSemaphore;
  }
  return ptr;
}

template<>
VkPhysicalDeviceTimelineSemaphoreProperties *CommandRecorder::CopyArray<VkPhysicalDeviceTimelineSemaphoreProperties>(const VkPhysicalDeviceTimelineSemaphoreProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceTimelineSemaphoreProperties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceTimelineSemaphoreProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].maxTimelineSemaphoreValueDifference = src[start_index + i].maxTimelineSemaphoreValueDifference;
  }
  return ptr;
}

template<>
VkSemaphoreTypeCreateInfo *CommandRecorder::CopyArray<VkSemaphoreTypeCreateInfo>(const VkSemaphoreTypeCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSemaphoreTypeCreateInfo *>(m_allocator.Alloc(sizeof(VkSemaphoreTypeCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].semaphoreType = src[start_index + i].semaphoreType;
      ptr[i].initialValue = src[start_index + i].initialValue;
  }
  return ptr;
}

template<>
VkTimelineSemaphoreSubmitInfo *CommandRecorder::CopyArray<VkTimelineSemaphoreSubmitInfo>(const VkTimelineSemaphoreSubmitInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkTimelineSemaphoreSubmitInfo *>(m_allocator.Alloc(sizeof(VkTimelineSemaphoreSubmitInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].waitSemaphoreValueCount = src[start_index + i].waitSemaphoreValueCount;
      ptr[i].pWaitSemaphoreValues = nullptr;
      if (src[start_index + i].pWaitSemaphoreValues) {
        ptr[i].pWaitSemaphoreValues = CopyArray<>(src[start_index + i].pWaitSemaphoreValues, 0, 1);
      }
      ptr[i].signalSemaphoreValueCount = src[start_index + i].signalSemaphoreValueCount;
      ptr[i].pSignalSemaphoreValues = nullptr;
      if (src[start_index + i].pSignalSemaphoreValues) {
        ptr[i].pSignalSemaphoreValues = CopyArray<>(src[start_index + i].pSignalSemaphoreValues, 0, 1);
      }
  }
  return ptr;
}

template<>
VkSemaphoreWaitInfo *CommandRecorder::CopyArray<VkSemaphoreWaitInfo>(const VkSemaphoreWaitInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSemaphoreWaitInfo *>(m_allocator.Alloc(sizeof(VkSemaphoreWaitInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].semaphoreCount = src[start_index + i].semaphoreCount;
      ptr[i].pSemaphores = nullptr;
      if (src[start_index + i].pSemaphores) {
        ptr[i].pSemaphores = CopyArray<>(src[start_index + i].pSemaphores, 0, 1);
      }
      ptr[i].pValues = nullptr;
      if (src[start_index + i].pValues) {
        ptr[i].pValues = CopyArray<>(src[start_index + i].pValues, 0, 1);
      }
  }
  return ptr;
}

template<>
VkSemaphoreSignalInfo *CommandRecorder::CopyArray<VkSemaphoreSignalInfo>(const VkSemaphoreSignalInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSemaphoreSignalInfo *>(m_allocator.Alloc(sizeof(VkSemaphoreSignalInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].semaphore = src[start_index + i].semaphore;
      ptr[i].value = src[start_index + i].value;
  }
  return ptr;
}

template<>
VkPhysicalDevice8BitStorageFeatures *CommandRecorder::CopyArray<VkPhysicalDevice8BitStorageFeatures>(const VkPhysicalDevice8BitStorageFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDevice8BitStorageFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDevice8BitStorageFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].storageBuffer8BitAccess = src[start_index + i].storageBuffer8BitAccess;
      ptr[i].uniformAndStorageBuffer8BitAccess = src[start_index + i].uniformAndStorageBuffer8BitAccess;
      ptr[i].storagePushConstant8 = src[start_index + i].storagePushConstant8;
  }
  return ptr;
}

template<>
VkPhysicalDeviceVulkanMemoryModelFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceVulkanMemoryModelFeatures>(const VkPhysicalDeviceVulkanMemoryModelFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceVulkanMemoryModelFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceVulkanMemoryModelFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].vulkanMemoryModel = src[start_index + i].vulkanMemoryModel;
      ptr[i].vulkanMemoryModelDeviceScope = src[start_index + i].vulkanMemoryModelDeviceScope;
      ptr[i].vulkanMemoryModelAvailabilityVisibilityChains = src[start_index + i].vulkanMemoryModelAvailabilityVisibilityChains;
  }
  return ptr;
}

template<>
VkPhysicalDeviceShaderAtomicInt64Features *CommandRecorder::CopyArray<VkPhysicalDeviceShaderAtomicInt64Features>(const VkPhysicalDeviceShaderAtomicInt64Features *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceShaderAtomicInt64Features *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceShaderAtomicInt64Features) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].shaderBufferInt64Atomics = src[start_index + i].shaderBufferInt64Atomics;
      ptr[i].shaderSharedInt64Atomics = src[start_index + i].shaderSharedInt64Atomics;
  }
  return ptr;
}

template<>
VkPhysicalDeviceDepthStencilResolveProperties *CommandRecorder::CopyArray<VkPhysicalDeviceDepthStencilResolveProperties>(const VkPhysicalDeviceDepthStencilResolveProperties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceDepthStencilResolveProperties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceDepthStencilResolveProperties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].supportedDepthResolveModes = src[start_index + i].supportedDepthResolveModes;
      ptr[i].supportedStencilResolveModes = src[start_index + i].supportedStencilResolveModes;
      ptr[i].independentResolveNone = src[start_index + i].independentResolveNone;
      ptr[i].independentResolve = src[start_index + i].independentResolve;
  }
  return ptr;
}

template<>
VkSubpassDescriptionDepthStencilResolve *CommandRecorder::CopyArray<VkSubpassDescriptionDepthStencilResolve>(const VkSubpassDescriptionDepthStencilResolve *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkSubpassDescriptionDepthStencilResolve *>(m_allocator.Alloc(sizeof(VkSubpassDescriptionDepthStencilResolve) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].depthResolveMode = src[start_index + i].depthResolveMode;
      ptr[i].stencilResolveMode = src[start_index + i].stencilResolveMode;
      ptr[i].pDepthStencilResolveAttachment = nullptr;
      if (src[start_index + i].pDepthStencilResolveAttachment) {
        ptr[i].pDepthStencilResolveAttachment = CopyArray<>(src[start_index + i].pDepthStencilResolveAttachment, 0, 1);
      }
  }
  return ptr;
}

template<>
VkImageStencilUsageCreateInfo *CommandRecorder::CopyArray<VkImageStencilUsageCreateInfo>(const VkImageStencilUsageCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkImageStencilUsageCreateInfo *>(m_allocator.Alloc(sizeof(VkImageStencilUsageCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].stencilUsage = src[start_index + i].stencilUsage;
  }
  return ptr;
}

template<>
VkPhysicalDeviceScalarBlockLayoutFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceScalarBlockLayoutFeatures>(const VkPhysicalDeviceScalarBlockLayoutFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceScalarBlockLayoutFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceScalarBlockLayoutFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].scalarBlockLayout = src[start_index + i].scalarBlockLayout;
  }
  return ptr;
}

template<>
VkPhysicalDeviceUniformBufferStandardLayoutFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>(const VkPhysicalDeviceUniformBufferStandardLayoutFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceUniformBufferStandardLayoutFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceUniformBufferStandardLayoutFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].uniformBufferStandardLayout = src[start_index + i].uniformBufferStandardLayout;
  }
  return ptr;
}

template<>
VkPhysicalDeviceBufferDeviceAddressFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceBufferDeviceAddressFeatures>(const VkPhysicalDeviceBufferDeviceAddressFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceBufferDeviceAddressFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceBufferDeviceAddressFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].bufferDeviceAddress = src[start_index + i].bufferDeviceAddress;
      ptr[i].bufferDeviceAddressCaptureReplay = src[start_index + i].bufferDeviceAddressCaptureReplay;
      ptr[i].bufferDeviceAddressMultiDevice = src[start_index + i].bufferDeviceAddressMultiDevice;
  }
  return ptr;
}

template<>
VkBufferDeviceAddressInfo *CommandRecorder::CopyArray<VkBufferDeviceAddressInfo>(const VkBufferDeviceAddressInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBufferDeviceAddressInfo *>(m_allocator.Alloc(sizeof(VkBufferDeviceAddressInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].buffer = src[start_index + i].buffer;
  }
  return ptr;
}

template<>
VkBufferOpaqueCaptureAddressCreateInfo *CommandRecorder::CopyArray<VkBufferOpaqueCaptureAddressCreateInfo>(const VkBufferOpaqueCaptureAddressCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkBufferOpaqueCaptureAddressCreateInfo *>(m_allocator.Alloc(sizeof(VkBufferOpaqueCaptureAddressCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].opaqueCaptureAddress = src[start_index + i].opaqueCaptureAddress;
  }
  return ptr;
}

template<>
VkPhysicalDeviceImagelessFramebufferFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceImagelessFramebufferFeatures>(const VkPhysicalDeviceImagelessFramebufferFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceImagelessFramebufferFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceImagelessFramebufferFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].imagelessFramebuffer = src[start_index + i].imagelessFramebuffer;
  }
  return ptr;
}

template<>
VkFramebufferAttachmentsCreateInfo *CommandRecorder::CopyArray<VkFramebufferAttachmentsCreateInfo>(const VkFramebufferAttachmentsCreateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkFramebufferAttachmentsCreateInfo *>(m_allocator.Alloc(sizeof(VkFramebufferAttachmentsCreateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].attachmentImageInfoCount = src[start_index + i].attachmentImageInfoCount;
      ptr[i].pAttachmentImageInfos = nullptr;
      if (src[start_index + i].pAttachmentImageInfos) {
        ptr[i].pAttachmentImageInfos = CopyArray<>(src[start_index + i].pAttachmentImageInfos, 0, 1);
      }
  }
  return ptr;
}

template<>
VkFramebufferAttachmentImageInfo *CommandRecorder::CopyArray<VkFramebufferAttachmentImageInfo>(const VkFramebufferAttachmentImageInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkFramebufferAttachmentImageInfo *>(m_allocator.Alloc(sizeof(VkFramebufferAttachmentImageInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].usage = src[start_index + i].usage;
      ptr[i].width = src[start_index + i].width;
      ptr[i].height = src[start_index + i].height;
      ptr[i].layerCount = src[start_index + i].layerCount;
      ptr[i].viewFormatCount = src[start_index + i].viewFormatCount;
      ptr[i].pViewFormats = nullptr;
      if (src[start_index + i].pViewFormats) {
        ptr[i].pViewFormats = CopyArray<>(src[start_index + i].pViewFormats, 0, 1);
      }
  }
  return ptr;
}

template<>
VkRenderPassAttachmentBeginInfo *CommandRecorder::CopyArray<VkRenderPassAttachmentBeginInfo>(const VkRenderPassAttachmentBeginInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkRenderPassAttachmentBeginInfo *>(m_allocator.Alloc(sizeof(VkRenderPassAttachmentBeginInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].attachmentCount = src[start_index + i].attachmentCount;
      ptr[i].pAttachments = nullptr;
      if (src[start_index + i].pAttachments) {
        ptr[i].pAttachments = CopyArray<>(src[start_index + i].pAttachments, 0, 1);
      }
  }
  return ptr;
}

template<>
VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *CommandRecorder::CopyArray<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>(const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].separateDepthStencilLayouts = src[start_index + i].separateDepthStencilLayouts;
  }
  return ptr;
}

template<>
VkAttachmentReferenceStencilLayout *CommandRecorder::CopyArray<VkAttachmentReferenceStencilLayout>(const VkAttachmentReferenceStencilLayout *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAttachmentReferenceStencilLayout *>(m_allocator.Alloc(sizeof(VkAttachmentReferenceStencilLayout) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].stencilLayout = src[start_index + i].stencilLayout;
  }
  return ptr;
}

template<>
VkAttachmentDescriptionStencilLayout *CommandRecorder::CopyArray<VkAttachmentDescriptionStencilLayout>(const VkAttachmentDescriptionStencilLayout *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkAttachmentDescriptionStencilLayout *>(m_allocator.Alloc(sizeof(VkAttachmentDescriptionStencilLayout) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].stencilInitialLayout = src[start_index + i].stencilInitialLayout;
      ptr[i].stencilFinalLayout = src[start_index + i].stencilFinalLayout;
  }
  return ptr;
}

template<>
VkMemoryOpaqueCaptureAddressAllocateInfo *CommandRecorder::CopyArray<VkMemoryOpaqueCaptureAddressAllocateInfo>(const VkMemoryOpaqueCaptureAddressAllocateInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkMemoryOpaqueCaptureAddressAllocateInfo *>(m_allocator.Alloc(sizeof(VkMemoryOpaqueCaptureAddressAllocateInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].opaqueCaptureAddress = src[start_index + i].opaqueCaptureAddress;
  }
  return ptr;
}

template<>
VkDeviceMemoryOpaqueCaptureAddressInfo *CommandRecorder::CopyArray<VkDeviceMemoryOpaqueCaptureAddressInfo>(const VkDeviceMemoryOpaqueCaptureAddressInfo *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkDeviceMemoryOpaqueCaptureAddressInfo *>(m_allocator.Alloc(sizeof(VkDeviceMemoryOpaqueCaptureAddressInfo) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].memory = src[start_index + i].memory;
  }
  return ptr;
}

template<>
VkPhysicalDeviceVulkan11Features *CommandRecorder::CopyArray<VkPhysicalDeviceVulkan11Features>(const VkPhysicalDeviceVulkan11Features *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceVulkan11Features *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceVulkan11Features) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].storageBuffer16BitAccess = src[start_index + i].storageBuffer16BitAccess;
      ptr[i].uniformAndStorageBuffer16BitAccess = src[start_index + i].uniformAndStorageBuffer16BitAccess;
      ptr[i].storagePushConstant16 = src[start_index + i].storagePushConstant16;
      ptr[i].storageInputOutput16 = src[start_index + i].storageInputOutput16;
      ptr[i].multiview = src[start_index + i].multiview;
      ptr[i].multiviewGeometryShader = src[start_index + i].multiviewGeometryShader;
      ptr[i].multiviewTessellationShader = src[start_index + i].multiviewTessellationShader;
      ptr[i].variablePointersStorageBuffer = src[start_index + i].variablePointersStorageBuffer;
      ptr[i].variablePointers = src[start_index + i].variablePointers;
      ptr[i].protectedMemory = src[start_index + i].protectedMemory;
      ptr[i].samplerYcbcrConversion = src[start_index + i].samplerYcbcrConversion;
      ptr[i].shaderDrawParameters = src[start_index + i].shaderDrawParameters;
  }
  return ptr;
}

template<>
VkPhysicalDeviceVulkan11Properties *CommandRecorder::CopyArray<VkPhysicalDeviceVulkan11Properties>(const VkPhysicalDeviceVulkan11Properties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceVulkan11Properties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceVulkan11Properties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      std::memcpy(ptr[i].deviceUUID, src[start_index + i].deviceUUID, sizeof(src[start_index + i].deviceUUID));
      std::memcpy(ptr[i].driverUUID, src[start_index + i].driverUUID, sizeof(src[start_index + i].driverUUID));
      std::memcpy(ptr[i].deviceLUID, src[start_index + i].deviceLUID, sizeof(src[start_index + i].deviceLUID));
      ptr[i].deviceNodeMask = src[start_index + i].deviceNodeMask;
      ptr[i].deviceLUIDValid = src[start_index + i].deviceLUIDValid;
      ptr[i].subgroupSize = src[start_index + i].subgroupSize;
      ptr[i].subgroupSupportedStages = src[start_index + i].subgroupSupportedStages;
      ptr[i].subgroupSupportedOperations = src[start_index + i].subgroupSupportedOperations;
      ptr[i].subgroupQuadOperationsInAllStages = src[start_index + i].subgroupQuadOperationsInAllStages;
      ptr[i].pointClippingBehavior = src[start_index + i].pointClippingBehavior;
      ptr[i].maxMultiviewViewCount = src[start_index + i].maxMultiviewViewCount;
      ptr[i].maxMultiviewInstanceIndex = src[start_index + i].maxMultiviewInstanceIndex;
      ptr[i].protectedNoFault = src[start_index + i].protectedNoFault;
      ptr[i].maxPerSetDescriptors = src[start_index + i].maxPerSetDescriptors;
      ptr[i].maxMemoryAllocationSize = src[start_index + i].maxMemoryAllocationSize;
  }
  return ptr;
}

template<>
VkPhysicalDeviceVulkan12Features *CommandRecorder::CopyArray<VkPhysicalDeviceVulkan12Features>(const VkPhysicalDeviceVulkan12Features *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceVulkan12Features *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceVulkan12Features) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].samplerMirrorClampToEdge = src[start_index + i].samplerMirrorClampToEdge;
      ptr[i].drawIndirectCount = src[start_index + i].drawIndirectCount;
      ptr[i].storageBuffer8BitAccess = src[start_index + i].storageBuffer8BitAccess;
      ptr[i].uniformAndStorageBuffer8BitAccess = src[start_index + i].uniformAndStorageBuffer8BitAccess;
      ptr[i].storagePushConstant8 = src[start_index + i].storagePushConstant8;
      ptr[i].shaderBufferInt64Atomics = src[start_index + i].shaderBufferInt64Atomics;
      ptr[i].shaderSharedInt64Atomics = src[start_index + i].shaderSharedInt64Atomics;
      ptr[i].shaderFloat16 = src[start_index + i].shaderFloat16;
      ptr[i].shaderInt8 = src[start_index + i].shaderInt8;
      ptr[i].descriptorIndexing = src[start_index + i].descriptorIndexing;
      ptr[i].shaderInputAttachmentArrayDynamicIndexing = src[start_index + i].shaderInputAttachmentArrayDynamicIndexing;
      ptr[i].shaderUniformTexelBufferArrayDynamicIndexing = src[start_index + i].shaderUniformTexelBufferArrayDynamicIndexing;
      ptr[i].shaderStorageTexelBufferArrayDynamicIndexing = src[start_index + i].shaderStorageTexelBufferArrayDynamicIndexing;
      ptr[i].shaderUniformBufferArrayNonUniformIndexing = src[start_index + i].shaderUniformBufferArrayNonUniformIndexing;
      ptr[i].shaderSampledImageArrayNonUniformIndexing = src[start_index + i].shaderSampledImageArrayNonUniformIndexing;
      ptr[i].shaderStorageBufferArrayNonUniformIndexing = src[start_index + i].shaderStorageBufferArrayNonUniformIndexing;
      ptr[i].shaderStorageImageArrayNonUniformIndexing = src[start_index + i].shaderStorageImageArrayNonUniformIndexing;
      ptr[i].shaderInputAttachmentArrayNonUniformIndexing = src[start_index + i].shaderInputAttachmentArrayNonUniformIndexing;
      ptr[i].shaderUniformTexelBufferArrayNonUniformIndexing = src[start_index + i].shaderUniformTexelBufferArrayNonUniformIndexing;
      ptr[i].shaderStorageTexelBufferArrayNonUniformIndexing = src[start_index + i].shaderStorageTexelBufferArrayNonUniformIndexing;
      ptr[i].descriptorBindingUniformBufferUpdateAfterBind = src[start_index + i].descriptorBindingUniformBufferUpdateAfterBind;
      ptr[i].descriptorBindingSampledImageUpdateAfterBind = src[start_index + i].descriptorBindingSampledImageUpdateAfterBind;
      ptr[i].descriptorBindingStorageImageUpdateAfterBind = src[start_index + i].descriptorBindingStorageImageUpdateAfterBind;
      ptr[i].descriptorBindingStorageBufferUpdateAfterBind = src[start_index + i].descriptorBindingStorageBufferUpdateAfterBind;
      ptr[i].descriptorBindingUniformTexelBufferUpdateAfterBind = src[start_index + i].descriptorBindingUniformTexelBufferUpdateAfterBind;
      ptr[i].descriptorBindingStorageTexelBufferUpdateAfterBind = src[start_index + i].descriptorBindingStorageTexelBufferUpdateAfterBind;
      ptr[i].descriptorBindingUpdateUnusedWhilePending = src[start_index + i].descriptorBindingUpdateUnusedWhilePending;
      ptr[i].descriptorBindingPartiallyBound = src[start_index + i].descriptorBindingPartiallyBound;
      ptr[i].descriptorBindingVariableDescriptorCount = src[start_index + i].descriptorBindingVariableDescriptorCount;
      ptr[i].runtimeDescriptorArray = src[start_index + i].runtimeDescriptorArray;
      ptr[i].samplerFilterMinmax = src[start_index + i].samplerFilterMinmax;
      ptr[i].scalarBlockLayout = src[start_index + i].scalarBlockLayout;
      ptr[i].imagelessFramebuffer = src[start_index + i].imagelessFramebuffer;
      ptr[i].uniformBufferStandardLayout = src[start_index + i].uniformBufferStandardLayout;
      ptr[i].shaderSubgroupExtendedTypes = src[start_index + i].shaderSubgroupExtendedTypes;
      ptr[i].separateDepthStencilLayouts = src[start_index + i].separateDepthStencilLayouts;
      ptr[i].hostQueryReset = src[start_index + i].hostQueryReset;
      ptr[i].timelineSemaphore = src[start_index + i].timelineSemaphore;
      ptr[i].bufferDeviceAddress = src[start_index + i].bufferDeviceAddress;
      ptr[i].bufferDeviceAddressCaptureReplay = src[start_index + i].bufferDeviceAddressCaptureReplay;
      ptr[i].bufferDeviceAddressMultiDevice = src[start_index + i].bufferDeviceAddressMultiDevice;
      ptr[i].vulkanMemoryModel = src[start_index + i].vulkanMemoryModel;
      ptr[i].vulkanMemoryModelDeviceScope = src[start_index + i].vulkanMemoryModelDeviceScope;
      ptr[i].vulkanMemoryModelAvailabilityVisibilityChains = src[start_index + i].vulkanMemoryModelAvailabilityVisibilityChains;
      ptr[i].shaderOutputViewportIndex = src[start_index + i].shaderOutputViewportIndex;
      ptr[i].shaderOutputLayer = src[start_index + i].shaderOutputLayer;
      ptr[i].subgroupBroadcastDynamicId = src[start_index + i].subgroupBroadcastDynamicId;
  }
  return ptr;
}

template<>
VkPhysicalDeviceVulkan12Properties *CommandRecorder::CopyArray<VkPhysicalDeviceVulkan12Properties>(const VkPhysicalDeviceVulkan12Properties *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPhysicalDeviceVulkan12Properties *>(m_allocator.Alloc(sizeof(VkPhysicalDeviceVulkan12Properties) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].driverID = src[start_index + i].driverID;
      std::memcpy(ptr[i].driverName, src[start_index + i].driverName, sizeof(src[start_index + i].driverName));
      std::memcpy(ptr[i].driverInfo, src[start_index + i].driverInfo, sizeof(src[start_index + i].driverInfo));
      ptr[i].conformanceVersion = src[start_index + i].conformanceVersion;
      ptr[i].denormBehaviorIndependence = src[start_index + i].denormBehaviorIndependence;
      ptr[i].roundingModeIndependence = src[start_index + i].roundingModeIndependence;
      ptr[i].shaderSignedZeroInfNanPreserveFloat16 = src[start_index + i].shaderSignedZeroInfNanPreserveFloat16;
      ptr[i].shaderSignedZeroInfNanPreserveFloat32 = src[start_index + i].shaderSignedZeroInfNanPreserveFloat32;
      ptr[i].shaderSignedZeroInfNanPreserveFloat64 = src[start_index + i].shaderSignedZeroInfNanPreserveFloat64;
      ptr[i].shaderDenormPreserveFloat16 = src[start_index + i].shaderDenormPreserveFloat16;
      ptr[i].shaderDenormPreserveFloat32 = src[start_index + i].shaderDenormPreserveFloat32;
      ptr[i].shaderDenormPreserveFloat64 = src[start_index + i].shaderDenormPreserveFloat64;
      ptr[i].shaderDenormFlushToZeroFloat16 = src[start_index + i].shaderDenormFlushToZeroFloat16;
      ptr[i].shaderDenormFlushToZeroFloat32 = src[start_index + i].shaderDenormFlushToZeroFloat32;
      ptr[i].shaderDenormFlushToZeroFloat64 = src[start_index + i].shaderDenormFlushToZeroFloat64;
      ptr[i].shaderRoundingModeRTEFloat16 = src[start_index + i].shaderRoundingModeRTEFloat16;
      ptr[i].shaderRoundingModeRTEFloat32 = src[start_index + i].shaderRoundingModeRTEFloat32;
      ptr[i].shaderRoundingModeRTEFloat64 = src[start_index + i].shaderRoundingModeRTEFloat64;
      ptr[i].shaderRoundingModeRTZFloat16 = src[start_index + i].shaderRoundingModeRTZFloat16;
      ptr[i].shaderRoundingModeRTZFloat32 = src[start_index + i].shaderRoundingModeRTZFloat32;
      ptr[i].shaderRoundingModeRTZFloat64 = src[start_index + i].shaderRoundingModeRTZFloat64;
      ptr[i].maxUpdateAfterBindDescriptorsInAllPools = src[start_index + i].maxUpdateAfterBindDescriptorsInAllPools;
      ptr[i].shaderUniformBufferArrayNonUniformIndexingNative = src[start_index + i].shaderUniformBufferArrayNonUniformIndexingNative;
      ptr[i].shaderSampledImageArrayNonUniformIndexingNative = src[start_index + i].shaderSampledImageArrayNonUniformIndexingNative;
      ptr[i].shaderStorageBufferArrayNonUniformIndexingNative = src[start_index + i].shaderStorageBufferArrayNonUniformIndexingNative;
      ptr[i].shaderStorageImageArrayNonUniformIndexingNative = src[start_index + i].shaderStorageImageArrayNonUniformIndexingNative;
      ptr[i].shaderInputAttachmentArrayNonUniformIndexingNative = src[start_index + i].shaderInputAttachmentArrayNonUniformIndexingNative;
      ptr[i].robustBufferAccessUpdateAfterBind = src[start_index + i].robustBufferAccessUpdateAfterBind;
      ptr[i].quadDivergentImplicitLod = src[start_index + i].quadDivergentImplicitLod;
      ptr[i].maxPerStageDescriptorUpdateAfterBindSamplers = src[start_index + i].maxPerStageDescriptorUpdateAfterBindSamplers;
      ptr[i].maxPerStageDescriptorUpdateAfterBindUniformBuffers = src[start_index + i].maxPerStageDescriptorUpdateAfterBindUniformBuffers;
      ptr[i].maxPerStageDescriptorUpdateAfterBindStorageBuffers = src[start_index + i].maxPerStageDescriptorUpdateAfterBindStorageBuffers;
      ptr[i].maxPerStageDescriptorUpdateAfterBindSampledImages = src[start_index + i].maxPerStageDescriptorUpdateAfterBindSampledImages;
      ptr[i].maxPerStageDescriptorUpdateAfterBindStorageImages = src[start_index + i].maxPerStageDescriptorUpdateAfterBindStorageImages;
      ptr[i].maxPerStageDescriptorUpdateAfterBindInputAttachments = src[start_index + i].maxPerStageDescriptorUpdateAfterBindInputAttachments;
      ptr[i].maxPerStageUpdateAfterBindResources = src[start_index + i].maxPerStageUpdateAfterBindResources;
      ptr[i].maxDescriptorSetUpdateAfterBindSamplers = src[start_index + i].maxDescriptorSetUpdateAfterBindSamplers;
      ptr[i].maxDescriptorSetUpdateAfterBindUniformBuffers = src[start_index + i].maxDescriptorSetUpdateAfterBindUniformBuffers;
      ptr[i].maxDescriptorSetUpdateAfterBindUniformBuffersDynamic = src[start_index + i].maxDescriptorSetUpdateAfterBindUniformBuffersDynamic;
      ptr[i].maxDescriptorSetUpdateAfterBindStorageBuffers = src[start_index + i].maxDescriptorSetUpdateAfterBindStorageBuffers;
      ptr[i].maxDescriptorSetUpdateAfterBindStorageBuffersDynamic = src[start_index + i].maxDescriptorSetUpdateAfterBindStorageBuffersDynamic;
      ptr[i].maxDescriptorSetUpdateAfterBindSampledImages = src[start_index + i].maxDescriptorSetUpdateAfterBindSampledImages;
      ptr[i].maxDescriptorSetUpdateAfterBindStorageImages = src[start_index + i].maxDescriptorSetUpdateAfterBindStorageImages;
      ptr[i].maxDescriptorSetUpdateAfterBindInputAttachments = src[start_index + i].maxDescriptorSetUpdateAfterBindInputAttachments;
      ptr[i].supportedDepthResolveModes = src[start_index + i].supportedDepthResolveModes;
      ptr[i].supportedStencilResolveModes = src[start_index + i].supportedStencilResolveModes;
      ptr[i].independentResolveNone = src[start_index + i].independentResolveNone;
      ptr[i].independentResolve = src[start_index + i].independentResolve;
      ptr[i].filterMinmaxSingleComponentFormats = src[start_index + i].filterMinmaxSingleComponentFormats;
      ptr[i].filterMinmaxImageComponentMapping = src[start_index + i].filterMinmaxImageComponentMapping;
      ptr[i].maxTimelineSemaphoreValueDifference = src[start_index + i].maxTimelineSemaphoreValueDifference;
      ptr[i].framebufferIntegerColorSampleCounts = src[start_index + i].framebufferIntegerColorSampleCounts;
  }
  return ptr;
}



#ifdef VK_USE_PLATFORM_GGP 

template<>
VkStreamDescriptorSurfaceCreateInfoGGP *CommandRecorder::CopyArray<VkStreamDescriptorSurfaceCreateInfoGGP>(const VkStreamDescriptorSurfaceCreateInfoGGP *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkStreamDescriptorSurfaceCreateInfoGGP *>(m_allocator.Alloc(sizeof(VkStreamDescriptorSurfaceCreateInfoGGP) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].flags = src[start_index + i].flags;
      ptr[i].streamDescriptor = src[start_index + i].streamDescriptor;
  }
  return ptr;
}

template<>
VkPresentFrameTokenGGP *CommandRecorder::CopyArray<VkPresentFrameTokenGGP>(const VkPresentFrameTokenGGP *src, uint64_t start_index, uint64_t count) {
  auto ptr = reinterpret_cast<VkPresentFrameTokenGGP *>(m_allocator.Alloc(sizeof(VkPresentFrameTokenGGP) * count));
  for (uint64_t i = 0; i < count; ++i) {
      ptr[i].sType = src[start_index + i].sType;
      ptr[i].pNext = src[start_index + i].pNext;
      ptr[i].frameToken = src[start_index + i].frameToken;
  }
  return ptr;
}

#endif // VK_USE_PLATFORM_GGP


// Define arguments recorder functions.


CmdDrawMultiEXTArgs *CommandRecorder::RecordCmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT* pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride) {
  auto *args = Alloc<CmdDrawMultiEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->drawCount = drawCount;
  args->pVertexInfo = pVertexInfo;
  if (pVertexInfo) {
      args->pVertexInfo = CopyArray(pVertexInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(drawCount));
    }
  args->instanceCount = instanceCount;
  args->firstInstance = firstInstance;
  args->stride = stride;
  
  return args;
}

CmdDrawMultiIndexedEXTArgs *CommandRecorder::RecordCmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT* pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t* pVertexOffset) {
  auto *args = Alloc<CmdDrawMultiIndexedEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->drawCount = drawCount;
  args->pIndexInfo = pIndexInfo;
  if (pIndexInfo) {
      args->pIndexInfo = CopyArray(pIndexInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(drawCount));
    }
  args->instanceCount = instanceCount;
  args->firstInstance = firstInstance;
  args->stride = stride;
  args->pVertexOffset = pVertexOffset;
  if (pVertexOffset) {
      args->pVertexOffset = CopyArray(pVertexOffset, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdDebugMarkerBeginEXTArgs *CommandRecorder::RecordCmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo) {
  auto *args = Alloc<CmdDebugMarkerBeginEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->pMarkerInfo = pMarkerInfo;
  if (pMarkerInfo) {
      args->pMarkerInfo = CopyArray(pMarkerInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdDebugMarkerEndEXTArgs *CommandRecorder::RecordCmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer) {
  auto *args = Alloc<CmdDebugMarkerEndEXTArgs>();
  args->commandBuffer = commandBuffer;
  
  return args;
}

CmdDebugMarkerInsertEXTArgs *CommandRecorder::RecordCmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo) {
  auto *args = Alloc<CmdDebugMarkerInsertEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->pMarkerInfo = pMarkerInfo;
  if (pMarkerInfo) {
      args->pMarkerInfo = CopyArray(pMarkerInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdPushDescriptorSetKHRArgs *CommandRecorder::RecordCmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites) {
  auto *args = Alloc<CmdPushDescriptorSetKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pipelineBindPoint = pipelineBindPoint;
  args->layout = layout;
  args->set = set;
  args->descriptorWriteCount = descriptorWriteCount;
  args->pDescriptorWrites = pDescriptorWrites;
  if (pDescriptorWrites) {
      args->pDescriptorWrites = CopyArray(pDescriptorWrites, static_cast<uint64_t>(0U), static_cast<uint64_t>(descriptorWriteCount));
    }
  
  return args;
}

CmdSetDeviceMaskArgs *CommandRecorder::RecordCmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask) {
  auto *args = Alloc<CmdSetDeviceMaskArgs>();
  args->commandBuffer = commandBuffer;
  args->deviceMask = deviceMask;
  
  return args;
}

CmdSetDeviceMaskKHRArgs *CommandRecorder::RecordCmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask) {
  auto *args = Alloc<CmdSetDeviceMaskKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->deviceMask = deviceMask;
  
  return args;
}

CmdDispatchBaseArgs *CommandRecorder::RecordCmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
  auto *args = Alloc<CmdDispatchBaseArgs>();
  args->commandBuffer = commandBuffer;
  args->baseGroupX = baseGroupX;
  args->baseGroupY = baseGroupY;
  args->baseGroupZ = baseGroupZ;
  args->groupCountX = groupCountX;
  args->groupCountY = groupCountY;
  args->groupCountZ = groupCountZ;
  
  return args;
}

CmdDispatchBaseKHRArgs *CommandRecorder::RecordCmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
  auto *args = Alloc<CmdDispatchBaseKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->baseGroupX = baseGroupX;
  args->baseGroupY = baseGroupY;
  args->baseGroupZ = baseGroupZ;
  args->groupCountX = groupCountX;
  args->groupCountY = groupCountY;
  args->groupCountZ = groupCountZ;
  
  return args;
}

CmdPushDescriptorSetWithTemplateKHRArgs *CommandRecorder::RecordCmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData) {
  auto *args = Alloc<CmdPushDescriptorSetWithTemplateKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->descriptorUpdateTemplate = descriptorUpdateTemplate;
  args->layout = layout;
  args->set = set;
  args->pData = pData;
  
  return args;
}

CmdSetSampleLocationsEXTArgs *CommandRecorder::RecordCmdSetSampleLocationsEXT(VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT* pSampleLocationsInfo) {
  auto *args = Alloc<CmdSetSampleLocationsEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->pSampleLocationsInfo = pSampleLocationsInfo;
  if (pSampleLocationsInfo) {
      args->pSampleLocationsInfo = CopyArray(pSampleLocationsInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdBeginDebugUtilsLabelEXTArgs *CommandRecorder::RecordCmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo) {
  auto *args = Alloc<CmdBeginDebugUtilsLabelEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->pLabelInfo = pLabelInfo;
  if (pLabelInfo) {
      args->pLabelInfo = CopyArray(pLabelInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdEndDebugUtilsLabelEXTArgs *CommandRecorder::RecordCmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer) {
  auto *args = Alloc<CmdEndDebugUtilsLabelEXTArgs>();
  args->commandBuffer = commandBuffer;
  
  return args;
}

CmdInsertDebugUtilsLabelEXTArgs *CommandRecorder::RecordCmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo) {
  auto *args = Alloc<CmdInsertDebugUtilsLabelEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->pLabelInfo = pLabelInfo;
  if (pLabelInfo) {
      args->pLabelInfo = CopyArray(pLabelInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdWriteBufferMarkerAMDArgs *CommandRecorder::RecordCmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) {
  auto *args = Alloc<CmdWriteBufferMarkerAMDArgs>();
  args->commandBuffer = commandBuffer;
  args->pipelineStage = pipelineStage;
  args->dstBuffer = dstBuffer;
  args->dstOffset = dstOffset;
  args->marker = marker;
  
  return args;
}

CmdBeginRenderPass2Args *CommandRecorder::RecordCmdBeginRenderPass2(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo) {
  auto *args = Alloc<CmdBeginRenderPass2Args>();
  args->commandBuffer = commandBuffer;
  args->pRenderPassBegin = pRenderPassBegin;
  if (pRenderPassBegin) {
      args->pRenderPassBegin = CopyArray(pRenderPassBegin, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  args->pSubpassBeginInfo = pSubpassBeginInfo;
  if (pSubpassBeginInfo) {
      args->pSubpassBeginInfo = CopyArray(pSubpassBeginInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdBeginRenderPass2KHRArgs *CommandRecorder::RecordCmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, const VkSubpassBeginInfo* pSubpassBeginInfo) {
  auto *args = Alloc<CmdBeginRenderPass2KHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pRenderPassBegin = pRenderPassBegin;
  if (pRenderPassBegin) {
      args->pRenderPassBegin = CopyArray(pRenderPassBegin, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  args->pSubpassBeginInfo = pSubpassBeginInfo;
  if (pSubpassBeginInfo) {
      args->pSubpassBeginInfo = CopyArray(pSubpassBeginInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdNextSubpass2Args *CommandRecorder::RecordCmdNextSubpass2(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo* pSubpassBeginInfo, const VkSubpassEndInfo* pSubpassEndInfo) {
  auto *args = Alloc<CmdNextSubpass2Args>();
  args->commandBuffer = commandBuffer;
  args->pSubpassBeginInfo = pSubpassBeginInfo;
  if (pSubpassBeginInfo) {
      args->pSubpassBeginInfo = CopyArray(pSubpassBeginInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  args->pSubpassEndInfo = pSubpassEndInfo;
  if (pSubpassEndInfo) {
      args->pSubpassEndInfo = CopyArray(pSubpassEndInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdNextSubpass2KHRArgs *CommandRecorder::RecordCmdNextSubpass2KHR(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo* pSubpassBeginInfo, const VkSubpassEndInfo* pSubpassEndInfo) {
  auto *args = Alloc<CmdNextSubpass2KHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pSubpassBeginInfo = pSubpassBeginInfo;
  if (pSubpassBeginInfo) {
      args->pSubpassBeginInfo = CopyArray(pSubpassBeginInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  args->pSubpassEndInfo = pSubpassEndInfo;
  if (pSubpassEndInfo) {
      args->pSubpassEndInfo = CopyArray(pSubpassEndInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdEndRenderPass2Args *CommandRecorder::RecordCmdEndRenderPass2(VkCommandBuffer commandBuffer, const VkSubpassEndInfo* pSubpassEndInfo) {
  auto *args = Alloc<CmdEndRenderPass2Args>();
  args->commandBuffer = commandBuffer;
  args->pSubpassEndInfo = pSubpassEndInfo;
  if (pSubpassEndInfo) {
      args->pSubpassEndInfo = CopyArray(pSubpassEndInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdEndRenderPass2KHRArgs *CommandRecorder::RecordCmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, const VkSubpassEndInfo* pSubpassEndInfo) {
  auto *args = Alloc<CmdEndRenderPass2KHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pSubpassEndInfo = pSubpassEndInfo;
  if (pSubpassEndInfo) {
      args->pSubpassEndInfo = CopyArray(pSubpassEndInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdDrawIndirectCountArgs *CommandRecorder::RecordCmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
  auto *args = Alloc<CmdDrawIndirectCountArgs>();
  args->commandBuffer = commandBuffer;
  args->buffer = buffer;
  args->offset = offset;
  args->countBuffer = countBuffer;
  args->countBufferOffset = countBufferOffset;
  args->maxDrawCount = maxDrawCount;
  args->stride = stride;
  
  return args;
}

CmdDrawIndirectCountKHRArgs *CommandRecorder::RecordCmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
  auto *args = Alloc<CmdDrawIndirectCountKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->buffer = buffer;
  args->offset = offset;
  args->countBuffer = countBuffer;
  args->countBufferOffset = countBufferOffset;
  args->maxDrawCount = maxDrawCount;
  args->stride = stride;
  
  return args;
}

CmdDrawIndirectCountAMDArgs *CommandRecorder::RecordCmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
  auto *args = Alloc<CmdDrawIndirectCountAMDArgs>();
  args->commandBuffer = commandBuffer;
  args->buffer = buffer;
  args->offset = offset;
  args->countBuffer = countBuffer;
  args->countBufferOffset = countBufferOffset;
  args->maxDrawCount = maxDrawCount;
  args->stride = stride;
  
  return args;
}

CmdDrawIndexedIndirectCountArgs *CommandRecorder::RecordCmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
  auto *args = Alloc<CmdDrawIndexedIndirectCountArgs>();
  args->commandBuffer = commandBuffer;
  args->buffer = buffer;
  args->offset = offset;
  args->countBuffer = countBuffer;
  args->countBufferOffset = countBufferOffset;
  args->maxDrawCount = maxDrawCount;
  args->stride = stride;
  
  return args;
}

CmdDrawIndexedIndirectCountKHRArgs *CommandRecorder::RecordCmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
  auto *args = Alloc<CmdDrawIndexedIndirectCountKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->buffer = buffer;
  args->offset = offset;
  args->countBuffer = countBuffer;
  args->countBufferOffset = countBufferOffset;
  args->maxDrawCount = maxDrawCount;
  args->stride = stride;
  
  return args;
}

CmdDrawIndexedIndirectCountAMDArgs *CommandRecorder::RecordCmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
  auto *args = Alloc<CmdDrawIndexedIndirectCountAMDArgs>();
  args->commandBuffer = commandBuffer;
  args->buffer = buffer;
  args->offset = offset;
  args->countBuffer = countBuffer;
  args->countBufferOffset = countBufferOffset;
  args->maxDrawCount = maxDrawCount;
  args->stride = stride;
  
  return args;
}

CmdCopyAccelerationStructureKHRArgs *CommandRecorder::RecordCmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR* pInfo) {
  auto *args = Alloc<CmdCopyAccelerationStructureKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pInfo = pInfo;
  if (pInfo) {
      args->pInfo = CopyArray(pInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdCopyAccelerationStructureToMemoryKHRArgs *CommandRecorder::RecordCmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR* pInfo) {
  auto *args = Alloc<CmdCopyAccelerationStructureToMemoryKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pInfo = pInfo;
  if (pInfo) {
      args->pInfo = CopyArray(pInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdCopyMemoryToAccelerationStructureKHRArgs *CommandRecorder::RecordCmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR* pInfo) {
  auto *args = Alloc<CmdCopyMemoryToAccelerationStructureKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pInfo = pInfo;
  if (pInfo) {
      args->pInfo = CopyArray(pInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdWriteAccelerationStructuresPropertiesKHRArgs *CommandRecorder::RecordCmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) {
  auto *args = Alloc<CmdWriteAccelerationStructuresPropertiesKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->accelerationStructureCount = accelerationStructureCount;
  args->pAccelerationStructures = pAccelerationStructures;
  if (pAccelerationStructures) {
      args->pAccelerationStructures = CopyArray(pAccelerationStructures, static_cast<uint64_t>(0U), static_cast<uint64_t>(accelerationStructureCount));
    }
  args->queryType = queryType;
  args->queryPool = queryPool;
  args->firstQuery = firstQuery;
  
  return args;
}

CmdTraceRaysKHRArgs *CommandRecorder::RecordCmdTraceRaysKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth) {
  auto *args = Alloc<CmdTraceRaysKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pRaygenShaderBindingTable = pRaygenShaderBindingTable;
  if (pRaygenShaderBindingTable) {
      args->pRaygenShaderBindingTable = CopyArray(pRaygenShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  args->pMissShaderBindingTable = pMissShaderBindingTable;
  if (pMissShaderBindingTable) {
      args->pMissShaderBindingTable = CopyArray(pMissShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  args->pHitShaderBindingTable = pHitShaderBindingTable;
  if (pHitShaderBindingTable) {
      args->pHitShaderBindingTable = CopyArray(pHitShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  args->pCallableShaderBindingTable = pCallableShaderBindingTable;
  if (pCallableShaderBindingTable) {
      args->pCallableShaderBindingTable = CopyArray(pCallableShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  args->width = width;
  args->height = height;
  args->depth = depth;
  
  return args;
}

CmdTraceRaysIndirectKHRArgs *CommandRecorder::RecordCmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR* pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR* pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress) {
  auto *args = Alloc<CmdTraceRaysIndirectKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pRaygenShaderBindingTable = pRaygenShaderBindingTable;
  if (pRaygenShaderBindingTable) {
      args->pRaygenShaderBindingTable = CopyArray(pRaygenShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  args->pMissShaderBindingTable = pMissShaderBindingTable;
  if (pMissShaderBindingTable) {
      args->pMissShaderBindingTable = CopyArray(pMissShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  args->pHitShaderBindingTable = pHitShaderBindingTable;
  if (pHitShaderBindingTable) {
      args->pHitShaderBindingTable = CopyArray(pHitShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  args->pCallableShaderBindingTable = pCallableShaderBindingTable;
  if (pCallableShaderBindingTable) {
      args->pCallableShaderBindingTable = CopyArray(pCallableShaderBindingTable, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  args->indirectDeviceAddress = indirectDeviceAddress;
  
  return args;
}

CmdSetRayTracingPipelineStackSizeKHRArgs *CommandRecorder::RecordCmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize) {
  auto *args = Alloc<CmdSetRayTracingPipelineStackSizeKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pipelineStackSize = pipelineStackSize;
  
  return args;
}

CmdSetLineStippleEXTArgs *CommandRecorder::RecordCmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) {
  auto *args = Alloc<CmdSetLineStippleEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->lineStippleFactor = lineStippleFactor;
  args->lineStipplePattern = lineStipplePattern;
  
  return args;
}

CmdBuildAccelerationStructuresKHRArgs *CommandRecorder::RecordCmdBuildAccelerationStructuresKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkAccelerationStructureBuildRangeInfoKHR** ppBuildRangeInfos) {
  auto *args = Alloc<CmdBuildAccelerationStructuresKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->infoCount = infoCount;
  args->pInfos = pInfos;
  if (pInfos) {
      args->pInfos = CopyArray(pInfos, static_cast<uint64_t>(0U), static_cast<uint64_t>(infoCount));
    }
  args->ppBuildRangeInfos = ppBuildRangeInfos;
  if (ppBuildRangeInfos) {
      args->ppBuildRangeInfos = CopyArray(ppBuildRangeInfos, static_cast<uint64_t>(0U), static_cast<uint64_t>(infoCount));
    }
  
  return args;
}

CmdBuildAccelerationStructuresIndirectKHRArgs *CommandRecorder::RecordCmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR* pInfos, const VkDeviceAddress* pIndirectDeviceAddresses, const uint32_t* pIndirectStrides, const uint32_t** ppMaxPrimitiveCounts) {
  auto *args = Alloc<CmdBuildAccelerationStructuresIndirectKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->infoCount = infoCount;
  args->pInfos = pInfos;
  if (pInfos) {
      args->pInfos = CopyArray(pInfos, static_cast<uint64_t>(0U), static_cast<uint64_t>(infoCount));
    }
  args->pIndirectDeviceAddresses = pIndirectDeviceAddresses;
  if (pIndirectDeviceAddresses) {
      args->pIndirectDeviceAddresses = CopyArray(pIndirectDeviceAddresses, static_cast<uint64_t>(0U), static_cast<uint64_t>(infoCount));
    }
  args->pIndirectStrides = pIndirectStrides;
  if (pIndirectStrides) {
      args->pIndirectStrides = CopyArray(pIndirectStrides, static_cast<uint64_t>(0U), static_cast<uint64_t>(infoCount));
    }
  args->ppMaxPrimitiveCounts = ppMaxPrimitiveCounts;
  if (ppMaxPrimitiveCounts) {
      args->ppMaxPrimitiveCounts = CopyArray(ppMaxPrimitiveCounts, static_cast<uint64_t>(0U), static_cast<uint64_t>(infoCount));
    }
  
  return args;
}

CmdSetCullModeEXTArgs *CommandRecorder::RecordCmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
  auto *args = Alloc<CmdSetCullModeEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->cullMode = cullMode;
  
  return args;
}

CmdSetFrontFaceEXTArgs *CommandRecorder::RecordCmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
  auto *args = Alloc<CmdSetFrontFaceEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->frontFace = frontFace;
  
  return args;
}

CmdSetPrimitiveTopologyEXTArgs *CommandRecorder::RecordCmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) {
  auto *args = Alloc<CmdSetPrimitiveTopologyEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->primitiveTopology = primitiveTopology;
  
  return args;
}

CmdSetViewportWithCountEXTArgs *CommandRecorder::RecordCmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport* pViewports) {
  auto *args = Alloc<CmdSetViewportWithCountEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->viewportCount = viewportCount;
  args->pViewports = pViewports;
  if (pViewports) {
      args->pViewports = CopyArray(pViewports, static_cast<uint64_t>(0U), static_cast<uint64_t>(viewportCount));
    }
  
  return args;
}

CmdSetScissorWithCountEXTArgs *CommandRecorder::RecordCmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D* pScissors) {
  auto *args = Alloc<CmdSetScissorWithCountEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->scissorCount = scissorCount;
  args->pScissors = pScissors;
  if (pScissors) {
      args->pScissors = CopyArray(pScissors, static_cast<uint64_t>(0U), static_cast<uint64_t>(scissorCount));
    }
  
  return args;
}

CmdBindVertexBuffers2EXTArgs *CommandRecorder::RecordCmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes, const VkDeviceSize* pStrides) {
  auto *args = Alloc<CmdBindVertexBuffers2EXTArgs>();
  args->commandBuffer = commandBuffer;
  args->firstBinding = firstBinding;
  args->bindingCount = bindingCount;
  args->pBuffers = pBuffers;
  if (pBuffers) {
      args->pBuffers = CopyArray(pBuffers, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
  args->pOffsets = pOffsets;
  if (pOffsets) {
      args->pOffsets = CopyArray(pOffsets, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
  args->pSizes = pSizes;
  if (pSizes) {
      args->pSizes = CopyArray(pSizes, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
  args->pStrides = pStrides;
  if (pStrides) {
      args->pStrides = CopyArray(pStrides, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
  
  return args;
}

CmdSetDepthTestEnableEXTArgs *CommandRecorder::RecordCmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
  auto *args = Alloc<CmdSetDepthTestEnableEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->depthTestEnable = depthTestEnable;
  
  return args;
}

CmdSetDepthWriteEnableEXTArgs *CommandRecorder::RecordCmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
  auto *args = Alloc<CmdSetDepthWriteEnableEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->depthWriteEnable = depthWriteEnable;
  
  return args;
}

CmdSetDepthCompareOpEXTArgs *CommandRecorder::RecordCmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
  auto *args = Alloc<CmdSetDepthCompareOpEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->depthCompareOp = depthCompareOp;
  
  return args;
}

CmdSetDepthBoundsTestEnableEXTArgs *CommandRecorder::RecordCmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) {
  auto *args = Alloc<CmdSetDepthBoundsTestEnableEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->depthBoundsTestEnable = depthBoundsTestEnable;
  
  return args;
}

CmdSetStencilTestEnableEXTArgs *CommandRecorder::RecordCmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) {
  auto *args = Alloc<CmdSetStencilTestEnableEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->stencilTestEnable = stencilTestEnable;
  
  return args;
}

CmdSetStencilOpEXTArgs *CommandRecorder::RecordCmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) {
  auto *args = Alloc<CmdSetStencilOpEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->faceMask = faceMask;
  args->failOp = failOp;
  args->passOp = passOp;
  args->depthFailOp = depthFailOp;
  args->compareOp = compareOp;
  
  return args;
}

CmdSetPatchControlPointsEXTArgs *CommandRecorder::RecordCmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints) {
  auto *args = Alloc<CmdSetPatchControlPointsEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->patchControlPoints = patchControlPoints;
  
  return args;
}

CmdSetRasterizerDiscardEnableEXTArgs *CommandRecorder::RecordCmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) {
  auto *args = Alloc<CmdSetRasterizerDiscardEnableEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->rasterizerDiscardEnable = rasterizerDiscardEnable;
  
  return args;
}

CmdSetDepthBiasEnableEXTArgs *CommandRecorder::RecordCmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
  auto *args = Alloc<CmdSetDepthBiasEnableEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->depthBiasEnable = depthBiasEnable;
  
  return args;
}

CmdSetLogicOpEXTArgs *CommandRecorder::RecordCmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp) {
  auto *args = Alloc<CmdSetLogicOpEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->logicOp = logicOp;
  
  return args;
}

CmdSetPrimitiveRestartEnableEXTArgs *CommandRecorder::RecordCmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) {
  auto *args = Alloc<CmdSetPrimitiveRestartEnableEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->primitiveRestartEnable = primitiveRestartEnable;
  
  return args;
}

CmdCopyBuffer2KHRArgs *CommandRecorder::RecordCmdCopyBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2KHR* pCopyBufferInfo) {
  auto *args = Alloc<CmdCopyBuffer2KHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pCopyBufferInfo = pCopyBufferInfo;
  if (pCopyBufferInfo) {
      args->pCopyBufferInfo = CopyArray(pCopyBufferInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdCopyImage2KHRArgs *CommandRecorder::RecordCmdCopyImage2KHR(VkCommandBuffer commandBuffer, const VkCopyImageInfo2KHR* pCopyImageInfo) {
  auto *args = Alloc<CmdCopyImage2KHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pCopyImageInfo = pCopyImageInfo;
  if (pCopyImageInfo) {
      args->pCopyImageInfo = CopyArray(pCopyImageInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdBlitImage2KHRArgs *CommandRecorder::RecordCmdBlitImage2KHR(VkCommandBuffer commandBuffer, const VkBlitImageInfo2KHR* pBlitImageInfo) {
  auto *args = Alloc<CmdBlitImage2KHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pBlitImageInfo = pBlitImageInfo;
  if (pBlitImageInfo) {
      args->pBlitImageInfo = CopyArray(pBlitImageInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdCopyBufferToImage2KHRArgs *CommandRecorder::RecordCmdCopyBufferToImage2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2KHR* pCopyBufferToImageInfo) {
  auto *args = Alloc<CmdCopyBufferToImage2KHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pCopyBufferToImageInfo = pCopyBufferToImageInfo;
  if (pCopyBufferToImageInfo) {
      args->pCopyBufferToImageInfo = CopyArray(pCopyBufferToImageInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdCopyImageToBuffer2KHRArgs *CommandRecorder::RecordCmdCopyImageToBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2KHR* pCopyImageToBufferInfo) {
  auto *args = Alloc<CmdCopyImageToBuffer2KHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pCopyImageToBufferInfo = pCopyImageToBufferInfo;
  if (pCopyImageToBufferInfo) {
      args->pCopyImageToBufferInfo = CopyArray(pCopyImageToBufferInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdResolveImage2KHRArgs *CommandRecorder::RecordCmdResolveImage2KHR(VkCommandBuffer commandBuffer, const VkResolveImageInfo2KHR* pResolveImageInfo) {
  auto *args = Alloc<CmdResolveImage2KHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pResolveImageInfo = pResolveImageInfo;
  if (pResolveImageInfo) {
      args->pResolveImageInfo = CopyArray(pResolveImageInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdSetFragmentShadingRateKHRArgs *CommandRecorder::RecordCmdSetFragmentShadingRateKHR(VkCommandBuffer commandBuffer, const VkExtent2D* pFragmentSize, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) {
  auto *args = Alloc<CmdSetFragmentShadingRateKHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pFragmentSize = pFragmentSize;
  if (pFragmentSize) {
      args->pFragmentSize = CopyArray(pFragmentSize, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  for (uint32_t i = 0; i < 2; ++i) {
    args->combinerOps[i] = combinerOps[i];
  }
  
  return args;
}

CmdSetVertexInputEXTArgs *CommandRecorder::RecordCmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT* pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT* pVertexAttributeDescriptions) {
  auto *args = Alloc<CmdSetVertexInputEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->vertexBindingDescriptionCount = vertexBindingDescriptionCount;
  args->pVertexBindingDescriptions = pVertexBindingDescriptions;
  if (pVertexBindingDescriptions) {
      args->pVertexBindingDescriptions = CopyArray(pVertexBindingDescriptions, static_cast<uint64_t>(0U), static_cast<uint64_t>(vertexBindingDescriptionCount));
    }
  args->vertexAttributeDescriptionCount = vertexAttributeDescriptionCount;
  args->pVertexAttributeDescriptions = pVertexAttributeDescriptions;
  if (pVertexAttributeDescriptions) {
      args->pVertexAttributeDescriptions = CopyArray(pVertexAttributeDescriptions, static_cast<uint64_t>(0U), static_cast<uint64_t>(vertexAttributeDescriptionCount));
    }
  
  return args;
}

CmdSetColorWriteEnableEXTArgs *CommandRecorder::RecordCmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32* pColorWriteEnables) {
  auto *args = Alloc<CmdSetColorWriteEnableEXTArgs>();
  args->commandBuffer = commandBuffer;
  args->attachmentCount = attachmentCount;
  args->pColorWriteEnables = pColorWriteEnables;
  if (pColorWriteEnables) {
      args->pColorWriteEnables = CopyArray(pColorWriteEnables, static_cast<uint64_t>(0U), static_cast<uint64_t>(attachmentCount));
    }
  
  return args;
}

CmdSetEvent2KHRArgs *CommandRecorder::RecordCmdSetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfoKHR* pDependencyInfo) {
  auto *args = Alloc<CmdSetEvent2KHRArgs>();
  args->commandBuffer = commandBuffer;
  args->event = event;
  args->pDependencyInfo = pDependencyInfo;
  if (pDependencyInfo) {
      args->pDependencyInfo = CopyArray(pDependencyInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdResetEvent2KHRArgs *CommandRecorder::RecordCmdResetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2KHR stageMask) {
  auto *args = Alloc<CmdResetEvent2KHRArgs>();
  args->commandBuffer = commandBuffer;
  args->event = event;
  args->stageMask = stageMask;
  
  return args;
}

CmdWaitEvents2KHRArgs *CommandRecorder::RecordCmdWaitEvents2KHR(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, const VkDependencyInfoKHR* pDependencyInfos) {
  auto *args = Alloc<CmdWaitEvents2KHRArgs>();
  args->commandBuffer = commandBuffer;
  args->eventCount = eventCount;
  args->pEvents = pEvents;
  if (pEvents) {
      args->pEvents = CopyArray(pEvents, static_cast<uint64_t>(0U), static_cast<uint64_t>(eventCount));
    }
  args->pDependencyInfos = pDependencyInfos;
  if (pDependencyInfos) {
      args->pDependencyInfos = CopyArray(pDependencyInfos, static_cast<uint64_t>(0U), static_cast<uint64_t>(eventCount));
    }
  
  return args;
}

CmdPipelineBarrier2KHRArgs *CommandRecorder::RecordCmdPipelineBarrier2KHR(VkCommandBuffer commandBuffer, const VkDependencyInfoKHR* pDependencyInfo) {
  auto *args = Alloc<CmdPipelineBarrier2KHRArgs>();
  args->commandBuffer = commandBuffer;
  args->pDependencyInfo = pDependencyInfo;
  if (pDependencyInfo) {
      args->pDependencyInfo = CopyArray(pDependencyInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

CmdWriteTimestamp2KHRArgs *CommandRecorder::RecordCmdWriteTimestamp2KHR(VkCommandBuffer commandBuffer, VkPipelineStageFlags2KHR stage, VkQueryPool queryPool, uint32_t query) {
  auto *args = Alloc<CmdWriteTimestamp2KHRArgs>();
  args->commandBuffer = commandBuffer;
  args->stage = stage;
  args->queryPool = queryPool;
  args->query = query;
  
  return args;
}

CmdWriteBufferMarker2AMDArgs *CommandRecorder::RecordCmdWriteBufferMarker2AMD(VkCommandBuffer commandBuffer, VkPipelineStageFlags2KHR stage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) {
  auto *args = Alloc<CmdWriteBufferMarker2AMDArgs>();
  args->commandBuffer = commandBuffer;
  args->stage = stage;
  args->dstBuffer = dstBuffer;
  args->dstOffset = dstOffset;
  args->marker = marker;
  
  return args;
}

BeginCommandBufferArgs *CommandRecorder::RecordBeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo) {
  auto *args = Alloc<BeginCommandBufferArgs>();
  args->commandBuffer = commandBuffer;
  args->pBeginInfo = pBeginInfo;
  if (pBeginInfo) {
      args->pBeginInfo = CopyArray(pBeginInfo, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  
  return args;
}

EndCommandBufferArgs *CommandRecorder::RecordEndCommandBuffer(VkCommandBuffer commandBuffer) {
  auto *args = Alloc<EndCommandBufferArgs>();
  args->commandBuffer = commandBuffer;
  
  return args;
}

ResetCommandBufferArgs *CommandRecorder::RecordResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags) {
  auto *args = Alloc<ResetCommandBufferArgs>();
  args->commandBuffer = commandBuffer;
  args->flags = flags;
  
  return args;
}

CmdBindPipelineArgs *CommandRecorder::RecordCmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) {
  auto *args = Alloc<CmdBindPipelineArgs>();
  args->commandBuffer = commandBuffer;
  args->pipelineBindPoint = pipelineBindPoint;
  args->pipeline = pipeline;
  
  return args;
}

CmdSetViewportArgs *CommandRecorder::RecordCmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport* pViewports) {
  auto *args = Alloc<CmdSetViewportArgs>();
  args->commandBuffer = commandBuffer;
  args->firstViewport = firstViewport;
  args->viewportCount = viewportCount;
  args->pViewports = pViewports;
  if (pViewports) {
      args->pViewports = CopyArray(pViewports, static_cast<uint64_t>(0U), static_cast<uint64_t>(viewportCount));
    }
  
  return args;
}

CmdSetScissorArgs *CommandRecorder::RecordCmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors) {
  auto *args = Alloc<CmdSetScissorArgs>();
  args->commandBuffer = commandBuffer;
  args->firstScissor = firstScissor;
  args->scissorCount = scissorCount;
  args->pScissors = pScissors;
  if (pScissors) {
      args->pScissors = CopyArray(pScissors, static_cast<uint64_t>(0U), static_cast<uint64_t>(scissorCount));
    }
  
  return args;
}

CmdSetLineWidthArgs *CommandRecorder::RecordCmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth) {
  auto *args = Alloc<CmdSetLineWidthArgs>();
  args->commandBuffer = commandBuffer;
  args->lineWidth = lineWidth;
  
  return args;
}

CmdSetDepthBiasArgs *CommandRecorder::RecordCmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor) {
  auto *args = Alloc<CmdSetDepthBiasArgs>();
  args->commandBuffer = commandBuffer;
  args->depthBiasConstantFactor = depthBiasConstantFactor;
  args->depthBiasClamp = depthBiasClamp;
  args->depthBiasSlopeFactor = depthBiasSlopeFactor;
  
  return args;
}

CmdSetBlendConstantsArgs *CommandRecorder::RecordCmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4]) {
  auto *args = Alloc<CmdSetBlendConstantsArgs>();
  args->commandBuffer = commandBuffer;
  for (uint32_t i = 0; i < 4; ++i) {
    args->blendConstants[i] = blendConstants[i];
  }
  
  return args;
}

CmdSetDepthBoundsArgs *CommandRecorder::RecordCmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds) {
  auto *args = Alloc<CmdSetDepthBoundsArgs>();
  args->commandBuffer = commandBuffer;
  args->minDepthBounds = minDepthBounds;
  args->maxDepthBounds = maxDepthBounds;
  
  return args;
}

CmdSetStencilCompareMaskArgs *CommandRecorder::RecordCmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask) {
  auto *args = Alloc<CmdSetStencilCompareMaskArgs>();
  args->commandBuffer = commandBuffer;
  args->faceMask = faceMask;
  args->compareMask = compareMask;
  
  return args;
}

CmdSetStencilWriteMaskArgs *CommandRecorder::RecordCmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask) {
  auto *args = Alloc<CmdSetStencilWriteMaskArgs>();
  args->commandBuffer = commandBuffer;
  args->faceMask = faceMask;
  args->writeMask = writeMask;
  
  return args;
}

CmdSetStencilReferenceArgs *CommandRecorder::RecordCmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference) {
  auto *args = Alloc<CmdSetStencilReferenceArgs>();
  args->commandBuffer = commandBuffer;
  args->faceMask = faceMask;
  args->reference = reference;
  
  return args;
}

CmdBindDescriptorSetsArgs *CommandRecorder::RecordCmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets) {
  auto *args = Alloc<CmdBindDescriptorSetsArgs>();
  args->commandBuffer = commandBuffer;
  args->pipelineBindPoint = pipelineBindPoint;
  args->layout = layout;
  args->firstSet = firstSet;
  args->descriptorSetCount = descriptorSetCount;
  args->pDescriptorSets = pDescriptorSets;
  if (pDescriptorSets) {
      args->pDescriptorSets = CopyArray(pDescriptorSets, static_cast<uint64_t>(0U), static_cast<uint64_t>(descriptorSetCount));
    }
  args->dynamicOffsetCount = dynamicOffsetCount;
  args->pDynamicOffsets = pDynamicOffsets;
  if (pDynamicOffsets) {
      args->pDynamicOffsets = CopyArray(pDynamicOffsets, static_cast<uint64_t>(0U), static_cast<uint64_t>(dynamicOffsetCount));
    }
  
  return args;
}

CmdBindIndexBufferArgs *CommandRecorder::RecordCmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType) {
  auto *args = Alloc<CmdBindIndexBufferArgs>();
  args->commandBuffer = commandBuffer;
  args->buffer = buffer;
  args->offset = offset;
  args->indexType = indexType;
  
  return args;
}

CmdBindVertexBuffersArgs *CommandRecorder::RecordCmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets) {
  auto *args = Alloc<CmdBindVertexBuffersArgs>();
  args->commandBuffer = commandBuffer;
  args->firstBinding = firstBinding;
  args->bindingCount = bindingCount;
  args->pBuffers = pBuffers;
  if (pBuffers) {
      args->pBuffers = CopyArray(pBuffers, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
  args->pOffsets = pOffsets;
  if (pOffsets) {
      args->pOffsets = CopyArray(pOffsets, static_cast<uint64_t>(0U), static_cast<uint64_t>(bindingCount));
    }
  
  return args;
}

CmdDrawArgs *CommandRecorder::RecordCmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {
  auto *args = Alloc<CmdDrawArgs>();
  args->commandBuffer = commandBuffer;
  args->vertexCount = vertexCount;
  args->instanceCount = instanceCount;
  args->firstVertex = firstVertex;
  args->firstInstance = firstInstance;
  
  return args;
}

CmdDrawIndexedArgs *CommandRecorder::RecordCmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) {
  auto *args = Alloc<CmdDrawIndexedArgs>();
  args->commandBuffer = commandBuffer;
  args->indexCount = indexCount;
  args->instanceCount = instanceCount;
  args->firstIndex = firstIndex;
  args->vertexOffset = vertexOffset;
  args->firstInstance = firstInstance;
  
  return args;
}

CmdDrawIndirectArgs *CommandRecorder::RecordCmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
  auto *args = Alloc<CmdDrawIndirectArgs>();
  args->commandBuffer = commandBuffer;
  args->buffer = buffer;
  args->offset = offset;
  args->drawCount = drawCount;
  args->stride = stride;
  
  return args;
}

CmdDrawIndexedIndirectArgs *CommandRecorder::RecordCmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
  auto *args = Alloc<CmdDrawIndexedIndirectArgs>();
  args->commandBuffer = commandBuffer;
  args->buffer = buffer;
  args->offset = offset;
  args->drawCount = drawCount;
  args->stride = stride;
  
  return args;
}

CmdDispatchArgs *CommandRecorder::RecordCmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
  auto *args = Alloc<CmdDispatchArgs>();
  args->commandBuffer = commandBuffer;
  args->groupCountX = groupCountX;
  args->groupCountY = groupCountY;
  args->groupCountZ = groupCountZ;
  
  return args;
}

CmdDispatchIndirectArgs *CommandRecorder::RecordCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) {
  auto *args = Alloc<CmdDispatchIndirectArgs>();
  args->commandBuffer = commandBuffer;
  args->buffer = buffer;
  args->offset = offset;
  
  return args;
}

CmdCopyBufferArgs *CommandRecorder::RecordCmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions) {
  auto *args = Alloc<CmdCopyBufferArgs>();
  args->commandBuffer = commandBuffer;
  args->srcBuffer = srcBuffer;
  args->dstBuffer = dstBuffer;
  args->regionCount = regionCount;
  args->pRegions = pRegions;
  if (pRegions) {
      args->pRegions = CopyArray(pRegions, static_cast<uint64_t>(0U), static_cast<uint64_t>(regionCount));
    }
  
  return args;
}

CmdCopyImageArgs *CommandRecorder::RecordCmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy* pRegions) {
  auto *args = Alloc<CmdCopyImageArgs>();
  args->commandBuffer = commandBuffer;
  args->srcImage = srcImage;
  args->srcImageLayout = srcImageLayout;
  args->dstImage = dstImage;
  args->dstImageLayout = dstImageLayout;
  args->regionCount = regionCount;
  args->pRegions = pRegions;
  if (pRegions) {
      args->pRegions = CopyArray(pRegions, static_cast<uint64_t>(0U), static_cast<uint64_t>(regionCount));
    }
  
  return args;
}

CmdBlitImageArgs *CommandRecorder::RecordCmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit* pRegions, VkFilter filter) {
  auto *args = Alloc<CmdBlitImageArgs>();
  args->commandBuffer = commandBuffer;
  args->srcImage = srcImage;
  args->srcImageLayout = srcImageLayout;
  args->dstImage = dstImage;
  args->dstImageLayout = dstImageLayout;
  args->regionCount = regionCount;
  args->pRegions = pRegions;
  if (pRegions) {
      args->pRegions = CopyArray(pRegions, static_cast<uint64_t>(0U), static_cast<uint64_t>(regionCount));
    }
  args->filter = filter;
  
  return args;
}

CmdCopyBufferToImageArgs *CommandRecorder::RecordCmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions) {
  auto *args = Alloc<CmdCopyBufferToImageArgs>();
  args->commandBuffer = commandBuffer;
  args->srcBuffer = srcBuffer;
  args->dstImage = dstImage;
  args->dstImageLayout = dstImageLayout;
  args->regionCount = regionCount;
  args->pRegions = pRegions;
  if (pRegions) {
      args->pRegions = CopyArray(pRegions, static_cast<uint64_t>(0U), static_cast<uint64_t>(regionCount));
    }
  
  return args;
}

CmdCopyImageToBufferArgs *CommandRecorder::RecordCmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions) {
  auto *args = Alloc<CmdCopyImageToBufferArgs>();
  args->commandBuffer = commandBuffer;
  args->srcImage = srcImage;
  args->srcImageLayout = srcImageLayout;
  args->dstBuffer = dstBuffer;
  args->regionCount = regionCount;
  args->pRegions = pRegions;
  if (pRegions) {
      args->pRegions = CopyArray(pRegions, static_cast<uint64_t>(0U), static_cast<uint64_t>(regionCount));
    }
  
  return args;
}

CmdUpdateBufferArgs *CommandRecorder::RecordCmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData) {
  auto *args = Alloc<CmdUpdateBufferArgs>();
  args->commandBuffer = commandBuffer;
  args->dstBuffer = dstBuffer;
  args->dstOffset = dstOffset;
  args->dataSize = dataSize;
  args->pData = pData;
  
  return args;
}

CmdFillBufferArgs *CommandRecorder::RecordCmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data) {
  auto *args = Alloc<CmdFillBufferArgs>();
  args->commandBuffer = commandBuffer;
  args->dstBuffer = dstBuffer;
  args->dstOffset = dstOffset;
  args->size = size;
  args->data = data;
  
  return args;
}

CmdClearColorImageArgs *CommandRecorder::RecordCmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue* pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges) {
  auto *args = Alloc<CmdClearColorImageArgs>();
  args->commandBuffer = commandBuffer;
  args->image = image;
  args->imageLayout = imageLayout;
  args->pColor = pColor;
  if (pColor) {
      args->pColor = CopyArray(pColor, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  args->rangeCount = rangeCount;
  args->pRanges = pRanges;
  if (pRanges) {
      args->pRanges = CopyArray(pRanges, static_cast<uint64_t>(0U), static_cast<uint64_t>(rangeCount));
    }
  
  return args;
}

CmdClearDepthStencilImageArgs *CommandRecorder::RecordCmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges) {
  auto *args = Alloc<CmdClearDepthStencilImageArgs>();
  args->commandBuffer = commandBuffer;
  args->image = image;
  args->imageLayout = imageLayout;
  args->pDepthStencil = pDepthStencil;
  if (pDepthStencil) {
      args->pDepthStencil = CopyArray(pDepthStencil, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  args->rangeCount = rangeCount;
  args->pRanges = pRanges;
  if (pRanges) {
      args->pRanges = CopyArray(pRanges, static_cast<uint64_t>(0U), static_cast<uint64_t>(rangeCount));
    }
  
  return args;
}

CmdClearAttachmentsArgs *CommandRecorder::RecordCmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects) {
  auto *args = Alloc<CmdClearAttachmentsArgs>();
  args->commandBuffer = commandBuffer;
  args->attachmentCount = attachmentCount;
  args->pAttachments = pAttachments;
  if (pAttachments) {
      args->pAttachments = CopyArray(pAttachments, static_cast<uint64_t>(0U), static_cast<uint64_t>(attachmentCount));
    }
  args->rectCount = rectCount;
  args->pRects = pRects;
  if (pRects) {
      args->pRects = CopyArray(pRects, static_cast<uint64_t>(0U), static_cast<uint64_t>(rectCount));
    }
  
  return args;
}

CmdResolveImageArgs *CommandRecorder::RecordCmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve* pRegions) {
  auto *args = Alloc<CmdResolveImageArgs>();
  args->commandBuffer = commandBuffer;
  args->srcImage = srcImage;
  args->srcImageLayout = srcImageLayout;
  args->dstImage = dstImage;
  args->dstImageLayout = dstImageLayout;
  args->regionCount = regionCount;
  args->pRegions = pRegions;
  if (pRegions) {
      args->pRegions = CopyArray(pRegions, static_cast<uint64_t>(0U), static_cast<uint64_t>(regionCount));
    }
  
  return args;
}

CmdSetEventArgs *CommandRecorder::RecordCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) {
  auto *args = Alloc<CmdSetEventArgs>();
  args->commandBuffer = commandBuffer;
  args->event = event;
  args->stageMask = stageMask;
  
  return args;
}

CmdResetEventArgs *CommandRecorder::RecordCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) {
  auto *args = Alloc<CmdResetEventArgs>();
  args->commandBuffer = commandBuffer;
  args->event = event;
  args->stageMask = stageMask;
  
  return args;
}

CmdWaitEventsArgs *CommandRecorder::RecordCmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers) {
  auto *args = Alloc<CmdWaitEventsArgs>();
  args->commandBuffer = commandBuffer;
  args->eventCount = eventCount;
  args->pEvents = pEvents;
  if (pEvents) {
      args->pEvents = CopyArray(pEvents, static_cast<uint64_t>(0U), static_cast<uint64_t>(eventCount));
    }
  args->srcStageMask = srcStageMask;
  args->dstStageMask = dstStageMask;
  args->memoryBarrierCount = memoryBarrierCount;
  args->pMemoryBarriers = pMemoryBarriers;
  if (pMemoryBarriers) {
      args->pMemoryBarriers = CopyArray(pMemoryBarriers, static_cast<uint64_t>(0U), static_cast<uint64_t>(memoryBarrierCount));
    }
  args->bufferMemoryBarrierCount = bufferMemoryBarrierCount;
  args->pBufferMemoryBarriers = pBufferMemoryBarriers;
  if (pBufferMemoryBarriers) {
      args->pBufferMemoryBarriers = CopyArray(pBufferMemoryBarriers, static_cast<uint64_t>(0U), static_cast<uint64_t>(bufferMemoryBarrierCount));
    }
  args->imageMemoryBarrierCount = imageMemoryBarrierCount;
  args->pImageMemoryBarriers = pImageMemoryBarriers;
  if (pImageMemoryBarriers) {
      args->pImageMemoryBarriers = CopyArray(pImageMemoryBarriers, static_cast<uint64_t>(0U), static_cast<uint64_t>(imageMemoryBarrierCount));
    }
  
  return args;
}

CmdPipelineBarrierArgs *CommandRecorder::RecordCmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers) {
  auto *args = Alloc<CmdPipelineBarrierArgs>();
  args->commandBuffer = commandBuffer;
  args->srcStageMask = srcStageMask;
  args->dstStageMask = dstStageMask;
  args->dependencyFlags = dependencyFlags;
  args->memoryBarrierCount = memoryBarrierCount;
  args->pMemoryBarriers = pMemoryBarriers;
  if (pMemoryBarriers) {
      args->pMemoryBarriers = CopyArray(pMemoryBarriers, static_cast<uint64_t>(0U), static_cast<uint64_t>(memoryBarrierCount));
    }
  args->bufferMemoryBarrierCount = bufferMemoryBarrierCount;
  args->pBufferMemoryBarriers = pBufferMemoryBarriers;
  if (pBufferMemoryBarriers) {
      args->pBufferMemoryBarriers = CopyArray(pBufferMemoryBarriers, static_cast<uint64_t>(0U), static_cast<uint64_t>(bufferMemoryBarrierCount));
    }
  args->imageMemoryBarrierCount = imageMemoryBarrierCount;
  args->pImageMemoryBarriers = pImageMemoryBarriers;
  if (pImageMemoryBarriers) {
      args->pImageMemoryBarriers = CopyArray(pImageMemoryBarriers, static_cast<uint64_t>(0U), static_cast<uint64_t>(imageMemoryBarrierCount));
    }
  
  return args;
}

CmdBeginQueryArgs *CommandRecorder::RecordCmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags) {
  auto *args = Alloc<CmdBeginQueryArgs>();
  args->commandBuffer = commandBuffer;
  args->queryPool = queryPool;
  args->query = query;
  args->flags = flags;
  
  return args;
}

CmdEndQueryArgs *CommandRecorder::RecordCmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query) {
  auto *args = Alloc<CmdEndQueryArgs>();
  args->commandBuffer = commandBuffer;
  args->queryPool = queryPool;
  args->query = query;
  
  return args;
}

CmdResetQueryPoolArgs *CommandRecorder::RecordCmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {
  auto *args = Alloc<CmdResetQueryPoolArgs>();
  args->commandBuffer = commandBuffer;
  args->queryPool = queryPool;
  args->firstQuery = firstQuery;
  args->queryCount = queryCount;
  
  return args;
}

CmdWriteTimestampArgs *CommandRecorder::RecordCmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query) {
  auto *args = Alloc<CmdWriteTimestampArgs>();
  args->commandBuffer = commandBuffer;
  args->pipelineStage = pipelineStage;
  args->queryPool = queryPool;
  args->query = query;
  
  return args;
}

CmdCopyQueryPoolResultsArgs *CommandRecorder::RecordCmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags) {
  auto *args = Alloc<CmdCopyQueryPoolResultsArgs>();
  args->commandBuffer = commandBuffer;
  args->queryPool = queryPool;
  args->firstQuery = firstQuery;
  args->queryCount = queryCount;
  args->dstBuffer = dstBuffer;
  args->dstOffset = dstOffset;
  args->stride = stride;
  args->flags = flags;
  
  return args;
}

CmdPushConstantsArgs *CommandRecorder::RecordCmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues) {
  auto *args = Alloc<CmdPushConstantsArgs>();
  args->commandBuffer = commandBuffer;
  args->layout = layout;
  args->stageFlags = stageFlags;
  args->offset = offset;
  args->size = size;
  args->pValues = pValues;
  
  return args;
}

CmdBeginRenderPassArgs *CommandRecorder::RecordCmdBeginRenderPass(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents) {
  auto *args = Alloc<CmdBeginRenderPassArgs>();
  args->commandBuffer = commandBuffer;
  args->pRenderPassBegin = pRenderPassBegin;
  if (pRenderPassBegin) {
      args->pRenderPassBegin = CopyArray(pRenderPassBegin, static_cast<uint64_t>(0U), static_cast<uint64_t>(1U));
    }
  args->contents = contents;
  
  return args;
}

CmdNextSubpassArgs *CommandRecorder::RecordCmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents) {
  auto *args = Alloc<CmdNextSubpassArgs>();
  args->commandBuffer = commandBuffer;
  args->contents = contents;
  
  return args;
}

CmdEndRenderPassArgs *CommandRecorder::RecordCmdEndRenderPass(VkCommandBuffer commandBuffer) {
  auto *args = Alloc<CmdEndRenderPassArgs>();
  args->commandBuffer = commandBuffer;
  
  return args;
}

CmdExecuteCommandsArgs *CommandRecorder::RecordCmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers) {
  auto *args = Alloc<CmdExecuteCommandsArgs>();
  args->commandBuffer = commandBuffer;
  args->commandBufferCount = commandBufferCount;
  args->pCommandBuffers = pCommandBuffers;
  if (pCommandBuffers) {
      args->pCommandBuffers = CopyArray(pCommandBuffers, static_cast<uint64_t>(0U), static_cast<uint64_t>(commandBufferCount));
    }
  
  return args;
}

#ifdef VK_USE_PLATFORM_GGP 

#endif // VK_USE_PLATFORM_GGP
